<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BLISS 98</title>
    <link rel="icon" href="/assets/favicon/favicon.ico" sizes="any" />
    <link rel="icon" type="image/png" href="/assets/favicon/favicon-32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="/assets/favicon/favicon-16.png" sizes="16x16" />
    <link rel="apple-touch-icon" href="/assets/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/favicon/site.webmanifest" />
    <style>
      :root{
        --bg:#008080;
        --shadow-dark:#0a0a0a;
        --shadow-mid:#808080;
        --shadow-light:#dfdfdf;
        --shadow-white:#ffffff;
        --title:#000080;
        --title2:#1084d0;
        --titlebar-text:#ffffff;
        --task:#c0c0c0;
        --text:#000;
        --menu:#c0c0c0;
        --select:#000080;
        --select-text:#ffffff;
        --content-bg:#ffffff;
        --content-text:#000000;
        --panel-bg:#e9e9e9;
        --panel-in:#ffffff;
        --panel-border:#808080;
        --input-bg:#ffffff;
        --input-text:#000000;
        --menu-text:#000000;
        --link:#0000ee;
        --sep:#9a9a9a;
        --sep-light:#ffffff;
        --selection-bg:#d6e6ff;
        --selection-border:#000080;
        --kbd-bg:#ffffff;
        --kbd-border:#999999;
        --btn-text:#000000;
        --muted-text:#4b4b4b;
      }
      body.theme-xp98{
        --shadow-dark:#2b3a52;
        --shadow-mid:#6f86a6;
        --shadow-light:#edf2fb;
        --shadow-white:#ffffff;
        --task:#d4d9e3;
        --text:#000000;
        --menu:#dfe4ec;
        --select:#316ac5;
        --select-text:#ffffff;
        --content-bg:#ffffff;
        --content-text:#000000;
        --panel-bg:#dfe4ec;
        --panel-in:#ffffff;
        --panel-border:#7f93ad;
        --input-bg:#ffffff;
        --input-text:#000000;
        --menu-text:#000000;
        --link:#1b4f9c;
        --sep:#9aa9c2;
        --sep-light:#ffffff;
        --selection-bg:#c8d8f2;
        --selection-border:#316ac5;
        --kbd-bg:#f7f7f7;
        --kbd-border:#7f93ad;
        --btn-text:#000000;
        --muted-text:#4b4b4b;
      }
      body.theme-xp98 .taskbar.bevel{
        background:linear-gradient(90deg, #1d3e8a, #2a5db3);
      }
      body.theme-xp98 #startBtn.btn.bevel{
        background:linear-gradient(180deg, #38c85a, #1f9b3f);
        color:#ffffff;
        border-top-color:#c7f3cf;
        border-left-color:#c7f3cf;
        border-right-color:#0b6d2a;
        border-bottom-color:#0b6d2a;
        box-shadow: 1px 1px 0 0 rgba(255,255,255,0.25) inset, -1px -1px 0 0 rgba(0,0,0,0.2) inset;
      }
      body.theme-xp98 .tray.bevel{
        background:linear-gradient(180deg, #5a8fe2, #3f6fc8);
      }
      body.dark{
        --shadow-dark:#000000;
        --shadow-mid:#1c1c1c;
        --shadow-light:#3a3a3a;
        --shadow-white:#5a5a5a;
        --title:#1b3f7a;
        --title2:#0a2e5c;
        --titlebar-text:#f1f1f1;
        --task:#2a2a2a;
        --text:#e6e6e6;
        --menu:#2a2a2a;
        --select:#1b3f7a;
        --select-text:#f1f1f1;
        --content-bg:#1f1f1f;
        --content-text:#e6e6e6;
        --panel-bg:#303030;
        --panel-in:#1b1b1b;
        --panel-border:#5a5a5a;
        --input-bg:#1b1b1b;
        --input-text:#e6e6e6;
        --menu-text:#f1f1f1;
        --link:#8bb6ff;
        --sep:#4a4a4a;
        --sep-light:#2a2a2a;
        --selection-bg:#1c3f66;
        --selection-border:#9ec5ff;
        --kbd-bg:#1b1b1b;
        --kbd-border:#5a5a5a;
        --btn-text:#e0e0e0;
        --muted-text:#b9b9b9;
      }
      body.titlebar-blank .titlebar{
        background:transparent !important;
        background-image:none !important;
        box-shadow:none !important;
        color:var(--titlebar-text);
        text-shadow:1px 1px 0 rgba(0,0,0,0.55);
        border-top:1px solid var(--shadow-white);
        border-left:1px solid var(--shadow-white);
        border-right:1px solid var(--shadow-dark);
        border-bottom:1px solid var(--shadow-dark);
      }
      body.titlebar-blank .modal-titlebar{
        background:transparent !important;
        background-image:none !important;
        box-shadow:none !important;
        color:var(--titlebar-text);
        text-shadow:1px 1px 0 rgba(0,0,0,0.55);
        border-top:1px solid var(--shadow-white);
        border-left:1px solid var(--shadow-white);
        border-right:1px solid var(--shadow-dark);
        border-bottom:1px solid var(--shadow-dark);
      }
      body.titlebar-blank .start-side{
        background:var(--task);
        color:var(--text);
      }
      body.retro-glow .window .frame{
        box-shadow: 0 0 10px rgba(255,255,255,0.12);
      }
      body.retro-glow .icon span{
        text-shadow: 0 0 6px rgba(255,255,255,0.35);
      }

      html,body{height:100%;margin:0;}
      body{
        background:var(--bg);
        color:var(--text);
        font-family:"MS Sans Serif", Tahoma, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        font-size:13px;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        -webkit-touch-callout:none;
        -webkit-tap-highlight-color: transparent;
      }
      .hidden{display:none !important;}
      .pixel{image-rendering:pixelated; image-rendering:crisp-edges;}

      .bevel{
        background:var(--task);
        border-top:2px solid var(--shadow-white);
        border-left:2px solid var(--shadow-white);
        border-right:2px solid var(--shadow-dark);
        border-bottom:2px solid var(--shadow-dark);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .bevel-in{
        background:var(--panel-in);
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .btn{
        height:24px;
        padding:0 10px;
        display:inline-flex;
        align-items:center;
        gap:6px;
        cursor:pointer;
        color:var(--btn-text);
      }
      .btn:active{ filter:brightness(0.97); }
      .btn.pressed{
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }

      #app{height:100%;}

      #login{
        position:absolute; inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:radial-gradient(circle at 40% 35%, rgba(255,255,255,.15), rgba(255,255,255,0) 45%), var(--bg);
      }
      .login-panel{
        width:min(520px, calc(100% - 32px));
        padding:14px;
      }
      .login-title{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        margin-bottom:10px;
      }
      .login-left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .lang-btn{
        min-width:70px;
        justify-content:center;
        font-weight:700;
      }
      .logo{ width:34px; height:34px; }
      .login-title h1{
        font-size:18px;
        margin:0;
        letter-spacing:0.2px;
      }
      .login-sub{opacity:.9;margin:2px 0 0 0;}
      .field-row{display:flex; gap:8px; align-items:center; margin-top:12px;}
      label{white-space:nowrap;}
      input[type="text"]{
        flex:1;
        height:26px;
        padding:0 8px;
        outline:none;
        background:var(--input-bg);
        color:var(--input-text);
        border:1px solid var(--panel-border);
      }
      .login-footer{display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:10px;}
      .tiny{font-size:12px; opacity:.85; user-select:text;}
      .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:var(--kbd-bg); padding:1px 5px; border:1px solid var(--kbd-border);}

      #desktop{ position:absolute; inset:0; background:var(--bg); }
      #desktop.wallpaper-matrix{
        background-color:#020202;
        background-image:
          repeating-linear-gradient(90deg, rgba(0,255,90,0.18) 0 1px, transparent 1px 4px),
          repeating-linear-gradient(180deg, rgba(0,255,90,0.12) 0 2px, transparent 2px 10px),
          linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.9));
        background-size: 4px 100%, 100% 120px, 100% 100%;
        background-repeat: repeat;
        animation: matrixFlow 6s linear infinite;
      }
      @keyframes matrixFlow{
        from{ background-position: 0 0, 0 0, 0 0; }
        to{ background-position: 0 0, 0 240px, 0 0; }
      }
      .desktop-area{
        position:absolute; inset:0 0 30px 0;
        padding:10px;
      }
      .drag-layer{
        position:absolute;
        inset:0;
        z-index:9999;
        pointer-events:none;
      }
      .drag-layer.active{
        pointer-events:auto;
      }
      .games-drag-ghost{
        position:absolute;
        width:92px;
        opacity:0.85;
        pointer-events:none;
      }
      .games-drag-ghost.big{
        width:140px;
      }

      .icons{
        position:relative;
        width:100%;
        height:100%;
      }
      .icon{
        position:absolute;
        width:92px;
        height:88px;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        gap:6px;
        padding:6px 4px;
        border:1px solid transparent;
        cursor:default;
      }
      .icon[data-app-id="settings"] img{
        width:36px;
        height:36px;
      }
      .icon.selected{
        border:1px dotted rgba(255,255,255,0.9);
        background:rgba(0,0,0,0.12);
      }
      .icon span{
        color:#fff;
        text-align:center;
        line-height:1.1;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.65);
        padding:1px 2px;
        max-width:86px;
        word-break:break-word;
      }
      .icon.selected span{
        background:var(--select);
        outline:1px dotted var(--select-text);
      }
      .icon.trashed{
        opacity:0.65;
      }
      .wallpaper-swatch{
        width:18px;
        height:18px;
        border:1px solid #000;
        box-shadow: inset 1px 1px 0 rgba(255,255,255,0.35);
      }

      .taskbar{
        position:absolute;
        left:0; right:0; bottom:0;
        height:30px;
        display:flex;
        align-items:center;
        gap:6px;
        padding:2px 6px;
        color:var(--text);
      }
      .task-left{display:flex; align-items:center; gap:6px;}
      .task-buttons{
        display:flex;
        align-items:center;
        gap:4px;
        flex:1;
        overflow:auto hidden;
        padding:0 6px;
      }
      .task-buttons::-webkit-scrollbar{height:8px;}
      .task-buttons::-webkit-scrollbar-thumb{background:var(--sep);}
      .task-right{ display:flex; align-items:center; gap:8px; }
      .tray{
        height:24px;
        display:flex;
        align-items:center;
        padding:0 8px;
        color:var(--text);
      }
      .clock{min-width:72px; text-align:right; font-variant-numeric:tabular-nums;}

      .start-menu{
        position:absolute;
        left:6px;
        bottom:32px;
        width:260px;
        display:flex;
        padding:0;
        color:var(--menu-text);
      }
      .start-side{
        width:30px;
        background:linear-gradient(var(--title), var(--shadow-dark));
        color:#fff;
        display:flex;
        align-items:flex-end;
        justify-content:center;
        padding:8px 0;
      }
      .start-side span{
        writing-mode:vertical-rl;
        transform:rotate(180deg);
        letter-spacing:1px;
        font-weight:700;
      }
      .start-list{ flex:1; padding:2px; }
      .start-list .menu-item{
        width:100%;
        box-sizing:border-box;
        overflow:hidden;
      }
      .start-list .menu-item > div:last-child{
        flex:1;
        min-width:0;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }
      #startMenu .menu-item img[data-app-id="settings"]{
        width:18px;
        height:18px;
      }
      .menu-item{
        display:flex;
        align-items:center;
        gap:10px;
        padding:6px 8px;
        cursor:pointer;
      }
      .menu-drop .menu-item{
        color:var(--menu-text);
        background:transparent;
      }
      .menu-drop .menu-item:disabled,
      .menu-drop .menu-item.disabled{
        color:var(--muted-text);
        cursor:default;
      }
      .menu-item:hover{
        background:var(--select);
        color:var(--select-text);
      }
      .menu-sep{height:1px; background:var(--sep); margin:2px 0;}
      /* Desktop context menu (Win98 style) */
      .ctx-menu{
  position:absolute;
  min-width:220px;
  padding:2px;
  z-index:9999;
  color:var(--menu-text);
}
.ctx-item{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:6px 8px;
  background:transparent;
  border:0;
  font:inherit;
  color:inherit;
  cursor:pointer;
  text-align:left;
}
.ctx-item:hover,
.ctx-item:focus{
  background:var(--select);
  color:var(--select-text);
  outline:none;
}
.ctx-left{display:flex; align-items:center; gap:10px;}
.ctx-sep{height:1px; background:var(--sep); margin:2px 0;}
.ctx-check{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  opacity:.95;
}
.ctx-shortcut{opacity:.85; font-size:12px;}
.ctx-item:hover .ctx-shortcut,
.ctx-item:focus .ctx-shortcut{opacity:1;}

@media (max-width: 720px){
  .ctx-menu{min-width:200px;}
  .ctx-item{padding:10px 10px;}
}

      .window{ position:absolute; min-width:320px; min-height:220px; }
      .window.anim-open{
        animation:winOpen 160ms ease-out;
        transform-origin:top left;
      }
      .window.anim-close{
        animation:winClose 140ms ease-in forwards;
        transform-origin:top left;
        pointer-events:none;
      }
      .window.anim-minimize{
        animation:winMinimize 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window.anim-restore{
        animation:winRestore 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window .frame{height:100%; display:flex; flex-direction:column;}
      .titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 3px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:var(--titlebar-text);
        cursor:move;
        touch-action:none;
      }
      .title-left{display:flex; align-items:center; gap:6px;}
      .title-left strong{font-weight:700; font-size:12px;}
      .title-controls{display:flex; gap:4px;}
      .wctl{
        width:18px; height:18px;
        display:flex; align-items:center; justify-content:center;
        cursor:pointer;
        font-size:12px;
        line-height:1;
        color:var(--btn-text);
      }
      .titlebar .wctl,
      .modal-titlebar .wctl{
        color:var(--titlebar-text);
      }
      .menubar{
        height:22px;
        display:flex;
        align-items:center;
        gap:14px;
        padding:0 8px;
        background:var(--task);
        border-bottom:1px solid var(--sep);
        user-select:none;
        color:var(--text);
      }
      .menubar span{
        cursor:default;
        padding:0 6px;
      }
      .menubar span.active{
        background:var(--select);
        color:var(--select-text);
      }
      .menu-drop{
        position:absolute;
        min-width:190px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:5;
        color:var(--menu-text);
      }
      .menu-drop.hidden{display:none;}
      .menu-item{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        width:100%;
        padding:4px 8px;
        background:transparent;
        border:0;
        text-align:left;
        font:inherit;
        cursor:default;
        position:relative;
      }
      .menu-item:hover,
      .menu-item:focus{
        background:var(--select);
        color:var(--select-text);
        outline:none;
      }
      .menu-left{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .menu-check{
        width:16px;
        display:inline-flex;
        justify-content:center;
      }
      .menu-right{
        min-width:16px;
        text-align:right;
      }
      .menu-sep{
        height:1px;
        background:var(--sep);
        margin:2px 0;
      }
      .menu-item.has-sub:hover > .menu-sub,
      .menu-item.has-sub:focus-within > .menu-sub{
        display:block;
      }
      .menu-sub{
        position:absolute;
        top:-4px;
        left:100%;
        margin-left:2px;
        display:none;
        min-width:180px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:6;
        color:var(--menu-text);
      }
      .content{
        flex:1;
        padding:10px;
        overflow:auto;
        background:var(--content-bg);
        color:var(--content-text);
        user-select:text;
        -webkit-user-select:text;
      }
      .content.trash-empty{
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
      }
      .trash-actions{
        display:flex;
        align-items:center;
        gap:8px;
        padding:2px 8px;
        height:auto;
        background:var(--task);
        border-bottom:1px solid var(--sep);
        flex-wrap:wrap;
      }
      .trash-actions .btn{
        height:20px;
        padding:0 8px;
        white-space:nowrap;
      }
      @media (max-width: 420px){
        .trash-actions .btn{
          height:auto;
          line-height:1.1;
          white-space:normal;
          padding:2px 6px;
          flex:1 1 45%;
          min-width:120px;
        }
      }
      .content h2{margin:0 0 8px 0; font-size:16px;}
      .content p{margin:0 0 10px 0; line-height:1.35;}
      .content .card{ padding:10px; margin:10px 0; }
      .content a{color:var(--link);}
      .statusbar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:0 8px;
        background:var(--task);
        border-top:1px solid var(--sep);
        font-size:12px;
        position:relative;
        color:var(--text);
      }
      .status-center{
        position:absolute;
        left:50%;
        transform:translateX(-50%);
        pointer-events:none;
      }

      .resize{
        position:absolute;
        width:14px; height:14px;
        right:2px; bottom:2px;
        cursor:nwse-resize;
        background:conic-gradient(from 225deg, #0000 0 25%, #666 0 35%, #0000 0 50%, #666 0 60%, #0000 0 75%, #666 0 85%, #0000 0 100%);
        opacity:.55;
        touch-action:none;
      }

      /* Desktop selection box (Win98-like) */
      .rubberband{
        position:absolute;
        pointer-events:none;
        border:1px dotted var(--select-text);
        background:rgba(0,0,128,0.18);
        box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset;
      }

      /* While dragging/resizing/selecting, hard-disable selection everywhere */
      body.dragging, body.dragging *{
        user-select:none !important;
        -webkit-user-select:none !important;
      }

      /* Keep normal selection inside content and inputs */
      .content, .content *{
        user-select:text;
        -webkit-user-select:text;
      }
      input, textarea{
        user-select:text;
        -webkit-user-select:text;
      }
      input[type="text"], select, textarea{
        background:var(--input-bg);
        color:var(--input-text);
        border:1px solid var(--panel-border);
      }

      .hr98{height:1px; background:var(--sep); border-bottom:1px solid var(--sep-light); margin:10px 0;}
      .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
      .list98{padding-left:18px; margin:0;}
      .tag{
        display:inline-block;
        padding:1px 6px;
        border:1px solid var(--panel-border);
        background:var(--panel-bg);
        margin-right:6px;
        font-size:12px;
      }
      .videos-shell{
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .videos-header{
        display:flex;
        flex-wrap:wrap;
        gap:8px 12px;
        align-items:center;
      }
      .videos-header a{
        color:var(--link);
        text-decoration:underline;
      }
      .videos-player{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .videos-player-head{
        display:flex;
        flex-wrap:wrap;
        align-items:center;
        gap:8px 12px;
        justify-content:space-between;
      }
      .videos-player-actions{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
      }
      .videos-embed{
        padding:4px;
      }
      .videos-embed-inner{
        position:relative;
        width:100%;
        padding-top:56.25%;
        background:#000;
      }
      .videos-embed-inner iframe{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        border:0;
      }
      .videos-list{
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(180px, 1fr));
        gap:10px;
      }
      .videos-item{
        display:flex;
        gap:8px;
        align-items:flex-start;
        padding:6px;
        border:1px solid transparent;
        background:var(--content-bg);
        color:var(--content-text);
        text-align:left;
        cursor:default;
      }
      .videos-item.selected{
        border:1px dotted var(--select-text);
        background:var(--selection-bg);
      }
      .videos-thumb{
        width:96px;
        height:54px;
        flex:0 0 auto;
        border:1px solid var(--panel-border);
        background:#000;
        object-fit:cover;
      }
      .videos-meta{
        display:flex;
        flex-direction:column;
        gap:4px;
        min-width:0;
      }
      .videos-title{
        font-weight:700;
        font-size:12px;
        line-height:1.2;
      }
      .videos-sub{
        font-size:11px;
        opacity:.85;
      }
      @media (max-width: 520px){
        .videos-item{
          flex-direction:column;
          align-items:flex-start;
        }
        .videos-thumb{
          width:100%;
          height:auto;
          aspect-ratio:16/9;
        }
      }
      .music-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 120px);
        gap:14px;
        align-items:start;
      }
      .music-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:8px;
        width:120px;
        max-width:120px;
        padding:8px 6px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
        color:var(--content-text);
      }
      .music-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .music-item span{
        text-align:center;
        line-height:1.1;
        max-width:112px;
        word-break:break-word;
      }
      .music-icon{
        width:56px;
        height:56px;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .music-icon img{
        width:48px;
        height:48px;
      }
      .music-small .music-item{padding:6px; gap:6px;}
      .music-small .music-icon{width:40px; height:40px;}
      .music-small .music-icon img{width:32px; height:32px;}
      .music-small .music-label{font-size:12px;}
      .music-hide-icons .music-icon{display:none;}
      .games-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .games-grid.games-big{
        grid-template-columns: repeat(auto-fill, 140px);
        gap:16px;
      }
      .games-list{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .games-item{
        background:transparent;
        border:1px solid transparent;
        width:92px;
        max-width:92px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:default;
      }
      .games-list .games-item{
        width:100%;
        max-width:100%;
        flex-direction:row;
        justify-content:flex-start;
        gap:10px;
      }
      .games-grid.games-big .games-item{
        width:140px;
        max-width:140px;
        gap:8px;
        padding:8px 6px;
      }
      .games-icon{
        width:34px;
        height:34px;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .games-grid.games-big .games-icon{
        width:56px;
        height:56px;
      }
      .games-grid.games-big .games-icon img{
        width:48px;
        height:48px;
      }
      .games-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .games-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .snake-layout{
        display:flex;
        gap:12px;
        flex-wrap:wrap;
        align-items:stretch;
      }
      .snake-board{
        flex:0 0 auto;
        width:336px;
        height:336px;
        min-width:336px;
        min-height:336px;
        max-width:100%;
        max-height:100%;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        padding:8px;
        background:var(--panel-in);
        touch-action:none;
      }
      .snake-board canvas{
        touch-action:none;
      }
      .snake-side{
        width:200px;
        min-width:180px;
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .snake-controls{
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .snake-controls .btn{
        justify-content:center;
      }
      .snake-speed{
        display:flex;
        flex-direction:column;
        gap:4px;
      }
      .snake-speed select{
        height:24px;
      }
      .snake-overlay{
        position:absolute;
        inset:8px;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(233,233,233,0.85);
      }
      body.dark .snake-overlay{
        background:rgba(20,20,20,0.85);
      }
      .snake-overlay-box{
        display:flex;
        flex-direction:column;
        gap:8px;
        padding:10px 12px;
        min-width:160px;
        text-align:center;
      }
      .snake-instructions{
        line-height:1.3;
      }
      @media (max-width: 520px){
        .music-grid{
          grid-template-columns:1fr;
        }
        .music-item{
          width:100%;
          max-width:100%;
          flex-direction:row;
          justify-content:flex-start;
        }
        .music-item span{
          max-width:none;
          text-align:left;
        }
        .games-grid{
          grid-template-columns:repeat(2, minmax(0, 1fr));
        }
        .games-item{
          width:100%;
          max-width:100%;
        }
        .snake-side{
          width:100%;
          min-width:0;
        }
        .snake-board{
          width:336px;
          height:336px;
          min-width:336px;
          min-height:336px;
          margin:0 auto;
        }
      }
      .settings-shell{
        display:flex;
        flex-direction:column;
        gap:0;
      }
      .settings-tabs{
        display:flex;
        gap:4px;
        padding:4px 6px 0;
        overflow-x:auto;
        -webkit-overflow-scrolling:touch;
      }
      .settings-tab{
        padding:4px 10px;
        background:var(--task);
        border:1px solid var(--panel-border);
        border-bottom:none;
        cursor:pointer;
        white-space:nowrap;
        color:var(--btn-text);
      }
      .settings-tab[aria-selected="true"]{
        background:var(--panel-bg);
        position:relative;
        top:1px;
        z-index:1;
        color:var(--content-text);
      }
      .settings-panels{
        padding:0 6px 6px;
      }
      .settings-panel{
        display:none;
        padding:12px;
        background:var(--panel-bg);
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        min-height:200px;
      }
      .settings-panel.active{display:block;}
      .settings-general{
        display:flex;
        gap:14px;
        flex-wrap:wrap;
        align-items:flex-start;
      }
      .settings-panel-header{
        display:flex;
        align-items:center;
        gap:10px;
        margin-bottom:10px;
      }
      .titlebar-swatch{
        width:16px;
        height:16px;
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        flex-shrink:0;
      }
      .settings-panel-icon{
        width:48px;
        height:48px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        background:var(--panel-bg);
        flex-shrink:0;
      }
      .settings-panel-icon img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .theme-grid{
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(140px, 1fr));
        gap:10px;
        margin-top:8px;
      }
      .theme-thumb{
        display:flex;
        flex-direction:column;
        gap:6px;
        padding:6px;
        text-align:left;
        background:var(--content-bg);
        color:var(--content-text);
        border:1px solid var(--panel-border);
        cursor:pointer;
      }
      .theme-thumb .theme-preview{
        height:60px;
        border:1px solid var(--panel-border);
        display:flex;
        flex-direction:column;
        background:var(--panel-bg);
      }
      .theme-preview-bar{
        height:14px;
      }
      .theme-preview-body{
        flex:1;
        background:var(--content-bg);
      }
      .theme-thumb.selected{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .theme-thumb.disabled{
        opacity:0.6;
        cursor:default;
      }
      .theme-preview-default .theme-preview-bar{
        background:linear-gradient(90deg, #000080, #1084d0);
      }
      .theme-preview-totvers .theme-preview-bar{
        background:linear-gradient(90deg, #f6a6cf, #e46aa9);
      }
      .theme-preview-matrix .theme-preview-bar{
        background:linear-gradient(90deg, #1b4a2a, #0e2e1a);
      }
      .theme-preview-xp98 .theme-preview-bar{
        background:linear-gradient(90deg, #0a2e8f, #4f86d8);
      }
      .theme-preview-blank .theme-preview-bar{
        background:transparent;
        border-bottom:1px solid var(--panel-border);
      }
      .theme-preview-custom .theme-preview-bar{
        background:linear-gradient(90deg, #666, #999);
      }
      .settings-logo{
        width:96px;
        height:72px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:2px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        background:var(--panel-bg);
      }
      .settings-logo img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .settings-summary{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .settings-block{
        margin-top:8px;
        padding-top:8px;
        border-top:1px solid var(--sep);
      }
      .settings-actions{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
      }
      @media (max-width: 520px){
        .settings-general{flex-direction:column;}
        .settings-logo{width:100%; height:72px;}
        .settings-panel-header{align-items:flex-start;}
      }
      .clothes-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap:12px;
        align-items:start;
      }
      .clothes-item{
        display:flex;
        align-items:center;
        justify-content:center;
        padding:6px;
        border:1px solid transparent;
        background:transparent;
      }
      .clothes-item:focus,
      .clothes-item:focus-visible{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .clothes-thumb{
        width:100%;
        height:auto;
        aspect-ratio:1/1;
        object-fit:cover;
        border:1px solid var(--panel-border);
        background:var(--panel-in);
        display:block;
      }
      .clothes-status{
        margin-top:10px;
      }
      @media (max-width: 520px){
        .clothes-grid{
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .poetry-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        justify-items:start;
      }
      .poetry-item{
        background:transparent;
        border:1px solid transparent;
        width:92px;
        max-width:92px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:default;
      }
      .poetry-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .poetry-item span{
        text-align:center;
        line-height:1.1;
        max-width:110px;
        word-break:break-word;
      }
      .poem-body{
        white-space:pre-line;
        line-height:1.4;
      }
      .trash-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .trash-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        width:92px;
        max-width:92px;
        padding:6px 4px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
      }
      .trash-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .trash-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .trash-empty-msg{
        font-weight:700;
      }
      .mp-compact .content{padding:6px;}
      .mp-compact .card{padding:6px;}
      .mp-hide-list #mpList,
      .mp-hide-list #mpMsg{display:none;}
      .mp-item.selected{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      #win_mediaplayer .content{
        background:var(--task);
        padding:8px;
        display:flex;
        justify-content:center;
        align-items:flex-start;
      }
      .mp-mini{
        width:min(360px, 100%);
        padding:8px;
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .mp-now{
        display:flex;
        align-items:baseline;
        gap:6px;
      }
      .mp-title{
        font-weight:700;
        min-width:0;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }
      .mp-controls{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
        justify-content:center;
      }
      .mp-controls .btn{
        height:24px;
        padding:0 8px;
      }
      .mp-seek-row{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .mp-seek{
        flex:1;
        min-width:140px;
      }
      .mp-time{
        font-variant-numeric:tabular-nums;
        white-space:nowrap;
      }
      .mp-bottom{
        display:flex;
        align-items:center;
        gap:8px;
        flex-wrap:wrap;
        justify-content:space-between;
      }
      .mp-actions{
        display:flex;
        gap:6px;
        flex-wrap:wrap;
      }
      .mp-actions .btn{
        height:22px;
        padding:0 8px;
      }
      .mp-vol{
        display:flex;
        align-items:center;
        gap:6px;
      }
      .mp-status{
        min-height:14px;
      }
      .mp-drop{
        border:1px dotted var(--selection-border);
        background:var(--panel-bg);
        text-align:center;
        padding:6px;
      }
      .mp-drop.active{
        background:var(--selection-bg);
      }
      .diev-small .content{font-size:12px;}
      .diev-large .content{font-size:15px;}
      .diev-contrast .content{
        background:#000;
        color:#fff;
      }
      .diev-contrast .content a{color:#9ad0ff;}
      .art-zoom-50 .content{font-size:12px;}
      .art-zoom-100 .content{font-size:13px;}
      .art-zoom-200 .content{font-size:16px;}
      body.scanlines::before{
        content:"";
        position:fixed;
        inset:0;
        background:repeating-linear-gradient(
          0deg,
          rgba(0,0,0,0.15) 0,
          rgba(0,0,0,0.15) 1px,
          rgba(255,255,255,0) 2px,
          rgba(255,255,255,0) 3px
        );
        pointer-events:none;
        z-index:9999;
      }
      .modal{
        position:fixed;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(0,0,0,0.25);
        z-index:9998;
        padding:12px;
        box-sizing:border-box;
        overflow:auto;
      }
      .modal.hidden{display:none;}
      .modal-box{
        min-width:280px;
        max-width:520px;
        width:100%;
        max-height:calc(100% - 12px);
        display:flex;
        flex-direction:column;
      }
      .modal-titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 4px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:var(--titlebar-text);
      }
      .modal-body{
        padding:10px;
        background:var(--content-bg);
        color:var(--content-text);
        overflow:auto;
        max-height:calc(100% - 72px);
      }
      .modal-body input,
      .modal-body select{
        max-width:100%;
        box-sizing:border-box;
      }
      .modal-actions{
        display:flex;
        justify-content:flex-end;
        gap:8px;
        padding:10px;
        background:var(--task);
        border-top:1px solid var(--sep);
      }
      @keyframes winOpen{
        from{opacity:0; transform:scale(0.98);}
        to{opacity:1; transform:scale(1);}
      }
      @keyframes winClose{
        from{opacity:1; transform:scale(1);}
        to{opacity:0; transform:scale(0.96);}
      }
      @keyframes winMinimize{
        0%{opacity:1; transform:translate(0,0) scale(1);}
        100%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
      }
      @keyframes winRestore{
        0%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
        100%{opacity:1; transform:translate(0,0) scale(1);}
      }

      @media (max-width: 720px){
        .icons{grid-template-rows: repeat(5, 88px);}
        .window{min-width:280px;}
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="login">
        <div class="login-panel bevel">
          <div class="login-title">
            <div class="login-left">
              <img class="logo pixel" src="/assets/icons/bliss.png" width="34" height="34" alt="" style="display:block;" />
              <div>
                <h1>BLISS 98</h1>
                <p class="login-sub" data-i18n="login.sub">Enter your name to login</p>
              </div>
            </div>
            <button id="langBtn" class="btn bevel lang-btn" type="button" aria-label="Language" data-i18n-aria="aria.language">
              EN
            </button>
          </div>

          <div class="bevel-in" style="padding:12px;">
            <div class="field-row">
              <label for="username" data-i18n="login.labelName">Name:</label>
              <input id="username" class="bevel-in" type="text" autocomplete="name" placeholder="Enter your name" data-i18n-placeholder="login.placeholder" />
            </div>

            <div class="login-footer">
              <div class="tiny" data-i18n="login.hint">Hint: Ignorance is BLISS</div>
              <div style="display:flex; gap:6px;">
                <button id="clearProfile" class="btn bevel" type="button" data-i18n="login.clear">Clear</button>
                <button id="enter" class="btn bevel" type="button"><strong data-i18n="login.enter">Enter</strong></button>
              </div>
            </div>
          </div>

          <div class="tiny" style="margin-top:10px; opacity:.9;">
            <span data-i18n="login.copyright">© BLISS / DIEV — Bliss 98 OS</span>
          </div>
        </div>
      </div>

      <div id="desktop" class="hidden">
        <div class="desktop-area" id="desktopArea">
          <div class="icons" id="iconGrid"></div>
          <div class="drag-layer" id="dragLayer"></div>
          <div id="windows"></div>
          <div id="rubberband" class="rubberband hidden"></div>
        </div>

        <div class="taskbar bevel" id="taskbar">
          <div class="task-left">
            <div id="startBtn" class="btn bevel" title="Menu" data-i18n-title="start.menu">
              <img class="pixel" src="/assets/icons/bliss.png" width="16" height="16" alt="" style="display:block;" />
              <strong>Bliss</strong>
            </div>
          </div>

          <div class="task-buttons" id="taskButtons"></div>

          <div class="task-right">
            <div class="tray bevel">
              <span id="who" style="margin-right:10px;"></span>
              <span class="clock" id="clock"></span>
            </div>
          </div>
        </div>

        <div id="startMenu" class="start-menu bevel hidden" role="menu" aria-label="Menu Bliss" data-i18n-aria="aria.startMenu">
          <div class="start-side"><span>BLISS 98</span></div>
          <div class="start-list" id="startList"></div>
        </div>

        <!-- Desktop context menu -->
        <div id="ctxMenu" class="ctx-menu bevel hidden" role="menu" aria-label="Context menu" data-i18n-aria="aria.contextMenu">
          <!-- items injected by JS -->
        </div>

        <div id="modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
          <div class="modal-box bevel">
            <div class="modal-titlebar">
              <div class="title-left">
                <strong id="modalTitle"></strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" id="modalClose" aria-label="Close" data-i18n-aria="aria.close">×</div>
              </div>
            </div>
            <div class="modal-body" id="modalBody"></div>
            <div class="modal-actions" id="modalActions"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      const state = {
        user: null,
        windows: new Map(),
        zTop: 10,
        activeWindowId: null,
        selectedIconId: null,
        lang: 'en',
        wallpaper: 'classic',
        animations: true,
        music: {
          selected: new Set(),
          tileSize: 'large',
          openNewTab: true,
          showIcons: true,
        },
        mediaplayer: {
          selected: new Set(),
          shuffle: false,
          repeat: 'off',
          showPlaylist: true,
          compact: false,
          needsReimport: false,
        },
        diev: {
          textSize: 'normal',
          highContrast: false,
        },
        videos: {
          openNewTab: true,
          thumbSize: 'large',
          items: [],
          selectedId: null,
        },
        art: {
          zoom: 100,
        },
        settings: {
          scanlines: false,
          tab: 'general',
          darkMode: false,
          retroGlow: false,
        },
        theme: {
          preset: 'default',
          titlebar: 'defaultBlue',
          palette: 'default',
        },
        games: {
          view: 'list',
          selectedId: null,
          layout: 'grid',
          bigIcons: false,
        },
        folders: {
          games: [],
        },
        snake: {
          speed: 'normal',
          highScore: 0,
        },
        trash: new Set(),
        iconLabels: {},
        trashSelection: new Set(),
        poetry: {
          view: 'list',
          selectedId: null,
          currentId: null,
          readLang: 'en',
        },
        menuOpen: null,
        gridSnap: true,
        autoPlayTimer: null,
        didAutoPlayThisSession: false,
      };

      const ICON_POS_KEY = 'bliss98_icon_positions';
      const ICON_SIZE = { w: 92, h: 88 };
      const ICON_GAP = { x: 12, y: 8 };
      const WALLPAPER_KEY = 'bliss98_wallpaper';
      const ANIMATIONS_KEY = 'bliss98_animations';
      const SCANLINES_KEY = 'bliss98_scanlines';
      const DARKMODE_KEY = 'bliss98_darkmode';
      const TRASH_KEY = 'bliss98_trash';
      const ICON_LABELS_KEY = 'bliss98_icon_labels';
      const CLOTHES_CACHE_KEY = 'bliss98_clothes_cache';
      const CLOTHES_CACHE_TTL = 1000 * 60 * 60 * 3;
      const SNAKE_HIGH_KEY = 'bliss98_snake_highscore';
      const TITLEBAR_KEY = 'bliss98_titlebar_theme';
      const THEME_PRESET_KEY = 'bliss98_theme_preset';
      const THEME_CUSTOM_KEY = 'bliss98_theme_custom';
      const FOLDER_KEY = 'bliss98_folders';
      const GAMES_VIEW_KEY = 'bliss98_games_view';
      const GAMES_BIG_KEY = 'bliss98_games_big';
      const RETRO_KEY = 'bliss98_retro_glow';
      const YOUTUBE_KEY = 'bliss98_youtube_api_key';
      const SFX = {
        boot: {
          src: '/assets/audio/boot.mp3',
          audio: null,
          played: false,
          pending: false,
          unlockArmed: false,
          playing: false,
        },
        logoff: {
          src: '/assets/audio/logoff.mp3',
          audio: null,
          playing: false,
        }
      };
      const WALLPAPERS = [
        {
          id: 'classic',
          labelKey: 'wallpaper.classic',
          background: '#008080',
          size: 'auto',
          repeat: 'repeat'
        },
        {
          id: 'bliss',
          labelKey: 'wallpaper.bliss',
          background: 'radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'clouds',
          labelKey: 'wallpaper.clouds',
          background: 'linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'diev',
          labelKey: 'wallpaper.diev',
          background: 'repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), linear-gradient(135deg, #0a2333, #114b6a)',
          size: 'auto',
          repeat: 'repeat'
        },
        {
          id: 'tot',
          labelKey: 'wallpaper.tot',
          background: 'radial-gradient(circle at 20% 20%, #ffd1e6 0%, #ff9fcb 45%, #ff7fb7 100%), repeating-radial-gradient(circle, rgba(255,255,255,0.35) 0 1px, transparent 1px 10px)',
          size: 'cover',
          repeat: 'repeat'
        },
        {
          id: 'matrix',
          labelKey: 'wallpaper.matrix',
          className: 'wallpaper-matrix'
        },
        {
          id: 'xp98bliss',
          labelKey: 'wallpaper.xp98bliss',
          background: 'url("/assets/wallpapers/bliss98.png")',
          size: 'cover',
          repeat: 'no-repeat',
          position: 'center'
        },
      ];

      const TITLEBAR_THEMES = {
        defaultBlue: { bar1:'#000080', bar2:'#1084d0', text:'#ffffff' },
        pinkLight: { bar1:'#f6a6cf', bar2:'#e46aa9', text:'#1a1a1a' },
        purpleDark: { bar1:'#3a1c5a', bar2:'#1b0f30', text:'#f1f1f1' },
        offWhite: { bar1:'#e6e6e6', bar2:'#cfcfcf', text:'#1a1a1a' },
        greenDark: { bar1:'#1b4a2a', bar2:'#0e2e1a', text:'#f1f1f1' },
        redDark: { bar1:'#5a1a1a', bar2:'#2f0b0b', text:'#f1f1f1' },
        blank: { bar1:'#b6b6b6', bar2:'#c9c9c9', text:'#f1f1f1' },
        xpBlue: { bar1:'#0a2e8f', bar2:'#4f86d8', text:'#ffffff' },
      };

      const THEME_PRESETS = [
        { id:'default', nameKey:'theme.default', titlebarColor:'defaultBlue', wallpaperId:'classic', darkMode:false },
        { id:'totvers', nameKey:'theme.totvers', titlebarColor:'pinkLight', wallpaperId:'tot', darkMode:false },
        { id:'matrix', nameKey:'theme.matrix', titlebarColor:'greenDark', wallpaperId:'matrix', darkMode:true },
        { id:'xp98', nameKey:'theme.xp98', titlebarColor:'xpBlue', wallpaperId:'xp98bliss', darkMode:false },
        { id:'blank', nameKey:'theme.blank', titlebarColor:'blank', wallpaperId:'classic', darkMode:false },
      ];

      const VIRTUAL_ICONS = [
        { id:'snake', titleKey:'games.snake', iconFile:'/assets/icons/snake.png' }
      ];

      function initSfx(){
        Object.values(SFX).forEach(entry => {
          entry.audio = new Audio(entry.src);
          entry.audio.preload = 'auto';
          entry.audio.volume = 0.5;
        });
      }

      function playSfx(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        try{
          entry.audio.currentTime = 0;
          const p = entry.audio.play();
          if(p && typeof p.then === 'function'){
            return p.then(()=>{
              entry.playing = false;
              return true;
            }).catch(()=>{
              entry.playing = false;
              return false;
            });
          }
          entry.playing = false;
          return Promise.resolve(true);
        } catch {
          entry.playing = false;
          return Promise.resolve(false);
        }
      }

      function playSfxOnce(name, opts = {}){
        const entry = SFX[name];
        if(!entry || entry.played) return Promise.resolve(false);
        return playSfx(name).then((ok)=>{
          if(ok){
            entry.played = true;
            entry.pending = false;
          } else if(opts.allowPending){
            entry.pending = true;
          }
          return ok;
        });
      }

      function playSfxAndWait(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        return new Promise(resolve => {
          const audio = entry.audio;
          const cleanup = ()=>{
            audio.removeEventListener('ended', onEnd);
            audio.removeEventListener('error', onError);
          };
          const onEnd = ()=>{
            cleanup();
            entry.playing = false;
            resolve(true);
          };
          const onError = ()=>{
            cleanup();
            entry.playing = false;
            resolve(false);
          };
          audio.addEventListener('ended', onEnd, { once: true });
          audio.addEventListener('error', onError, { once: true });
          try{
            audio.currentTime = 0;
            const p = audio.play();
            if(p && typeof p.then === 'function'){
              p.catch(()=>{ onError(); });
            }
          } catch {
            onError();
          }
        });
      }

      function armBootUnlock(){
        const entry = SFX.boot;
        if(!entry || entry.played || !entry.pending || entry.unlockArmed) return;
        entry.unlockArmed = true;
        const loginEl = $('#login');
        if(!loginEl){
          entry.unlockArmed = false;
          return;
        }
        const handler = ()=>{
          if($('#login').classList.contains('hidden')){
            entry.pending = false;
            entry.unlockArmed = false;
            return;
          }
          playSfxOnce('boot').finally(()=>{
            entry.pending = false;
            entry.unlockArmed = false;
          });
        };
        const wrapped = ()=>{
          loginEl.removeEventListener('pointerdown', wrapped, true);
          loginEl.removeEventListener('keydown', wrapped, true);
          handler();
        };
        loginEl.addEventListener('pointerdown', wrapped, true);
        loginEl.addEventListener('keydown', wrapped, true);
      }

      function loadIconPositions(){
        try{
          const raw = localStorage.getItem(ICON_POS_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch {
          return {};
        }
      }

      function saveIconPositions(pos){
        try{
          localStorage.setItem(ICON_POS_KEY, JSON.stringify(pos));
        } catch {}
      }

      function legacyDefaultIconPos(index){
        // Layout similar to the old grid: 6 rows then new column
        const rows = 6;
        const col = Math.floor(index / rows);
        const row = index % rows;
        return {
          x: col * (ICON_SIZE.w + ICON_GAP.x),
          y: row * (ICON_SIZE.h + ICON_GAP.y)
        };
      }

      function clampIconPos(x, y){
        const area = $('#desktopArea').getBoundingClientRect();
        const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
        const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));
        return {
          x: clamp(Math.floor(x), 0, maxX),
          y: clamp(Math.floor(y), 0, maxY)
        };
      }
      const GRID_SNAP_KEY = 'bliss98_grid_snap';

function loadGridSnap(){
  try{
    const raw = localStorage.getItem(GRID_SNAP_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveGridSnap(){
  try{
    localStorage.setItem(GRID_SNAP_KEY, state.gridSnap ? '1' : '0');
  } catch {}
}

function snapToGrid(x, y){
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const sx = Math.round(x / stepX) * stepX;
  const sy = Math.round(y / stepY) * stepY;
  return clampIconPos(sx, sy);
}

function getGridMetrics(){
  const area = $('#desktopArea').getBoundingClientRect();
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const cols = Math.max(1, Math.floor((area.width - 6) / stepX));
  const rows = Math.max(1, Math.floor((area.height - 6) / stepY));
  return { stepX, stepY, cols, rows };
}

function snapToGridClamped(x, y, metrics){
  const snapped = snapToGrid(x, y);
  const maxX = (metrics.cols - 1) * metrics.stepX;
  const maxY = (metrics.rows - 1) * metrics.stepY;
  return {
    x: clamp(snapped.x, 0, maxX),
    y: clamp(snapped.y, 0, maxY)
  };
}

function gridCellFromPos(x, y, metrics){
  return {
    col: clamp(Math.round(x / metrics.stepX), 0, metrics.cols - 1),
    row: clamp(Math.round(y / metrics.stepY), 0, metrics.rows - 1)
  };
}

function gridPosFromCell(cell, metrics){
  return { x: cell.col * metrics.stepX, y: cell.row * metrics.stepY };
}

function findFreeCell(startCell, occupied, metrics){
  const total = metrics.cols * metrics.rows;
  const startIdx = startCell.row * metrics.cols + startCell.col;
  for(let i = 0; i < total; i++){
    const idx = (startIdx + i) % total;
    const col = idx % metrics.cols;
    const row = Math.floor(idx / metrics.cols);
    const key = `${col},${row}`;
    if(!occupied.has(key)){
      return { col, row };
    }
  }
  return startCell;
}

function placeOnFreeCell(x, y, occupied, metrics){
  const snapped = snapToGridClamped(x, y, metrics);
  const cell = gridCellFromPos(snapped.x, snapped.y, metrics);
  const key = `${cell.col},${cell.row}`;
  const targetCell = occupied.has(key) ? findFreeCell(cell, occupied, metrics) : cell;
  const pos = gridPosFromCell(targetCell, metrics);
  occupied.set(`${targetCell.col},${targetCell.row}`, true);
  return {
    x: pos.x,
    y: pos.y,
    changed: targetCell.col !== cell.col || targetCell.row !== cell.row || pos.x !== snapped.x || pos.y !== snapped.y
  };
}

function getIconLabel(app){
  return state.iconLabels[app.id] || t(app.titleKey);
}

function getTrashIconFile(){
  return state.trash && state.trash.size > 0
    ? '/assets/icons/trash2.png'
    : '/assets/icons/trash1.png';
}

function updateTrashIconUI(){
  const trashFile = getTrashIconFile();

  const desktopIcon = document.querySelector('.icon[data-app-id="trash"] img');
  if(desktopIcon) desktopIcon.src = trashFile;

  const startIcon = document.querySelector('#startMenu .menu-item img[data-app-id="trash"]');
  if(startIcon) startIcon.src = trashFile;

  const win = document.getElementById('win_trash');
  if(win){
    const titleIcon = win.querySelector('.title-left img');
    if(titleIcon) titleIcon.src = trashFile;
  }

  const taskBtn = document.querySelector('#taskButtons img[data-app-id="trash"]');
  if(taskBtn) taskBtn.src = trashFile;
}

function buildOccupied(excludeIds, metrics){
  const occupied = new Map();
  const exclude = new Set(excludeIds || []);
  $$('.icon').forEach(el => {
    const id = el.dataset.appId;
    if(exclude.has(id)) return;
    const x = parseInt(el.style.left || '0', 10);
    const y = parseInt(el.style.top || '0', 10);
    const cell = gridCellFromPos(x, y, metrics);
    occupied.set(`${cell.col},${cell.row}`, true);
  });
  return occupied;
}

function getDefaultIconLayout(){
  const area = $('#desktopArea').getBoundingClientRect();
  const metrics = getGridMetrics();
  const isMobile = area.width <= 520;
  const order = ['settings','games','about','videos','mediaplayer','diev','art','contact','poetry','music','clothes'];
  const available = APPS.filter(app => app.showOnDesktop !== false && app.id !== 'trash' && !state.trash.has(app.id) && !isInFolder(app.id));
  const availableIds = new Set(available.map(app => app.id));
  const ordered = order.filter(id => availableIds.has(id)).concat(
    available.map(app => app.id).filter(id => !order.includes(id))
  );

  const layout = {};
  const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
  const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));

  if(isMobile){
    const cols = Math.max(1, Math.floor((area.width - 6) / metrics.stepX));
    const rows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    const trashCell = { col: cols - 1, row: rows - 1 };
    let i = 0;
    ordered.forEach(id => {
      let col = i % cols;
      let row = Math.floor(i / cols);
      if(col === trashCell.col && row === trashCell.row){
        i += 1;
        col = i % cols;
        row = Math.floor(i / cols);
      }
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      i += 1;
    });
  } else {
    let col = 0;
    let row = 0;
    const maxRows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    ordered.forEach(id => {
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      row += 1;
      if(row >= maxRows){
        row = 0;
        col += 1;
      }
    });
  }

  const trashX = snapToGridClamped(maxX, maxY, metrics).x;
  const trashY = snapToGridClamped(maxX, maxY, metrics).y;
  layout.trash = { x: trashX, y: trashY };

  return layout;
}

function isOverTrash(x, y){
  const trashEl = document.querySelector('.icon[data-app-id="trash"]');
  if(!trashEl) return false;
  const r = trashEl.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function moveIconsToTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.add(id));
  Object.keys(state.folders).forEach(folderId => {
    removeFromFolder(folderId, filtered);
  });
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function restoreFromTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.delete(id));
  Object.keys(state.folders).forEach(folderId => {
    removeFromFolder(folderId, filtered);
  });
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function emptyTrash(){
  state.trash = new Set();
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function renderTrashWindow(){
  const win = document.getElementById('win_trash');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.trash();
  applyI18nTo(win);
  content.classList.toggle('trash-empty', state.trash.size === 0);
  const items = win.querySelectorAll('[data-trash-id]');
  items.forEach(item => {
    const id = item.dataset.trashId;
    item.classList.toggle('selected', state.trashSelection.has(id));
  });
  const restoreBtn = win.querySelector('[data-trash-action="restore"]');
  const restoreAllBtn = win.querySelector('[data-trash-action="restoreAll"]');
  if(restoreBtn) restoreBtn.disabled = state.trash.size === 0;
  if(restoreAllBtn) restoreAllBtn.disabled = state.trash.size === 0;
}

function renderPoetryWindow(){
  const win = document.getElementById('win_poetry');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.poetry();
  applyI18nTo(win);
  const items = win.querySelectorAll('[data-poem-id]');
  items.forEach(item => {
    const id = item.dataset.poemId;
    item.classList.toggle('selected', state.poetry.selectedId === id);
  });
}

function renderGamesWindow(){
  const win = document.getElementById('win_games');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.games();
  applyI18nTo(win);

  if(state.games.view === 'list'){
    const firstId = getFirstGameId();
    if(!state.games.selectedId) state.games.selectedId = firstId;
    const items = Array.from(win.querySelectorAll('[data-game-id]'));
    if(state.games.selectedId && !items.some(item => item.dataset.gameId === state.games.selectedId)){
      state.games.selectedId = firstId;
    }
    const listEl = win.querySelector('#gamesList');
    if(listEl){
      listEl.className = state.games.layout === 'list' ? 'games-list' : 'games-grid';
      if(state.games.layout === 'grid' && state.games.bigIcons) listEl.classList.add('games-big');
    }
    const gridBtn = win.querySelector('[data-games-view="grid"]');
    const listBtn = win.querySelector('[data-games-view="list"]');
    const bigBtn = win.querySelector('[data-games-big="toggle"]');
    if(gridBtn) gridBtn.classList.toggle('pressed', state.games.layout === 'grid');
    if(listBtn) listBtn.classList.toggle('pressed', state.games.layout === 'list');
    if(bigBtn) bigBtn.classList.toggle('pressed', state.games.bigIcons);

    items.forEach(item => {
      const id = item.dataset.gameId;
      item.classList.toggle('selected', state.games.selectedId === id);
      item.addEventListener('click', (e)=>{
        if(e.detail > 1) return;
        state.games.selectedId = id;
        items.forEach(btn => btn.classList.toggle('selected', btn === item));
      });
      item.addEventListener('dblclick', (e)=>{
        e.stopPropagation();
        openGameFromHub(id);
      });
      item.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          openGameFromHub(id);
        }
      });
      makeGameItemDraggable(item, id);
    });
    return;
  }

  if(state.games.view === 'snake'){
    initSnakeInWindow(win);
  }
}

function initGamesWindow(){
  renderGamesWindow();
}

function getFirstGameId(){
  const items = state.folders.games || [];
  return items[0] || null;
}

function openGameFromHub(id){
  if(id === 'snake'){
    state.games.view = 'snake';
    state.games.selectedId = 'snake';
    renderGamesWindow();
    return;
  }
  if(getAppById(id)){
    openApp(id);
  }
}

function backToGamesHub(){
  state.games.view = 'list';
  state.games.selectedId = getFirstGameId();
  snakeStop();
  renderGamesWindow();
}

const SNAKE_SPEEDS = {
  slow: 180,
  normal: 130,
  fast: 90,
};

let snake = {
  grid: 20,
  body: [],
  dir: { x: 1, y: 0 },
  nextDir: { x: 1, y: 0 },
  food: { x: 0, y: 0 },
  running: false,
  paused: false,
  score: 0,
  gameOver: false,
  started: false,
  speed: 'normal',
  timer: null,
  cell: 16,
  ctx: null,
  els: null,
  swipeStart: null,
};

function loadSnakeHighScore(){
  try{
    const raw = localStorage.getItem(SNAKE_HIGH_KEY);
    const parsed = parseInt(raw || '0', 10);
    return Number.isFinite(parsed) ? parsed : 0;
  } catch {
    return 0;
  }
}

function saveSnakeHighScore(score){
  try{ localStorage.setItem(SNAKE_HIGH_KEY, String(score)); } catch {}
}

function isSnakeActive(){
  return state.activeWindowId === 'games' && state.games.view === 'snake';
}

function initSnakeInWindow(winEl){
  const board = winEl.querySelector('#snakeBoard');
  const canvas = winEl.querySelector('#snakeCanvas');
  if(!board || !canvas) return;

  snake.els = {
    board,
    canvas,
    startBtn: winEl.querySelector('[data-snake-action="start"]'),
    pauseBtn: winEl.querySelector('[data-snake-action="pause"]'),
    playAgainBtn: winEl.querySelector('[data-snake-action="playAgain"]'),
    speedSelect: winEl.querySelector('[data-snake-speed]'),
    score: winEl.querySelector('[data-snake-score]'),
    high: winEl.querySelector('[data-snake-high]'),
    overlay: winEl.querySelector('#snakeOverlay'),
    overScore: winEl.querySelector('[data-snake-over-score]'),
    backBtn: winEl.querySelector('[data-games-action="back"]'),
  };

  snake.ctx = canvas.getContext('2d');
  snake.ctx.imageSmoothingEnabled = false;

  if(typeof state.snake.highScore !== 'number' || Number.isNaN(state.snake.highScore)){
    state.snake.highScore = loadSnakeHighScore();
  }
  snake.speed = state.snake.speed || 'normal';
  if(snake.els.speedSelect) snake.els.speedSelect.value = snake.speed;

  const fixedSize = 320;
  canvas.width = fixedSize;
  canvas.height = fixedSize;
  canvas.style.width = fixedSize + 'px';
  canvas.style.height = fixedSize + 'px';
  snake.cell = Math.max(8, Math.floor(fixedSize / snake.grid));
  snakeDraw();

  if(snake.els.backBtn){
    snake.els.backBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      backToGamesHub();
    });
  }
  if(snake.els.startBtn){
    snake.els.startBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeTogglePause();
    });
  }
  if(snake.els.playAgainBtn){
    snake.els.playAgainBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.speedSelect){
    snake.els.speedSelect.addEventListener('change', (e)=>{
      const val = e.target.value;
      state.snake.speed = val;
      snake.speed = val;
      if(snake.running) snakeStartLoop();
    });
  }

  board.addEventListener('touchstart', snakeHandleTouchStart, { passive: false });
  board.addEventListener('touchmove', snakeHandleTouchMove, { passive: false });
  board.addEventListener('touchend', snakeHandleTouchEnd, { passive: false });
  board.addEventListener('pointerdown', (e)=>{
    if(e.pointerType === 'mouse' || e.pointerType === 'pen'){
      snakeHandleTap(e.clientX, e.clientY);
    }
  });

  snakePrepareBoard();
  updateSnakeUI();
}

function snakePrepareBoard(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  snake.score = 0;
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snakePlaceFood();
  snakeDraw();
  updateSnakeUI();
}

function snakeStartGame(){
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  snake.score = 0;
  snake.running = true;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = true;
  snakePlaceFood();
  snakeStartLoop();
  updateSnakeUI();
  snakeDraw();
}

function snakeStartLoop(){
  snakeStopLoop();
  const step = SNAKE_SPEEDS[snake.speed] || SNAKE_SPEEDS.normal;
  snake.timer = setInterval(snakeTick, step);
}

function snakeStopLoop(){
  if(snake.timer){
    clearInterval(snake.timer);
    snake.timer = null;
  }
}

function snakeTogglePause(){
  if(!snake.running) return;
  snake.paused = !snake.paused;
  updateSnakeUI();
}

function snakeStop(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  snake.els = null;
  snake.ctx = null;
}

function snakeTick(){
  if(!snake.running || snake.paused || snake.gameOver) return;
  snake.dir = { ...snake.nextDir };
  const head = snake.body[0];
  const next = {
    x: (head.x + snake.dir.x + snake.grid) % snake.grid,
    y: (head.y + snake.dir.y + snake.grid) % snake.grid,
  };
  if(snake.body.some(seg => seg.x === next.x && seg.y === next.y)){
    snakeGameOver();
    return;
  }

  snake.body.unshift(next);
  if(next.x === snake.food.x && next.y === snake.food.y){
    snake.score += 10;
    snakePlaceFood();
  } else {
    snake.body.pop();
  }
  snakeDraw();
  updateSnakeUI();
}

function snakePlaceFood(){
  let x = 0;
  let y = 0;
  let guard = 0;
  do{
    x = Math.floor(Math.random() * snake.grid);
    y = Math.floor(Math.random() * snake.grid);
    guard += 1;
  } while(snake.body.some(seg => seg.x === x && seg.y === y) && guard < 200);
  snake.food = { x, y };
}

function snakeGameOver(){
  snake.running = false;
  snake.paused = false;
  snake.gameOver = true;
  snakeStopLoop();
  if(snake.score > state.snake.highScore){
    state.snake.highScore = snake.score;
    saveSnakeHighScore(state.snake.highScore);
  }
  updateSnakeUI();
}

function snakeDraw(){
  if(!snake.ctx || !snake.els) return;
  const canvas = snake.els.canvas;
  const ctx = snake.ctx;
  const cell = snake.cell;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#1b7c1b';
  snake.body.forEach((seg, idx)=>{
    ctx.fillStyle = idx === 0 ? '#0f5c0f' : '#1b7c1b';
    ctx.fillRect(seg.x * cell, seg.y * cell, cell, cell);
  });

  ctx.fillStyle = '#b20000';
  ctx.fillRect(snake.food.x * cell, snake.food.y * cell, cell, cell);
}


function snakeHandleDirection(dx, dy){
  if(!isSnakeActive()) return;
  if(dx === -snake.dir.x && dy === -snake.dir.y) return;
  snake.nextDir = { x: dx, y: dy };
}

function snakeHandleKey(e){
  if(!isSnakeActive()) return false;
  const tag = e.target && e.target.tagName;
  if(tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return false;

  const key = e.key.toLowerCase();
  let handled = true;
  if(key === 'arrowup' || key === 'w') snakeHandleDirection(0, -1);
  else if(key === 'arrowdown' || key === 's') snakeHandleDirection(0, 1);
  else if(key === 'arrowleft' || key === 'a') snakeHandleDirection(-1, 0);
  else if(key === 'arrowright' || key === 'd') snakeHandleDirection(1, 0);
  else if(key === ' ' || key === 'spacebar') snakeTogglePause();
  else handled = false;

  if(handled){
    e.preventDefault();
  }
  return handled;
}

function snakeHandleTouchStart(e){
  if(state.windows.has('games') && state.activeWindowId !== 'games'){
    focusWindow('games');
  }
  if(!isSnakeActive()) return;
  e.preventDefault();
  const touch = e.changedTouches[0];
  snake.swipeStart = { x: touch.clientX, y: touch.clientY, t: Date.now() };
}

function snakeHandleTouchMove(e){
  if(!isSnakeActive()) return;
  e.preventDefault();
}

function snakeHandleTouchEnd(e){
  if(!isSnakeActive() || !snake.swipeStart) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - snake.swipeStart.x;
  const dy = touch.clientY - snake.swipeStart.y;
  const absX = Math.abs(dx);
  const absY = Math.abs(dy);
  if(Math.max(absX, absY) < 18){
    snakeHandleTap(touch.clientX, touch.clientY);
    snake.swipeStart = null;
    return;
  }
  if(absX > absY){
    snakeHandleDirection(dx > 0 ? 1 : -1, 0);
  } else {
    snakeHandleDirection(0, dy > 0 ? 1 : -1);
  }
  snake.swipeStart = null;
}

function snakeHandleTap(clientX, clientY){
  if(!isSnakeActive() || !snake.els || !snake.els.canvas) return;
  const rect = snake.els.canvas.getBoundingClientRect();
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  const head = snake.body[0];
  if(!head) return;
  const headX = (head.x + 0.5) * snake.cell;
  const headY = (head.y + 0.5) * snake.cell;
  const dx = x - headX;
  const dy = y - headY;
  if(Math.abs(dx) > Math.abs(dy)){
    snakeHandleDirection(dx > 0 ? 1 : -1, 0);
  } else {
    snakeHandleDirection(0, dy > 0 ? 1 : -1);
  }
}

function updateSnakeUI(){
  if(!snake.els) return;
  if(snake.els.score) snake.els.score.textContent = String(snake.score);
  if(snake.els.high) snake.els.high.textContent = String(state.snake.highScore || 0);
  if(snake.els.overScore) snake.els.overScore.textContent = String(snake.score);
  if(snake.els.overlay) snake.els.overlay.classList.toggle('hidden', !snake.gameOver);
  if(snake.els.startBtn){
    snake.els.startBtn.textContent = snake.started ? t('snake.restart') : t('snake.start');
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.classList.toggle('pressed', snake.paused);
  }
}

function loadClothesCache(){
  try{
    const raw = localStorage.getItem(CLOTHES_CACHE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.items)) return null;
    if(!parsed.ts || (Date.now() - parsed.ts) > CLOTHES_CACHE_TTL) return null;
    return parsed.items;
  } catch {
    return null;
  }
}

function saveClothesCache(items){
  try{
    localStorage.setItem(CLOTHES_CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch {}
}

function decodeInstagramUrl(url){
  if(!url) return '';
  return url
    .replace(/\\u0026/g, '&')
    .replace(/\\u003d/g, '=')
    .replace(/\\\//g, '/');
}

function parseInstagramHtml(html){
  if(!html) return [];
  const items = [];
  const re = /"shortcode":"(.*?)".*?"display_url":"(.*?)"/g;
  let match;
  while((match = re.exec(html)) && items.length < 12){
    const shortcode = match[1];
    const display = decodeInstagramUrl(match[2]);
    if(!shortcode || !display) continue;
    items.push({
      img: display,
      url: `https://www.instagram.com/p/${shortcode}/`
    });
  }
  return items;
}

function fetchClothesFromInstagram(){
  const url = 'https://r.jina.ai/http://www.instagram.com/blissworldweb/';
  return fetch(url, { cache: 'no-store' })
    .then(res => res.ok ? res.text() : Promise.reject(new Error('bad')))
    .then(html => parseInstagramHtml(html))
    .catch(() => []);
}

function renderClothesItems(winEl, items){
  const grid = winEl.querySelector('#clothesGrid');
  if(!grid) return;
  const profile = 'https://www.instagram.com/blissworldweb/';
  const alt = t('clothes.thumbAlt');
  grid.innerHTML = items.map(item => {
    const href = item.url || profile;
    const img = item.img || '/assets/icons/Clothes.png';
    return `
      <a class="clothes-item" href="${href}" target="_blank" rel="noopener noreferrer" aria-label="${alt}">
        <img class="clothes-thumb" src="${img}" alt="${alt}" loading="lazy" />
      </a>
    `;
  }).join('');
}

function updateClothesStatus(winEl, key){
  const status = winEl.querySelector('#clothesStatus');
  if(!status) return;
  if(!key){
    status.textContent = '';
    status.classList.add('hidden');
  } else {
    status.textContent = t(key);
    status.classList.remove('hidden');
  }
}

function initClothesWindow(winEl){
  const win = winEl || document.getElementById('win_clothes');
  if(!win) return;
  const cached = loadClothesCache();
  if(cached && cached.length){
    renderClothesItems(win, cached);
    updateClothesStatus(win, null);
    return;
  }
  updateClothesStatus(win, 'clothes.loading');
  fetchClothesFromInstagram().then(items => {
    if(items && items.length) saveClothesCache(items);
    const fallback = (items && items.length) ? items : CLOTHES_FALLBACK;
    if(fallback && fallback.length){
      renderClothesItems(win, fallback);
      updateClothesStatus(win, null);
    } else {
      renderClothesItems(win, []);
      updateClothesStatus(win, 'clothes.unavailable');
    }
  });
}

function initSettingsTabs(winEl){
  const win = winEl || document.getElementById('win_settings');
  if(!win) return;
  const tabs = Array.from(win.querySelectorAll('.settings-tab'));
  const panels = Array.from(win.querySelectorAll('.settings-panel'));
  if(!tabs.length || !panels.length) return;
  const panelMap = new Map(panels.map(p => [p.dataset.tab, p]));

  const activate = (tabId)=>{
    if(!panelMap.has(tabId)) return;
    state.settings.tab = tabId;
    tabs.forEach(tab => {
      const active = tab.dataset.tab === tabId;
      tab.setAttribute('aria-selected', active ? 'true' : 'false');
      tab.tabIndex = active ? 0 : -1;
    });
    panels.forEach(panel => {
      panel.classList.toggle('active', panel.dataset.tab === tabId);
    });
    updateWallpaperButtons(win);
    updateAnimationButtons(win);
    updateScanlinesButtons(win);
  };

  const current = (state.settings.tab && panelMap.has(state.settings.tab))
    ? state.settings.tab
    : tabs[0].dataset.tab;
  activate(current);

  tabs.forEach((tab, idx) => {
    tab.addEventListener('click', ()=>{
      activate(tab.dataset.tab);
    });
    tab.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(key === 'Enter' || key === ' '){
        e.preventDefault();
        activate(tab.dataset.tab);
        return;
      }
      if(key === 'ArrowRight' || key === 'ArrowLeft' || key === 'Home' || key === 'End'){
        e.preventDefault();
        let nextIdx = idx;
        if(key === 'ArrowRight') nextIdx = (idx + 1) % tabs.length;
        if(key === 'ArrowLeft') nextIdx = (idx - 1 + tabs.length) % tabs.length;
        if(key === 'Home') nextIdx = 0;
        if(key === 'End') nextIdx = tabs.length - 1;
        tabs[nextIdx].focus();
      }
    });
  });
}

function openSettingsAndTab(tabId, scrollId){
  state.settings.tab = tabId || 'general';
  openApp('settings');
  setTimeout(()=>{
    const winEl = document.getElementById('win_settings');
    if(winEl) initSettingsTabs(winEl);
    if(winEl && scrollId){
      const target = winEl.querySelector(`#${scrollId}`);
      if(target && target.scrollIntoView){
        target.scrollIntoView({ block: 'nearest' });
      }
    }
  }, 0);
}

function selectPoetryItem(id){
  state.poetry.selectedId = id;
  const win = document.getElementById('win_poetry');
  if(!win) return;
  win.querySelectorAll('[data-poem-id]').forEach(item => {
    item.classList.toggle('selected', item.dataset.poemId === id);
  });
}

function arrangeIcons(){
  const next = getDefaultIconLayout();
  saveIconPositions(next);
  renderIcons();
}

function resetIconPositions(){
  try{ localStorage.removeItem(ICON_POS_KEY); } catch {}
  renderIcons();
}

function loadAnimations(){
  try{
    const raw = localStorage.getItem(ANIMATIONS_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveAnimations(){
  try{
    localStorage.setItem(ANIMATIONS_KEY, state.animations ? '1' : '0');
  } catch {}
}

function updateAnimationButtons(root=document){
  $$('[data-set-animations]', root).forEach(btn => {
    const on = btn.dataset.setAnimations === 'on';
    btn.classList.toggle('pressed', on === state.animations);
  });
}

function setAnimations(enabled){
  state.animations = !!enabled;
  saveAnimations();
  updateAnimationButtons();
}

function updateScanlinesButtons(root=document){
  $$('[data-set-scanlines]', root).forEach(btn => {
    const on = btn.dataset.setScanlines === 'on';
    btn.classList.toggle('pressed', on === state.settings.scanlines);
  });
}

function setScanlines(enabled){
  state.settings.scanlines = !!enabled;
  applyScanlines();
  updateScanlinesButtons();
}

function updateRetroGlowButtons(root=document){
  $$('[data-set-retro]', root).forEach(btn => {
    const on = btn.dataset.setRetro === 'on';
    btn.classList.toggle('pressed', on === state.settings.retroGlow);
  });
}

function setRetroGlow(enabled){
  state.settings.retroGlow = !!enabled;
  applyRetroGlow();
  updateRetroGlowButtons();
}

function updateDarkModeButtons(root=document){
  $$('[data-set-darkmode]', root).forEach(btn => {
    const on = btn.dataset.setDarkmode === 'on';
    btn.classList.toggle('pressed', on === state.settings.darkMode);
  });
}

function setDarkMode(enabled, fromPreset=false){
  state.settings.darkMode = !!enabled;
  applyDarkMode();
  updateDarkModeButtons();
  if(!fromPreset && !themeApplying) setThemePresetCustom();
}

function loadScanlines(){
  try{
    const raw = localStorage.getItem(SCANLINES_KEY);
    if(raw === null) return false;
    return raw === '1';
  } catch {
    return false;
  }
}

function loadDarkMode(){
  try{
    const raw = localStorage.getItem(DARKMODE_KEY);
    if(raw === null) return false;
    return raw === '1';
  } catch {
    return false;
  }
}

function loadTitlebarTheme(){
  try{
    const raw = localStorage.getItem(TITLEBAR_KEY);
    if(raw === 'transparent') return 'blank';
    return raw || 'defaultBlue';
  } catch {
    return 'defaultBlue';
  }
}

function loadThemePreset(){
  try{
    const raw = localStorage.getItem(THEME_PRESET_KEY);
    return raw || 'default';
  } catch {
    return 'default';
  }
}

function saveScanlines(){
  try{
    localStorage.setItem(SCANLINES_KEY, state.settings.scanlines ? '1' : '0');
  } catch {}
}

function saveDarkMode(){
  try{
    localStorage.setItem(DARKMODE_KEY, state.settings.darkMode ? '1' : '0');
  } catch {}
}

function saveTitlebarTheme(){
  try{
    localStorage.setItem(TITLEBAR_KEY, state.theme.titlebar);
  } catch {}
}

function saveThemePreset(){
  try{
    localStorage.setItem(THEME_PRESET_KEY, state.theme.preset);
  } catch {}
}

function loadTrash(){
  try{
    const raw = localStorage.getItem(TRASH_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function saveTrash(){
  try{
    localStorage.setItem(TRASH_KEY, JSON.stringify(Array.from(state.trash)));
  } catch {}
}

function loadIconLabels(){
  try{
    const raw = localStorage.getItem(ICON_LABELS_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function saveIconLabels(){
  try{
    localStorage.setItem(ICON_LABELS_KEY, JSON.stringify(state.iconLabels));
  } catch {}
}

function loadFolders(){
  try{
    const raw = localStorage.getItem(FOLDER_KEY);
    if(raw) return JSON.parse(raw);
  } catch {}
  return { games: ['snake'] };
}

function saveFolders(){
  try{
    localStorage.setItem(FOLDER_KEY, JSON.stringify(state.folders));
  } catch {}
}

function loadWallpaper(){
  try{
    const saved = localStorage.getItem(WALLPAPER_KEY);
    return saved || WALLPAPERS[0].id;
  } catch {
    return WALLPAPERS[0].id;
  }
}

function updateWallpaperButtons(root=document){
  $$('[data-set-wallpaper]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setWallpaper === state.wallpaper);
  });
}

let themeApplying = false;

function loadGamesLayout(){
  try{
    const raw = localStorage.getItem(GAMES_VIEW_KEY);
    return raw || 'grid';
  } catch {
    return 'grid';
  }
}

function saveGamesLayout(){
  try{
    localStorage.setItem(GAMES_VIEW_KEY, state.games.layout);
  } catch {}
}

function loadGamesBigIcons(){
  try{
    const raw = localStorage.getItem(GAMES_BIG_KEY);
    return raw === '1';
  } catch {
    return false;
  }
}

function saveGamesBigIcons(){
  try{
    localStorage.setItem(GAMES_BIG_KEY, state.games.bigIcons ? '1' : '0');
  } catch {}
}

function loadRetroGlow(){
  try{
    const raw = localStorage.getItem(RETRO_KEY);
    return raw === '1';
  } catch {
    return false;
  }
}

function saveRetroGlow(){
  try{
    localStorage.setItem(RETRO_KEY, state.settings.retroGlow ? '1' : '0');
  } catch {}
}

function updateTitlebarButtons(root=document){
  $$('[data-set-titlebar]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setTitlebar === state.theme.titlebar);
  });
}

function updateThemeButtons(root=document){
  $$('[data-set-theme]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setTheme === state.theme.preset);
  });
  const current = root.querySelector('[data-theme-current]');
  if(current){
    const key = `theme.${state.theme.preset}`;
    current.textContent = t(key);
  }
}

function applyThemePalette(){
  const palette = state.theme.palette || (state.theme.preset === 'xp98' ? 'xp98' : 'default');
  document.body.classList.toggle('theme-xp98', palette === 'xp98');
}

function setThemePresetCustom(){
  if(state.theme.preset !== 'custom'){
    state.theme.preset = 'custom';
    saveThemePreset();
    applyThemePalette();
    updateThemeButtons();
    updateThemeThumbs();
  }
}

function applyWallpaper(id){
  const wp = WALLPAPERS.find(w => w.id === id) || WALLPAPERS[0];
  state.wallpaper = wp.id;
  const desktop = $('#desktop');
  if(desktop){
    desktop.classList.remove('wallpaper-matrix');
    if(wp.className){
      desktop.classList.add(wp.className);
      desktop.style.background = '';
      desktop.style.backgroundSize = '';
      desktop.style.backgroundRepeat = '';
      desktop.style.backgroundPosition = '';
    } else {
      desktop.style.background = wp.background;
      desktop.style.backgroundSize = wp.size || 'auto';
      desktop.style.backgroundRepeat = wp.repeat || 'repeat';
      desktop.style.backgroundPosition = wp.position || 'top left';
    }
  }
  try{ localStorage.setItem(WALLPAPER_KEY, wp.id); } catch {}
  updateWallpaperButtons();
  renderCtxMenu();
  if(!themeApplying) setThemePresetCustom();
}

function setTitlebarTheme(id, fromPreset=false){
  state.theme.titlebar = id;
  saveTitlebarTheme();
  applyTitlebarTheme();
  updateTitlebarButtons();
  if(!fromPreset && !themeApplying) setThemePresetCustom();
}

function applyTitlebarTheme(){
  const cur = TITLEBAR_THEMES[state.theme.titlebar] || TITLEBAR_THEMES.defaultBlue;
  document.body.classList.toggle('titlebar-blank', state.theme.titlebar === 'blank');
  document.body.style.setProperty('--title', cur.bar1);
  document.body.style.setProperty('--title2', cur.bar2);
  document.body.style.setProperty('--titlebar-text', cur.text);
}

function setThemePreset(id, opts={}){
  const preset = THEME_PRESETS.find(t => t.id === id);
  if(!preset) return;
  themeApplying = true;
  state.theme.preset = id;
  state.theme.palette = (id === 'xp98') ? 'xp98' : 'default';
  saveThemePreset();
  applyThemePalette();
  setDarkMode(preset.darkMode, true);
  applyWallpaper(preset.wallpaperId);
  setTitlebarTheme(preset.titlebarColor, true);
  themeApplying = false;
  updateThemeButtons();
  updateThemeThumbs();
  if(!opts.init) renderCtxMenu();
}

function loadCustomTheme(){
  try{
    const raw = localStorage.getItem(THEME_CUSTOM_KEY);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function saveCustomTheme(data){
  try{
    localStorage.setItem(THEME_CUSTOM_KEY, JSON.stringify(data));
  } catch {}
}

function updateThemeThumbs(root=document){
  $$('[data-theme-thumb]', root).forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.themeThumb === state.theme.preset);
  });
  const customBtn = root.querySelector('[data-theme-custom="load"]');
  if(customBtn){
    const hasCustom = !!loadCustomTheme();
    customBtn.classList.toggle('disabled', !hasCustom);
    const label = customBtn.querySelector('[data-theme-custom-label]');
    if(label) label.textContent = hasCustom ? t('theme.custom') : t('theme.customEmpty');
  }
}

function saveCustomThemeFromState(){
  const data = {
    wallpaper: state.wallpaper,
    titlebar: state.theme.titlebar,
    darkMode: state.settings.darkMode,
    scanlines: state.settings.scanlines,
    retroGlow: state.settings.retroGlow,
    palette: state.theme.palette || 'default'
  };
  saveCustomTheme(data);
  updateThemeThumbs();
}

function applyCustomTheme(){
  const data = loadCustomTheme();
  if(!data) return;
  themeApplying = true;
  state.theme.preset = 'custom';
  state.theme.palette = data.palette || 'default';
  saveThemePreset();
  applyThemePalette();
  setDarkMode(!!data.darkMode, true);
  applyWallpaper(data.wallpaper || WALLPAPERS[0].id);
  setTitlebarTheme(data.titlebar || 'defaultBlue', true);
  state.settings.scanlines = !!data.scanlines;
  applyScanlines();
  state.settings.retroGlow = !!data.retroGlow;
  applyRetroGlow();
  themeApplying = false;
  updateThemeButtons();
  updateThemeThumbs();
  renderCtxMenu();
}

function applyMusicState(winEl){
  const win = winEl || document.getElementById('win_music');
  if(!win) return;
  const grid = win.querySelector('.music-grid');
  if(!grid) return;
  grid.classList.toggle('music-small', state.music.tileSize === 'small');
  win.classList.toggle('music-hide-icons', !state.music.showIcons);
  grid.querySelectorAll('[data-music-id]').forEach(card => {
    const id = card.dataset.musicId;
    card.classList.toggle('selected', state.music.selected.has(id));
  });
}

function applyMediaplayerState(winEl){
  const win = winEl || document.getElementById('win_mediaplayer');
  if(!win) return;
  const hasList = !!win.querySelector('#mpList');
  if(hasList){
    win.classList.toggle('mp-hide-list', !state.mediaplayer.showPlaylist);
  }
  win.classList.toggle('mp-compact', state.mediaplayer.compact);
}

function applyDievState(winEl){
  const win = winEl || document.getElementById('win_diev');
  if(!win) return;
  win.classList.toggle('diev-small', state.diev.textSize === 'small');
  win.classList.toggle('diev-large', state.diev.textSize === 'large');
  win.classList.toggle('diev-contrast', state.diev.highContrast);
}

function applyArtState(winEl){
  const win = winEl || document.getElementById('win_art');
  if(!win) return;
  win.classList.toggle('art-zoom-50', state.art.zoom === 50);
  win.classList.toggle('art-zoom-100', state.art.zoom === 100);
  win.classList.toggle('art-zoom-200', state.art.zoom === 200);
}

function getAppById(id){
  return APPS.find(a => a.id === id) || null;
}

function getVirtualIconById(id){
  return VIRTUAL_ICONS.find(v => v.id === id) || null;
}

function openIconById(id){
  if(id === 'snake'){
    openApp('games');
    state.games.view = 'snake';
    state.games.selectedId = 'snake';
    renderGamesWindow();
    return;
  }
  openApp(id);
}

function isInFolder(id){
  return (state.folders.games || []).includes(id);
}

function addToFolder(folderId, ids){
  const folder = state.folders[folderId] || [];
  ids.forEach(id => {
    if(id === 'games' || id === 'trash') return;
    if(!folder.includes(id)) folder.push(id);
  });
  state.folders[folderId] = folder;
  saveFolders();
}

function removeFromFolder(folderId, ids){
  const folder = state.folders[folderId] || [];
  state.folders[folderId] = folder.filter(id => !ids.includes(id));
  saveFolders();
}

function isOverTrashWindow(x, y){
  const win = document.getElementById('win_trash');
  if(!win || win.classList.contains('hidden')) return false;
  const content = win.querySelector('.content');
  if(!content) return false;
  const r = content.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function isOverGamesWindow(x, y){
  const win = document.getElementById('win_games');
  if(!win || win.classList.contains('hidden')) return false;
  if(state.games.view !== 'list') return false;
  const content = win.querySelector('.content');
  if(!content) return false;
  const r = content.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function isOverDesktopArea(x, y){
  const area = $('#desktopArea').getBoundingClientRect();
  return x >= area.left && x <= area.right && y >= area.top && y <= area.bottom;
}

function setIconPosition(id, x, y){
  const saved = loadIconPositions();
  const metrics = getGridMetrics();
  let nx = x;
  let ny = y;
  if(state.gridSnap){
    const snapped = snapToGrid(nx, ny);
    nx = snapped.x;
    ny = snapped.y;
  }
  const occupied = buildOccupied([id], metrics);
  const placed = placeOnFreeCell(nx, ny, occupied, metrics);
  saved[id] = { x: placed.x, y: placed.y };
  saveIconPositions(saved);
}

function makeGameItemDraggable(itemEl, id){
  let down = false;
  let dragging = false;
  let pointerId = null;
  let startX = 0;
  let startY = 0;
  let ghost = null;
  const dragLayer = $('#dragLayer');

  const onPointerDown = (e)=>{
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    down = true;
    dragging = false;
    pointerId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    itemEl.setPointerCapture(pointerId);
    itemEl.addEventListener('pointermove', onPointerMove);
    itemEl.addEventListener('pointerup', onPointerUp);
    itemEl.addEventListener('pointercancel', onPointerUp);
  };

  const onPointerMove = (e)=>{
    if(!down) return;
    if(pointerId !== null && e.pointerId !== pointerId) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    if(!dragging && (Math.abs(dx) + Math.abs(dy) > 4)){
      dragging = true;
      if(dragLayer){
        dragLayer.classList.add('active');
        ghost = itemEl.cloneNode(true);
        ghost.classList.add('games-drag-ghost');
        if(state.games.bigIcons && state.games.layout === 'grid') ghost.classList.add('big');
        dragLayer.appendChild(ghost);
      }
    }
    if(!dragging || !ghost) return;
    const area = $('#desktopArea').getBoundingClientRect();
    ghost.style.left = (e.clientX - area.left - 20) + 'px';
    ghost.style.top = (e.clientY - area.top - 20) + 'px';
  };

  const onPointerUp = (e)=>{
    if(pointerId !== null && e.pointerId !== pointerId) return;
    down = false;
    try{ itemEl.releasePointerCapture(e.pointerId); } catch {}
    itemEl.removeEventListener('pointermove', onPointerMove);
    itemEl.removeEventListener('pointerup', onPointerUp);
    itemEl.removeEventListener('pointercancel', onPointerUp);

    if(ghost && dragLayer){
      ghost.remove();
      dragLayer.classList.remove('active');
      ghost = null;
    }

    if(dragging && isOverDesktopArea(e.clientX, e.clientY) && !isOverGamesWindow(e.clientX, e.clientY)){
      removeFromFolder('games', [id]);
      const area = $('#desktopArea').getBoundingClientRect();
      const x = clamp(Math.round(e.clientX - area.left - ICON_SIZE.w / 2), 0, area.width - ICON_SIZE.w - 6);
      const y = clamp(Math.round(e.clientY - area.top - ICON_SIZE.h / 2), 0, area.height - ICON_SIZE.h - 6);
      setIconPosition(id, x, y);
      renderIcons();
      renderGamesWindow();
    }

    dragging = false;
    pointerId = null;
  };

  itemEl.addEventListener('pointerdown', onPointerDown);
}

function loadYouTubeApiKey(){
  try{
    return localStorage.getItem(YOUTUBE_KEY) || '';
  } catch {
    return '';
  }
}

function saveYouTubeApiKey(key){
  try{
    if(key){
      localStorage.setItem(YOUTUBE_KEY, key);
    } else {
      localStorage.removeItem(YOUTUBE_KEY);
    }
  } catch {}
}

function getFallbackEmbedUrl(){
  return `https://www.youtube.com/embed?listType=search&list=${encodeURIComponent(VIDEO_CHANNEL_HANDLE)}`;
}

function formatIsoDuration(iso){
  const match = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/.exec(iso || '');
  if(!match) return '';
  const h = parseInt(match[1] || '0', 10);
  const m = parseInt(match[2] || '0', 10);
  const s = parseInt(match[3] || '0', 10);
  const mm = String(m + (h * 60)).padStart(2, '0');
  const ss = String(s).padStart(2, '0');
  return `${mm}:${ss}`;
}

function formatVideoDate(iso){
  const d = new Date(iso);
  if(Number.isNaN(d.getTime())) return '';
  const locale = state.lang === 'pt' ? 'pt-BR' : 'en-US';
  return d.toLocaleDateString(locale, { year:'numeric', month:'short', day:'numeric' });
}

async function fetchYouTubeVideos(apiKey){
  const base = 'https://www.googleapis.com/youtube/v3';
  const channelUrl = `${base}/channels?part=contentDetails&forHandle=${encodeURIComponent(VIDEO_CHANNEL_HANDLE)}&key=${encodeURIComponent(apiKey)}`;
  const chRes = await fetch(channelUrl);
  if(!chRes.ok) throw new Error('channel');
  const chData = await chRes.json();
  const uploads = chData?.items?.[0]?.contentDetails?.relatedPlaylists?.uploads;
  if(!uploads) throw new Error('uploads');

  const listUrl = `${base}/playlistItems?part=snippet,contentDetails&maxResults=24&playlistId=${uploads}&key=${encodeURIComponent(apiKey)}`;
  const listRes = await fetch(listUrl);
  if(!listRes.ok) throw new Error('playlist');
  const listData = await listRes.json();
  const items = (listData.items || []).map(it => ({
    id: it?.contentDetails?.videoId,
    title: it?.snippet?.title || '',
    thumb: it?.snippet?.thumbnails?.medium?.url || it?.snippet?.thumbnails?.default?.url || '',
    publishedAt: it?.contentDetails?.videoPublishedAt || it?.snippet?.publishedAt || ''
  })).filter(it => it.id);

  const ids = items.map(it => it.id).join(',');
  if(!ids) return [];
  const videosUrl = `${base}/videos?part=contentDetails&id=${ids}&key=${encodeURIComponent(apiKey)}`;
  const vidsRes = await fetch(videosUrl);
  if(!vidsRes.ok) throw new Error('videos');
  const vidsData = await vidsRes.json();
  const durationMap = new Map();
  (vidsData.items || []).forEach(v => {
    durationMap.set(v.id, formatIsoDuration(v?.contentDetails?.duration));
  });

  return items.map(it => ({
    ...it,
    duration: durationMap.get(it.id) || ''
  }));
}

function renderVideoPlayer(winEl, videoId, opts = {}){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const frame = win.querySelector('#videosPlayer');
  if(!frame) return;
  const src = videoId
    ? `https://www.youtube.com/embed/${videoId}?rel=0`
    : getFallbackEmbedUrl();
  if(opts.force || frame.src !== src){
    frame.src = src;
  }
}

function renderVideosList(winEl, items){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const list = win.querySelector('#videosList');
  if(!list) return;
  if(!items || items.length === 0){
    list.innerHTML = `<div class="tiny" data-i18n="videos.listEmpty">${t('videos.listEmpty')}</div>`;
    return;
  }
  list.innerHTML = items.map(it => {
    const selected = it.id === state.videos.selectedId;
    const date = formatVideoDate(it.publishedAt);
    const meta = [it.duration, date].filter(Boolean).join(' • ');
    return `
      <button class="videos-item bevel-in${selected ? ' selected' : ''}" type="button" data-video-id="${it.id}">
        <img class="videos-thumb pixel" src="${it.thumb}" alt="" />
        <div class="videos-meta">
          <div class="videos-title">${it.title}</div>
          <div class="videos-sub">${meta}</div>
        </div>
      </button>
    `;
  }).join('');
}

function initVideosWindow(winEl){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const status = win.querySelector('#videosStatus');
  if(status) status.textContent = '';
  renderVideoPlayer(win, null, { force:true });

  const key = loadYouTubeApiKey();
  if(!key){
    if(status) status.textContent = t('videos.noKey');
    renderVideosList(win, []);
    return;
  }

  if(status) status.textContent = t('videos.loading');
  fetchYouTubeVideos(key).then(items => {
    state.videos.items = items;
    state.videos.selectedId = items[0]?.id || null;
    if(items[0]) renderVideoPlayer(win, items[0].id, { force:true });
    renderVideosList(win, items);
    if(status) status.textContent = items.length ? '' : t('videos.listEmpty');
  }).catch(()=>{
    if(status) status.textContent = t('videos.autoFail');
    renderVideosList(win, []);
    renderVideoPlayer(win, null, { force:true });
  });
}

function applyScanlines(){
  document.body.classList.toggle('scanlines', state.settings.scanlines);
  saveScanlines();
  updateScanlinesButtons();
}

function applyRetroGlow(){
  document.body.classList.toggle('retro-glow', state.settings.retroGlow);
  saveRetroGlow();
  updateRetroGlowButtons();
}

function applyDarkMode(){
  document.body.classList.toggle('dark', state.settings.darkMode);
  saveDarkMode();
  updateDarkModeButtons();
  renderCtxMenu();
  applyTitlebarTheme();
}

function applyWindowState(winEl, appId){
  if(appId === 'music') applyMusicState(winEl);
  if(appId === 'mediaplayer') applyMediaplayerState(winEl);
  if(appId === 'diev') applyDievState(winEl);
  if(appId === 'art') applyArtState(winEl);
}

function getPoemById(id){
  return POEMS.find(p => p.id === id) || null;
}

function getPoemBody(poem, lang){
  if(!poem) return '';
  if(lang === 'pt') return poem.body_pt || poem.body_en || '';
  return poem.body_en || poem.body_pt || '';
}

// Context menu state
let ctxState = { open:false, target:'desktop', appId:null };

function renderCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;

  const isIcon = ctxState.target === 'icon' && !!ctxState.appId;
  const gridMark = state.gridSnap ? '✓' : '';

  const items = [];
  if(isIcon){
    items.push({ action:'open', label:t('ctx.open') });
    items.push({ sep:true });
    if(ctxState.appId === 'trash'){
      items.push({ action:'emptyTrash', label:t('ctx.emptyTrash') });
      items.push({ sep:true });
    } else {
      items.push({ action:'rename', label:t('ctx.rename') });
      items.push({ action:'crop', label:t('ctx.crop') });
      items.push({ action:'copy', label:t('ctx.copy') });
      items.push({ sep:true });
      items.push({ action:'moveTrash', label:t('ctx.moveTrash') });
      items.push({ sep:true });
    }
  }

  if(!isIcon){
    items.push({ action:'arrange', label:t('ctx.arrange') });
    items.push({ action:'grid', label:t('ctx.grid'), check:gridMark });
    items.push({ action:'wallpaper', label:t('ctx.wallpaper') });
    items.push({ sep:true });
    items.push({ action:'settings', label:t('ctx.settings') });
    items.push({ action:'language', label:t('ctx.language'), right: state.lang.toUpperCase() });
    items.push({ action:'about', label:t('ctx.about') });
    items.push({ sep:true });
    items.push({ action:'logoff', label:t('ctx.logoff') });
  }

  menu.innerHTML = items.map(it => {
    if(it.sep) return `<div class="ctx-sep"></div>`;
    const check = it.check ? `<span class="ctx-check" aria-hidden="true">${it.check}</span>` : `<span class="ctx-check" aria-hidden="true"></span>`;
    const right = it.right ? `<span class="ctx-shortcut">${it.right}</span>` : `<span class="ctx-shortcut"></span>`;
    return `
      <button class="ctx-item" type="button" role="menuitem" data-ctx-action="${it.action}">
        <span class="ctx-left">${check}<span>${it.label}</span></span>
        ${right}
      </button>
    `;
  }).join('');
}

function positionCtxMenu(x, y){
  const menu = $('#ctxMenu');
  if(!menu) return;
  const area = $('#desktopArea').getBoundingClientRect();

  menu.classList.remove('hidden');
  menu.style.left = '0px';
  menu.style.top = '0px';
  const rect = menu.getBoundingClientRect();

  const maxX = area.left + area.width - rect.width - 6;
  const maxY = area.top + area.height - rect.height - 6;

  const px = clamp(x, area.left + 6, maxX);
  const py = clamp(y, area.top + 6, area.top + area.height - rect.height - 6);

  menu.style.left = (px - area.left) + 'px';
  menu.style.top = (py - area.top) + 'px';
}

function openCtxMenu(x, y, target='desktop', appId=null){
  if($('#desktop').classList.contains('hidden')) return;
  ctxState = { open:true, target, appId };
  closeStartMenu();
  closeWindowMenu();
  renderCtxMenu();
  positionCtxMenu(x, y);
  const menu = $('#ctxMenu');
  if(menu){
    menu.classList.remove('hidden');
    const first = menu.querySelector('.ctx-item');
    if(first) first.focus();
  }
}

function closeCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;
  menu.classList.add('hidden');
  ctxState = { open:false, target:'desktop', appId:null };
}

function handleCtxAction(action){
  if(action === 'open' && ctxState.target === 'icon' && ctxState.appId){
    openIconById(ctxState.appId);
  }
  if(action === 'rename' && ctxState.target === 'icon' && ctxState.appId && ctxState.appId !== 'trash'){
    const app = getAppById(ctxState.appId);
    const virtual = getVirtualIconById(ctxState.appId);
    const key = app ? app.titleKey : (virtual ? virtual.titleKey : null);
    if(!key) return;
    const current = state.iconLabels[ctxState.appId] || t(key);
    showInputDialog({
      titleKey: 'dialog.rename.title',
      descKey: 'dialog.rename.desc',
      value: current,
      confirmKey: 'dialog.rename.confirm',
      onConfirm: (val)=>{
        const next = String(val || '').trim();
        if(next){
          state.iconLabels[ctxState.appId] = next;
        } else {
          delete state.iconLabels[ctxState.appId];
        }
        saveIconLabels();
        renderIcons();
      }
    });
  }
  if(action === 'crop' && ctxState.target === 'icon' && ctxState.appId){
    showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
  }
  if(action === 'copy' && ctxState.target === 'icon' && ctxState.appId){
    const app = APPS.find(a => a.id === ctxState.appId);
    const label = app ? getIconLabel(app) : '';
    if(label){
      copyText(label).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
    } else {
      showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
    }
  }
  if(action === 'moveTrash' && ctxState.target === 'icon' && ctxState.appId){
    moveIconsToTrash([ctxState.appId]);
  }
  if(action === 'emptyTrash' && ctxState.target === 'icon' && ctxState.appId === 'trash'){
    emptyTrash();
  }
  if(action === 'arrange') arrangeIcons();
  if(action === 'grid'){
    state.gridSnap = !state.gridSnap;
    saveGridSnap();
    renderCtxMenu();
  }
  if(action === 'wallpaper'){
    openSettingsAndTab('appearance', 'settingsWallpaper');
  }
  if(action === 'settings') openApp('settings');
  if(action === 'language') toggleLang();
  if(action === 'about') openApp('about');
  if(action === 'logoff'){
    closeCtxMenu();
    closeStartMenu();
    doLogoff();
  }
}

// Long-press support (mobile/touch)
function installLongPress(el, getTarget){
  let timer = null;
  let start = null;
  const threshold = 8;
  const delay = 520;

  const clear = ()=>{
    if(timer){ clearTimeout(timer); timer = null; }
    start = null;
  };

  el.addEventListener('pointerdown', (e)=>{
    if(e.pointerType !== 'touch') return;
    start = { x:e.clientX, y:e.clientY };
    timer = setTimeout(()=>{
      const tgt = getTarget ? getTarget() : { target:'desktop', appId:null };
      openCtxMenu(e.clientX, e.clientY, tgt.target, tgt.appId);
      clear();
    }, delay);
  });

  el.addEventListener('pointermove', (e)=>{
    if(!start || !timer) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    if(Math.hypot(dx,dy) > threshold){
      clear();
    }
  });

  el.addEventListener('pointerup', clear);
  el.addEventListener('pointercancel', clear);
}

      const I18N = {
        en: {
          'login.sub': 'Enter your name to login',
          'login.labelName': 'Name:',
          'login.placeholder': 'Enter your name',
          'login.hint': 'Hint: Ignorance is BLISS',
          'login.clear': 'Clear',
          'login.enter': 'Enter',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Soon.',
          'common.ok': 'OK',
          'common.cancel': 'Cancel',
          'common.save': 'Save',
          'common.open': 'Open',
          'common.copy': 'Copy',

          'aria.language': 'Language',
          'aria.startMenu': 'BLISS Menu',
          'aria.contextMenu': 'Context menu',
          'aria.close': 'Close',
          'start.menu': 'Menu',

          'menubar.file': 'File',
          'menubar.edit': 'Edit',
          'menubar.view': 'View',
          'menubar.help': 'Help',

          'status.ready': 'Ready',

          'win.minimize': 'Minimize',
          'win.maximize': 'Fit to content',
          'win.close': 'Close',
          'win.resize': 'Resize',

          'app.clothes': 'Clothes',
          'app.music': 'Music',
          'app.art': 'Art',
          'app.games': 'Games',
          'app.videos': 'Videos',
          'app.about': 'About',
          'app.contact': 'Contact',
          'app.diev': 'DIEV',
          'app.settings': 'Settings',
          'app.poetry': 'Poetry',
          'app.trash': 'Recycle Bin',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.back': 'Back',
          'games.viewGrid': 'Grid view',
          'games.viewList': 'List view',
          'games.bigIcons': 'Bigger Icons',
          'games.empty': 'No games yet.',
          'snake.title': 'Snake',
          'snake.start': 'Start',
          'snake.restart': 'Restart',
          'snake.pause': 'Pause',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Speed:',
          'snake.speed.slow': 'Slow',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Fast',
          'snake.instructions': 'Use arrow keys or WASD. On mobile, swipe.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Play again',

          'menu.logoff': 'Log off…',

          'ctx.open': 'Open',
          'ctx.rename': 'Rename',
          'ctx.crop': 'Crop',
          'ctx.copy': 'Copy',
          'ctx.moveTrash': 'Move to Recycle Bin',
          'ctx.emptyTrash': 'Empty Recycle Bin',
          'ctx.arrange': 'Arrange icons',
          'ctx.grid': 'Grid (snap)',
          'ctx.wallpaper': 'Wallpaper',
          'ctx.settings': 'Settings',
          'ctx.language': 'Language',
          'ctx.about': 'About',
          'ctx.logoff': 'Log off…',

          'settings.title': 'Settings',
          'settings.tab.general': 'General',
          'settings.tab.language': 'Language',
          'settings.tab.appearance': 'Appearance',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'System properties and preferences for BLISS 98.',
          'settings.general.user': 'User:',
          'settings.general.guest': 'Guest',
          'settings.general.version': 'Version:',
          'settings.general.registeredTo': 'Registered to:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Language',
          'settings.languageDesc': 'Choose your language for BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',
          'settings.appearanceTab': 'Appearance',
          'settings.appearanceDesc': 'Customize how BLISS 98 looks.',
          'settings.themes.title': 'Themes',
          'settings.themes.desc': 'Select a theme to change wallpaper, title color, and dark mode.',
          'settings.themes.current': 'Current theme:',
          'settings.titlebar.title': 'Window Title Color',
          'settings.titlebar.desc': 'Choose the color of the window title bars.',
          'settings.darkMode.title': 'Dark Mode',
          'settings.darkMode.desc': 'Makes BLISS 98 darker and easier on the eyes.',
          'settings.darkMode.on': 'On',
          'settings.darkMode.off': 'Off',
          'settings.retro.title': 'Retro Glow',
          'settings.retro.desc': 'Add a soft glow to windows and icons.',
          'settings.retro.on': 'On',
          'settings.retro.off': 'Off',
          'settings.animationsTab': 'Animations',
          'settings.animationsDesc': 'Toggle window animations.',
          'settings.animations.on': 'On',
          'settings.animations.off': 'Off',
          'settings.wallpaperTab': 'Wallpaper',
          'settings.wallpaperDesc': 'Choose a wallpaper for your desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Add scanline effect to the display.',
          'settings.scanlines.on': 'On',
          'settings.scanlines.off': 'Off',
          'titlebar.defaultBlue': 'Default Blue',
          'titlebar.pinkLight': 'Light Pink',
          'titlebar.purpleDark': 'Dark Purple',
          'titlebar.offWhite': 'Off-white',
          'titlebar.greenDark': 'Dark Green',
          'titlebar.redDark': 'Dark Red',
          'titlebar.blank': 'Blank',
          'titlebar.xpBlue': 'XP Blue',
          'theme.default': 'Default',
          'theme.totvers': 'Totvers',
          'theme.matrix': 'Matrix',
          'theme.xp98': 'XP98',
          'theme.blank': 'Blank',
          'theme.custom': 'Custom',
          'theme.customEmpty': 'Empty',
          'theme.save': 'Save Custom',
          'poetry.title': 'Poetry Library',
          'poetry.back': 'Back',
          'poetry.language': 'Language',
          'poetry.empty': 'No poems yet.',

          'menu.file.newWindow': 'New Window…',
          'menu.file.close': 'Close',
          'menu.file.logoff': 'Log off…',
          'menu.help.controls': 'Controls',
          'menu.help.about': 'About BLISS 98',

          'menu.music.openLink': 'Open Link…',
          'menu.music.copyLink': 'Copy Link',
          'menu.music.selectAll': 'Select All',
          'menu.music.clearSelection': 'Clear Selection',
          'menu.music.tileSize': 'Tile size',
          'menu.music.tileSize.small': 'Small',
          'menu.music.tileSize.large': 'Large',
          'menu.music.openNewTab': 'Open in new tab (default)',
          'menu.music.showIcons': 'Show platform icons',
          'menu.music.where': 'Where to listen',

          'menu.player.openTrack': 'Open Track…',
          'menu.player.reload': 'Reload Library',
          'menu.player.selectAll': 'Select All',
          'menu.player.copyName': 'Copy Track Name',
          'menu.player.clearSelection': 'Clear Selection',
          'menu.player.shuffle': 'Shuffle',
          'menu.player.repeat': 'Repeat',
          'menu.player.repeat.off': 'Off',
          'menu.player.repeat.one': 'One',
          'menu.player.repeat.all': 'All',
          'menu.player.showPlaylist': 'Show Playlist',
          'menu.player.compact': 'Compact mode',
          'menu.player.tips': 'Playback tips',
          'menu.player.howto': 'How to add songs',

          'menu.clothes.openLookbook': 'Open Lookbook',
          'menu.clothes.shop': 'Shop…',
          'menu.clothes.copy': 'Copy',
          'menu.clothes.selectAll': 'Select All',
          'menu.clothes.viewGrid': 'Grid',
          'menu.clothes.sort': 'Sort by',
          'menu.clothes.sort.new': 'New',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Preview images',
          'menu.clothes.sizing': 'Sizing',

          'menu.diev.openPress': 'Open Press Kit',
          'menu.diev.copyBio': 'Copy Bio',
          'menu.diev.copy': 'Copy',
          'menu.diev.selectAll': 'Select All',
          'menu.diev.textSize': 'Text size',
          'menu.diev.textSize.small': 'Small',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Large',
          'menu.diev.highContrast': 'High contrast',
          'menu.diev.links': 'Links',

          'menu.contact.copyEmail': 'Copy Email',
          'menu.contact.openInstagram': 'Open Instagram',
          'menu.contact.copy': 'Copy',
          'menu.contact.selectAll': 'Select All',
          'menu.contact.showQr': 'Show QR',
          'menu.contact.compact': 'Compact',
          'menu.contact.support': 'Support',

          'menu.settings.apply': 'Apply',
          'menu.settings.reset': 'Reset to default',
          'menu.settings.undo': 'Undo',
          'menu.settings.redo': 'Redo',
          'menu.settings.fullscreen': 'Fullscreen',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Wallpaper…',
          'menu.settings.what': 'What is this?',

          'menu.art.openGallery': 'Open Gallery',
          'menu.art.saveImage': 'Save Image…',
          'menu.art.copy': 'Copy',
          'menu.art.selectAll': 'Select All',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Slideshow',
          'menu.art.credits': 'Credits',

          'menu.games.openFolder': 'Open Games Folder',
          'menu.games.download': 'Download…',
          'menu.games.copy': 'Copy',
          'menu.games.selectAll': 'Select All',
          'menu.games.grid': 'Grid',
          'menu.games.sort': 'Sort by',
          'menu.games.sort.new': 'New',
          'menu.games.sort.favorite': 'Favorite',
          'menu.games.requirements': 'Requirements',

          'menu.videos.openChannel': 'Open Channel',
          'menu.videos.copyLink': 'Copy Link',
          'menu.videos.copy': 'Copy',
          'menu.videos.selectAll': 'Select All',
          'menu.videos.thumbSize': 'Thumbnail size',
          'menu.videos.thumbSize.small': 'Small',
          'menu.videos.thumbSize.large': 'Large',
          'menu.videos.openNewTab': 'Open in new tab',
          'menu.videos.tips': 'Playback tips',
          'videos.channelLink': 'YouTube: @DIEVBLISS',
          'videos.watchTitle': 'Watch inside BLISS 98',
          'videos.openChannel': 'Watch channel videos',
          'videos.addKey': 'Add YouTube API Key…',
          'videos.noKey': 'Add a YouTube API key to load the full list. You can still watch here.',
          'videos.autoFail': 'Unable to load videos automatically. You can still open the channel.',
          'videos.loading': 'Loading videos…',
          'videos.listEmpty': 'No videos yet.',
          'videos.keyTitle': 'YouTube API Key',
          'videos.keyDesc': 'Paste your YouTube Data API v3 key to load the channel videos.',

          'menu.about.copy': 'Copy',
          'menu.about.selectAll': 'Select All',
          'menu.about.version': 'Version info',
          'menu.about.credits': 'Credits',
          'menu.about.controls': 'Controls',

          'dialog.newWindow.title': 'New Window',
          'dialog.newWindow.desc': 'Choose an app to open.',
          'dialog.newWindow.open': 'Open',
          'dialog.openLink.title': 'Open Link',
          'dialog.openLink.desc': 'Choose a platform.',
          'dialog.openLink.open': 'Open',
          'dialog.openTrack.title': 'Open Track',
          'dialog.openTrack.desc': 'Choose a track from the playlist.',
          'dialog.openTrack.open': 'Open',
          'dialog.controls.title': 'Controls',
          'dialog.controls.body': 'Drag windows by the title bar. Resize from the corner. Right-click or long-press the desktop for options.',
          'dialog.where.title': 'Where to listen',
          'dialog.where.body': 'These are official BLISS links. Pick a platform to open or copy the link.',
          'dialog.playerTips.title': 'Playback tips',
          'dialog.playerTips.body': 'Autoplay may be blocked. If it does not start, press Play once.',
          'dialog.support.title': 'Support',
          'dialog.support.body': 'Report issues through the Contact window when available. We will keep the system updated.',
          'dialog.settingsWhat.title': 'Settings',
          'dialog.settingsWhat.body': 'Adjust language, wallpaper, and window animations for BLISS 98.',
          'dialog.version.title': 'Version info',
          'dialog.version.body': 'BLISS 98 — Build 98.0',
          'dialog.credits.title': 'Credits',
          'dialog.credits.body': 'Created by DIEV.',
          'dialog.notAvailable.title': 'Coming soon',
          'dialog.notAvailable.body': 'This feature is not available yet.',
          'dialog.selectItem.title': 'Select an item',
          'dialog.selectItem.body': 'Select an item first to continue.',
          'dialog.copied.title': 'Copied',
          'dialog.copied.body': 'Copied to clipboard.',
          'dialog.settingsApplied.title': 'Settings',
          'dialog.settingsApplied.body': 'Settings applied.',
          'dialog.noUndo.title': 'Undo',
          'dialog.noUndo.body': 'Nothing to undo.',
          'dialog.noRedo.title': 'Redo',
          'dialog.noRedo.body': 'Nothing to redo.',
          'dialog.rename.title': 'Rename',
          'dialog.rename.desc': 'Enter a new name.',
          'dialog.rename.confirm': 'Rename',
          'dialog.loginEmpty.title': 'Enter your name',
          'dialog.loginEmpty.body': 'Please type a name to continue.',
          'dialog.trash.empty': 'Recycle Bin is empty.',
          'dialog.trash.restore': 'Restore',
          'dialog.trash.restoreAll': 'Restore All',
          'dialog.trash.emptyAction': 'Empty Recycle Bin',

          'wallpaper.classic': 'Classic Teal',
          'wallpaper.bliss': 'Sunrise',
          'wallpaper.clouds': 'Clouds',
          'wallpaper.diev': 'Grid',
          'wallpaper.tot': 'Tot (Pink)',
          'wallpaper.matrix': 'Matrix',
          'wallpaper.xp98bliss': 'XP Bliss 98',

          'music.title': 'BLISS — Music',
          'music.subtitle': 'Listen everywhere:',
          'music.tip': 'Music is a beautiful thing, innit?',

          'clothes.title': 'BLISS — Clothes',
          'clothes.subtitle': 'Latest from Instagram.',
          'clothes.loading': 'Loading…',
          'clothes.unavailable': 'Unable to load right now.',
          'clothes.thumbAlt': 'BLISS Instagram',

          'about.title': 'About',
          'about.p1': 'BLISS is a project that aims to bring together independent, weird, and unique artists,',
          'about.p2': 'supporting every form of art and self-expression.',
          'about.p3': 'Against the system and the dogmas created by humans,',
          'about.p4': 'we are our own GODS.',
          'about.p5': 'There are no rules.',
          'about.p6': 'We create our own world from the inside out.',
          'about.footer': 'Designed By DIEV',

          'contact.title': 'Contact',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Official page for DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Now playing:',
          'player.play': 'Play',
          'player.pause': 'Pause',
          'player.prev': 'Prev',
          'player.next': 'Next',
          'player.vol': 'Vol',
          'player.shuffle': 'Shuffle',
          'player.repeat': 'Repeat',
          'player.repeat.off': 'Off',
          'player.repeat.one': 'One',
          'player.repeat.all': 'All',
          'player.loading': 'Loading tracks…',
          'player.notfound': 'No songs yet.',
          'player.autoplay': 'Autoplay may be blocked by your browser. If it does not start, press Play.',
          'player.addSongs': 'Add songs…',
          'player.reimport': 'Re-import files',
          'player.reimportHint': 'Re-import files to restore your playlist.',
          'player.drop': 'Drop audio files here',
          'player.flacUnsupported': 'Your browser does not support FLAC. Use MP3/WAV/OGG or another browser.',
          'dialog.playerHowTo.title': 'How to add songs',
          'dialog.playerHowTo.body': 'Add songs by dragging audio files into the player window, or click Add songs… to choose files.'
        },
        pt: {
          'login.sub': 'Digite seu nome para entrar',
          'login.labelName': 'Nome:',
          'login.placeholder': 'Digite seu nome',
          'login.hint': 'Dica: Ignorância é BLISS',
          'login.clear': 'Limpar',
          'login.enter': 'Entrar',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Em breve.',
          'common.ok': 'OK',
          'common.cancel': 'Cancelar',
          'common.save': 'Salvar',
          'common.open': 'Abrir',
          'common.copy': 'Copiar',

          'aria.language': 'Idioma',
          'aria.startMenu': 'Menu BLISS',
          'aria.contextMenu': 'Menu de contexto',
          'aria.close': 'Fechar',
          'start.menu': 'Menu',

          'menubar.file': 'Arquivo',
          'menubar.edit': 'Editar',
          'menubar.view': 'Exibir',
          'menubar.help': 'Ajuda',

          'status.ready': 'Pronto',

          'win.minimize': 'Minimizar',
          'win.maximize': 'Ajustar ao conteúdo',
          'win.close': 'Fechar',
          'win.resize': 'Redimensionar',

          'app.clothes': 'Roupas',
          'app.music': 'Música',
          'app.art': 'Arte',
          'app.games': 'Jogos',
          'app.videos': 'Vídeos',
          'app.about': 'Sobre',
          'app.contact': 'Contato',
          'app.diev': 'DIEV',
          'app.settings': 'Configurações',
          'app.poetry': 'Poesias',
          'app.trash': 'Lixeira',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.back': 'Voltar',
          'games.viewGrid': 'Grade',
          'games.viewList': 'Lista',
          'games.bigIcons': 'Ícones grandes',
          'games.empty': 'Sem jogos ainda.',
          'snake.title': 'Snake',
          'snake.start': 'Iniciar',
          'snake.restart': 'Reiniciar',
          'snake.pause': 'Pausar',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Velocidade:',
          'snake.speed.slow': 'Lento',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Rápido',
          'snake.instructions': 'Use as setas ou WASD. No celular, deslize.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Jogar novamente',

          'menu.logoff': 'Sair…',

          'ctx.open': 'Abrir',
          'ctx.rename': 'Renomear',
          'ctx.crop': 'Recortar',
          'ctx.copy': 'Copiar',
          'ctx.moveTrash': 'Mover para a Lixeira',
          'ctx.emptyTrash': 'Esvaziar Lixeira',
          'ctx.arrange': 'Organizar ícones',
          'ctx.grid': 'Grade (snap)',
          'ctx.wallpaper': 'Plano de Fundo',
          'ctx.settings': 'Configurações',
          'ctx.language': 'Idioma',
          'ctx.about': 'Sobre',
          'ctx.logoff': 'Sair…',

          'settings.title': 'Configurações',
          'settings.tab.general': 'Geral',
          'settings.tab.language': 'Idioma',
          'settings.tab.appearance': 'Aparência',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'Propriedades e ajustes do BLISS 98.',
          'settings.general.user': 'Usuário:',
          'settings.general.guest': 'Convidado',
          'settings.general.version': 'Versão:',
          'settings.general.registeredTo': 'Registrado para:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Idioma',
          'settings.languageDesc': 'Escolha o idioma do BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',
          'settings.appearanceTab': 'Aparência',
          'settings.appearanceDesc': 'Personalize o visual do BLISS 98.',
          'settings.themes.title': 'Temas',
          'settings.themes.desc': 'Selecione um tema para mudar papel de parede, cor do topo e dark mode.',
          'settings.themes.current': 'Tema atual:',
          'settings.titlebar.title': 'Cor do topo da janela',
          'settings.titlebar.desc': 'Escolha a cor das barras de título.',
          'settings.darkMode.title': 'Modo Escuro',
          'settings.darkMode.desc': 'Deixa o BLISS 98 mais escuro e confortável.',
          'settings.darkMode.on': 'Ligado',
          'settings.darkMode.off': 'Desligado',
          'settings.retro.title': 'Brilho Retro',
          'settings.retro.desc': 'Adicione um brilho suave nas janelas e ícones.',
          'settings.retro.on': 'Ligado',
          'settings.retro.off': 'Desligado',
          'settings.animationsTab': 'Animações',
          'settings.animationsDesc': 'Ative ou desative as animações das janelas.',
          'settings.animations.on': 'Ligado',
          'settings.animations.off': 'Desligado',
          'settings.wallpaperTab': 'Papel de parede',
          'settings.wallpaperDesc': 'Escolha um papel de parede para o desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Adicione efeito de scanlines na tela.',
          'settings.scanlines.on': 'Ligado',
          'settings.scanlines.off': 'Desligado',
          'titlebar.defaultBlue': 'Azul padrão',
          'titlebar.pinkLight': 'Rosa claro',
          'titlebar.purpleDark': 'Roxo escuro',
          'titlebar.offWhite': 'Branco off-white',
          'titlebar.greenDark': 'Verde escuro',
          'titlebar.redDark': 'Vermelho escuro',
          'titlebar.blank': 'Vazio',
          'titlebar.xpBlue': 'Azul XP',
          'theme.default': 'Padrão',
          'theme.totvers': 'Totvers',
          'theme.matrix': 'Matrix',
          'theme.xp98': 'XP98',
          'theme.blank': 'Vazio',
          'theme.custom': 'Personalizado',
          'theme.customEmpty': 'Vazio',
          'theme.save': 'Salvar personalizado',
          'poetry.title': 'Biblioteca de Poesias',
          'poetry.back': 'Voltar',
          'poetry.language': 'Idioma',
          'poetry.empty': 'Sem poesias ainda.',

          'menu.file.newWindow': 'Nova janela…',
          'menu.file.close': 'Fechar',
          'menu.file.logoff': 'Sair…',
          'menu.help.controls': 'Controles',
          'menu.help.about': 'Sobre BLISS 98',

          'menu.music.openLink': 'Abrir link…',
          'menu.music.copyLink': 'Copiar link',
          'menu.music.selectAll': 'Selecionar tudo',
          'menu.music.clearSelection': 'Limpar seleção',
          'menu.music.tileSize': 'Tamanho dos cards',
          'menu.music.tileSize.small': 'Pequeno',
          'menu.music.tileSize.large': 'Grande',
          'menu.music.openNewTab': 'Abrir em nova aba (padrão)',
          'menu.music.showIcons': 'Mostrar ícones',
          'menu.music.where': 'Onde ouvir',

          'menu.player.openTrack': 'Abrir faixa…',
          'menu.player.reload': 'Recarregar biblioteca',
          'menu.player.selectAll': 'Selecionar tudo',
          'menu.player.copyName': 'Copiar nome da faixa',
          'menu.player.clearSelection': 'Limpar seleção',
          'menu.player.shuffle': 'Aleatório',
          'menu.player.repeat': 'Repetir',
          'menu.player.repeat.off': 'Desligado',
          'menu.player.repeat.one': 'Uma',
          'menu.player.repeat.all': 'Todas',
          'menu.player.showPlaylist': 'Mostrar playlist',
          'menu.player.compact': 'Modo compacto',
          'menu.player.tips': 'Dicas de reprodução',
          'menu.player.howto': 'Como adicionar músicas',

          'menu.clothes.openLookbook': 'Abrir lookbook',
          'menu.clothes.shop': 'Loja…',
          'menu.clothes.copy': 'Copiar',
          'menu.clothes.selectAll': 'Selecionar tudo',
          'menu.clothes.viewGrid': 'Grade',
          'menu.clothes.sort': 'Ordenar por',
          'menu.clothes.sort.new': 'Novidades',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Pré-visualizar',
          'menu.clothes.sizing': 'Tamanhos',

          'menu.diev.openPress': 'Abrir press kit',
          'menu.diev.copyBio': 'Copiar bio',
          'menu.diev.copy': 'Copiar',
          'menu.diev.selectAll': 'Selecionar tudo',
          'menu.diev.textSize': 'Tamanho do texto',
          'menu.diev.textSize.small': 'Pequeno',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Grande',
          'menu.diev.highContrast': 'Alto contraste',
          'menu.diev.links': 'Links oficiais',

          'menu.contact.copyEmail': 'Copiar e-mail',
          'menu.contact.openInstagram': 'Abrir Instagram',
          'menu.contact.copy': 'Copiar',
          'menu.contact.selectAll': 'Selecionar tudo',
          'menu.contact.showQr': 'Mostrar QR',
          'menu.contact.compact': 'Compacto',
          'menu.contact.support': 'Suporte',

          'menu.settings.apply': 'Aplicar',
          'menu.settings.reset': 'Restaurar padrão',
          'menu.settings.undo': 'Desfazer',
          'menu.settings.redo': 'Refazer',
          'menu.settings.fullscreen': 'Tela cheia',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Papel de parede…',
          'menu.settings.what': 'O que é isso?',

          'menu.art.openGallery': 'Abrir galeria',
          'menu.art.saveImage': 'Salvar imagem…',
          'menu.art.copy': 'Copiar',
          'menu.art.selectAll': 'Selecionar tudo',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Apresentação',
          'menu.art.credits': 'Créditos',

          'menu.games.openFolder': 'Abrir pasta de jogos',
          'menu.games.download': 'Download…',
          'menu.games.copy': 'Copiar',
          'menu.games.selectAll': 'Selecionar tudo',
          'menu.games.grid': 'Grade',
          'menu.games.sort': 'Ordenar por',
          'menu.games.sort.new': 'Novidades',
          'menu.games.sort.favorite': 'Favorito',
          'menu.games.requirements': 'Requisitos',

          'menu.videos.openChannel': 'Abrir canal',
          'menu.videos.copyLink': 'Copiar link',
          'menu.videos.copy': 'Copiar',
          'menu.videos.selectAll': 'Selecionar tudo',
          'menu.videos.thumbSize': 'Tamanho das miniaturas',
          'menu.videos.thumbSize.small': 'Pequeno',
          'menu.videos.thumbSize.large': 'Grande',
          'menu.videos.openNewTab': 'Abrir em nova aba',
          'menu.videos.tips': 'Dicas',
          'videos.channelLink': 'YouTube: @DIEVBLISS',
          'videos.watchTitle': 'Assista no BLISS 98',
          'videos.openChannel': 'Assistir vídeos do canal',
          'videos.addKey': 'Adicionar chave da API do YouTube…',
          'videos.noKey': 'Adicione uma chave da API do YouTube para carregar a lista completa. Ainda dá para assistir por aqui.',
          'videos.autoFail': 'Não foi possível carregar os vídeos automaticamente. Você ainda pode abrir o canal.',
          'videos.loading': 'Carregando vídeos…',
          'videos.listEmpty': 'Ainda não há vídeos.',
          'videos.keyTitle': 'Chave da API do YouTube',
          'videos.keyDesc': 'Cole sua chave da API do YouTube Data v3 para carregar os vídeos do canal.',

          'menu.about.copy': 'Copiar',
          'menu.about.selectAll': 'Selecionar tudo',
          'menu.about.version': 'Informações da versão',
          'menu.about.credits': 'Créditos',
          'menu.about.controls': 'Controles',

          'dialog.newWindow.title': 'Nova janela',
          'dialog.newWindow.desc': 'Escolha um app para abrir.',
          'dialog.newWindow.open': 'Abrir',
          'dialog.openLink.title': 'Abrir link',
          'dialog.openLink.desc': 'Escolha uma plataforma.',
          'dialog.openLink.open': 'Abrir',
          'dialog.openTrack.title': 'Abrir faixa',
          'dialog.openTrack.desc': 'Escolha uma faixa da playlist.',
          'dialog.openTrack.open': 'Abrir',
          'dialog.controls.title': 'Controles',
          'dialog.controls.body': 'Arraste a janela pela barra de título. Redimensione pelo canto. Clique com o botão direito ou pressione e segure no desktop para opções.',
          'dialog.where.title': 'Onde ouvir',
          'dialog.where.body': 'Estes são links oficiais da BLISS. Escolha uma plataforma para abrir ou copiar.',
          'dialog.playerTips.title': 'Dicas de reprodução',
          'dialog.playerTips.body': 'O autoplay pode ser bloqueado. Se não tocar, aperte Play uma vez.',
          'dialog.support.title': 'Suporte',
          'dialog.support.body': 'Reporte problemas pela janela de Contato quando estiver disponível. Vamos manter o sistema atualizado.',
          'dialog.settingsWhat.title': 'Configurações',
          'dialog.settingsWhat.body': 'Ajuste idioma, papel de parede e animações das janelas do BLISS 98.',
          'dialog.version.title': 'Informações da versão',
          'dialog.version.body': 'BLISS 98 — Build 98.0',
          'dialog.credits.title': 'Créditos',
          'dialog.credits.body': 'Criado por DIEV.',
          'dialog.notAvailable.title': 'Em breve',
          'dialog.notAvailable.body': 'Este recurso ainda não está disponível.',
          'dialog.selectItem.title': 'Selecione um item',
          'dialog.selectItem.body': 'Selecione um item para continuar.',
          'dialog.copied.title': 'Copiado',
          'dialog.copied.body': 'Copiado para a área de transferência.',
          'dialog.settingsApplied.title': 'Configurações',
          'dialog.settingsApplied.body': 'Configurações aplicadas.',
          'dialog.noUndo.title': 'Desfazer',
          'dialog.noUndo.body': 'Nada para desfazer.',
          'dialog.noRedo.title': 'Refazer',
          'dialog.noRedo.body': 'Nada para refazer.',
          'dialog.rename.title': 'Renomear',
          'dialog.rename.desc': 'Digite um novo nome.',
          'dialog.rename.confirm': 'Renomear',
          'dialog.loginEmpty.title': 'Digite seu nome',
          'dialog.loginEmpty.body': 'Digite um nome para continuar.',
          'dialog.trash.empty': 'A lixeira está vazia.',
          'dialog.trash.restore': 'Restaurar',
          'dialog.trash.restoreAll': 'Restaurar tudo',
          'dialog.trash.emptyAction': 'Esvaziar Lixeira',

          'wallpaper.classic': 'Teal clássico',
          'wallpaper.bliss': 'Nascer do Sol',
          'wallpaper.clouds': 'Nuvens',
          'wallpaper.diev': 'Grid',
          'wallpaper.tot': 'Tot (Rosa)',
          'wallpaper.matrix': 'Matrix',
          'wallpaper.xp98bliss': 'XP Bliss 98',

          'music.title': 'BLISS — Música',
          'music.subtitle': 'Ouça em todas as plataformas:',
          'music.tip': 'Música é uma coisa linda, não é?',

          'clothes.title': 'BLISS — Roupas',
          'clothes.subtitle': 'Últimos do Instagram.',
          'clothes.loading': 'Carregando…',
          'clothes.unavailable': 'Não foi possível carregar agora.',
          'clothes.thumbAlt': 'Instagram da BLISS',

          'about.title': 'Sobre',
          'about.p1': 'BLISS é um projeto que visa unir artistas independentes, estranhos e únicos,',
          'about.p2': 'apoiando toda forma de arte e autoexpressão.',
          'about.p3': 'Contra o sistema e os dogmas criados por humanos,',
          'about.p4': 'nós somos nossos próprios DEUSES.',
          'about.p5': 'Não existem regras.',
          'about.p6': 'Nós criamos o nosso próprio mundo de dentro para fora.',
          'about.footer': 'Design by DIEV',

          'contact.title': 'Contato',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Página oficial do DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Tocando:',
          'player.play': 'Play',
          'player.pause': 'Pausar',
          'player.prev': 'Anterior',
          'player.next': 'Próxima',
          'player.vol': 'Vol',
          'player.shuffle': 'Aleatório',
          'player.repeat': 'Repetir',
          'player.repeat.off': 'Desligado',
          'player.repeat.one': 'Uma',
          'player.repeat.all': 'Todas',
          'player.loading': 'Carregando músicas…',
          'player.notfound': 'Sem músicas ainda.',
          'player.autoplay': 'O autoplay pode ser bloqueado. Se não tocar, aperte Play.',
          'player.addSongs': 'Adicionar músicas…',
          'player.reimport': 'Reimportar arquivos',
          'player.reimportHint': 'Reimporte os arquivos para restaurar sua playlist.',
          'player.drop': 'Solte arquivos de áudio aqui',
          'player.flacUnsupported': 'Seu navegador não suporta FLAC. Use MP3/WAV/OGG ou outro navegador.',
          'dialog.playerHowTo.title': 'Como adicionar músicas',
          'dialog.playerHowTo.body': 'Adicione músicas arrastando arquivos de áudio para a janela do player, ou clique em Adicionar músicas… para escolher arquivos.'
        }
      };

      function t(key){
        return (I18N[state.lang] && I18N[state.lang][key]) || (I18N.en && I18N.en[key]) || key;
      }

      function applyI18nTo(root){
        // text nodes
        $$('[data-i18n]', root).forEach(el => {
          const key = el.getAttribute('data-i18n');
          if(key) el.textContent = t(key);
        });
        // titles
        $$('[data-i18n-title]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-title');
          if(key) el.setAttribute('title', t(key));
        });
        // aria labels
        $$('[data-i18n-aria]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-aria');
          if(key) el.setAttribute('aria-label', t(key));
        });
        // placeholders
        $$('[data-i18n-placeholder]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-placeholder');
          if(key) el.setAttribute('placeholder', t(key));
        });
        updateWallpaperButtons(root);
        updateAnimationButtons(root);
        updateDarkModeButtons(root);
        updateTitlebarButtons(root);
        updateThemeButtons(root);
        updateThemeThumbs(root);
        updateRetroGlowButtons(root);
      }

      function applyI18n(){
        applyI18nTo(document);

        // Update language button label
        const lb = $('#langBtn');
        if(lb) lb.textContent = state.lang.toUpperCase();

        // Re-render desktop UI labels
        renderIcons();
        renderStartMenu();
        updateOpenWindowTitles();
        renderTaskButtons();
        renderCtxMenu();
        updateSnakeUI();
        mpRender();
      }

      function setLang(lang){
        state.lang = (lang === 'pt') ? 'pt' : 'en';
        localStorage.setItem('bliss98_lang', state.lang);
        applyI18n();
      }

      function toggleLang(){
        setLang(state.lang === 'en' ? 'pt' : 'en');
      }

      function getWindowId(winEl){
        if(!winEl || !winEl.id) return null;
        return winEl.id.replace('win_', '');
      }

      function renderMenuItems(items){
        return items.map(item => {
          if(item.type === 'sep') return '<div class="menu-sep"></div>';
          const label = t(item.labelKey);
          const checkMark = item.type === 'radio' ? '•' : '✓';
          const check = item.checked ? checkMark : '';
          const left = `<span class="menu-left"><span class="menu-check">${check}</span><span>${label}</span></span>`;
          if(item.type === 'submenu'){
            return `
              <div class="menu-item has-sub" tabindex="0">
                ${left}
                <span class="menu-right">▶</span>
                <div class="menu-sub">
                  ${renderMenuItems(item.items)}
                </div>
              </div>
            `;
          }
          const actionAttr = item.action ? `data-menu-action="${item.action}"` : '';
          const right = item.right ? `<span class="menu-right">${item.right}</span>` : '<span class="menu-right"></span>';
          return `
            <button class="menu-item" type="button" ${actionAttr}>
              ${left}
              ${right}
            </button>
          `;
        }).join('');
      }

      function getMenuItems(appId, menuKey){
        const items = [];
        const addSep = () => { if(items.length && items[items.length-1].type !== 'sep') items.push({ type:'sep' }); };

        if(menuKey === 'file'){
          items.push({ labelKey:'menu.file.newWindow', action:'global:newWindow' });
          addSep();
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.openLink', action:'music:openLink' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.openTrack', action:'player:openTrack' });
            items.push({ labelKey:'menu.player.reload', action:'player:reload' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.openLookbook', action:'clothes:openLookbook' });
            items.push({ labelKey:'menu.clothes.shop', action:'clothes:shop' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.openPress', action:'diev:openPress' });
            items.push({ labelKey:'menu.diev.copyBio', action:'diev:copyBio' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copyEmail', action:'contact:copyEmail' });
            items.push({ labelKey:'menu.contact.openInstagram', action:'contact:openInstagram' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.apply', action:'settings:apply' });
            items.push({ labelKey:'menu.settings.reset', action:'settings:reset' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.openGallery', action:'art:openGallery' });
            items.push({ labelKey:'menu.art.saveImage', action:'art:saveImage' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.openFolder', action:'games:openFolder' });
            items.push({ labelKey:'menu.games.download', action:'games:download' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.openChannel', action:'videos:openChannel' });
            items.push({ labelKey:'menu.videos.copyLink', action:'videos:copyLink' });
          }
          addSep();
          items.push({ labelKey:'menu.file.close', action:'global:close' });
          items.push({ labelKey:'menu.file.logoff', action:'global:logoff' });
        }

        if(menuKey === 'edit'){
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.selectAll', action:'music:selectAll' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
            items.push({ labelKey:'menu.music.clearSelection', action:'music:clearSelection' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.selectAll', action:'player:selectAll' });
            items.push({ labelKey:'menu.player.copyName', action:'player:copyName' });
            items.push({ labelKey:'menu.player.clearSelection', action:'player:clearSelection' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.copy', action:'clothes:copy' });
            items.push({ labelKey:'menu.clothes.selectAll', action:'clothes:selectAll' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.copy', action:'diev:copy' });
            items.push({ labelKey:'menu.diev.selectAll', action:'diev:selectAll' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copy', action:'contact:copy' });
            items.push({ labelKey:'menu.contact.selectAll', action:'contact:selectAll' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.undo', action:'settings:undo' });
            items.push({ labelKey:'menu.settings.redo', action:'settings:redo' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.copy', action:'art:copy' });
            items.push({ labelKey:'menu.art.selectAll', action:'art:selectAll' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.copy', action:'games:copy' });
            items.push({ labelKey:'menu.games.selectAll', action:'games:selectAll' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.copy', action:'videos:copy' });
            items.push({ labelKey:'menu.videos.selectAll', action:'videos:selectAll' });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.copy', action:'about:copy' });
            items.push({ labelKey:'menu.about.selectAll', action:'about:selectAll' });
          }
        }

        if(menuKey === 'view'){
          if(appId === 'music'){
            items.push({
              type:'submenu',
              labelKey:'menu.music.tileSize',
              items:[
                { labelKey:'menu.music.tileSize.small', action:'music:tileSmall', type:'radio', checked: state.music.tileSize === 'small' },
                { labelKey:'menu.music.tileSize.large', action:'music:tileLarge', type:'radio', checked: state.music.tileSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.music.openNewTab', action:'music:toggleNewTab', type:'checkbox', checked: state.music.openNewTab });
            items.push({ labelKey:'menu.music.showIcons', action:'music:toggleIcons', type:'checkbox', checked: state.music.showIcons });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.shuffle', action:'player:toggleShuffle', type:'checkbox', checked: state.mediaplayer.shuffle });
            items.push({
              type:'submenu',
              labelKey:'menu.player.repeat',
              items:[
                { labelKey:'menu.player.repeat.off', action:'player:repeatOff', type:'radio', checked: state.mediaplayer.repeat === 'off' },
                { labelKey:'menu.player.repeat.one', action:'player:repeatOne', type:'radio', checked: state.mediaplayer.repeat === 'one' },
                { labelKey:'menu.player.repeat.all', action:'player:repeatAll', type:'radio', checked: state.mediaplayer.repeat === 'all' }
              ]
            });
            items.push({ labelKey:'menu.player.showPlaylist', action:'player:togglePlaylist', type:'checkbox', checked: state.mediaplayer.showPlaylist });
            items.push({ labelKey:'menu.player.compact', action:'player:toggleCompact', type:'checkbox', checked: state.mediaplayer.compact });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.viewGrid', action:'clothes:viewGrid' });
            items.push({
              type:'submenu',
              labelKey:'menu.clothes.sort',
              items:[
                { labelKey:'menu.clothes.sort.new', action:'clothes:sortNew' },
                { labelKey:'menu.clothes.sort.popular', action:'clothes:sortPopular' }
              ]
            });
            items.push({ labelKey:'menu.clothes.preview', action:'clothes:togglePreview', type:'checkbox', checked: false });
          }
          if(appId === 'diev'){
            items.push({
              type:'submenu',
              labelKey:'menu.diev.textSize',
              items:[
                { labelKey:'menu.diev.textSize.small', action:'diev:textSmall', type:'radio', checked: state.diev.textSize === 'small' },
                { labelKey:'menu.diev.textSize.normal', action:'diev:textNormal', type:'radio', checked: state.diev.textSize === 'normal' },
                { labelKey:'menu.diev.textSize.large', action:'diev:textLarge', type:'radio', checked: state.diev.textSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.diev.highContrast', action:'diev:toggleContrast', type:'checkbox', checked: state.diev.highContrast });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.showQr', action:'contact:showQr' });
            items.push({ labelKey:'menu.contact.compact', action:'contact:compact' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.fullscreen', action:'settings:fullscreen', type:'checkbox', checked: !!document.fullscreenElement });
            items.push({ labelKey:'menu.settings.scanlines', action:'settings:scanlines', type:'checkbox', checked: state.settings.scanlines });
            items.push({ labelKey:'menu.settings.wallpaper', action:'settings:wallpaper' });
          }
          if(appId === 'art'){
            items.push({
              type:'submenu',
              labelKey:'menu.art.zoom',
              items:[
                { labelKey:'menu.art.zoom.50', action:'art:zoom50', type:'radio', checked: state.art.zoom === 50 },
                { labelKey:'menu.art.zoom.100', action:'art:zoom100', type:'radio', checked: state.art.zoom === 100 },
                { labelKey:'menu.art.zoom.200', action:'art:zoom200', type:'radio', checked: state.art.zoom === 200 }
              ]
            });
            items.push({ labelKey:'menu.art.slideshow', action:'art:slideshow' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.grid', action:'games:grid' });
            items.push({
              type:'submenu',
              labelKey:'menu.games.sort',
              items:[
                { labelKey:'menu.games.sort.new', action:'games:sortNew' },
                { labelKey:'menu.games.sort.favorite', action:'games:sortFavorite' }
              ]
            });
          }
          if(appId === 'videos'){
            items.push({
              type:'submenu',
              labelKey:'menu.videos.thumbSize',
              items:[
                { labelKey:'menu.videos.thumbSize.small', action:'videos:thumbSmall', type:'radio', checked: state.videos.thumbSize === 'small' },
                { labelKey:'menu.videos.thumbSize.large', action:'videos:thumbLarge', type:'radio', checked: state.videos.thumbSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.videos.openNewTab', action:'videos:toggleNewTab', type:'checkbox', checked: state.videos.openNewTab });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.version', action:'about:version' });
            items.push({ labelKey:'menu.about.credits', action:'about:credits' });
          }
        }

        if(menuKey === 'help'){
          if(appId === 'music') items.push({ labelKey:'menu.music.where', action:'music:where' });
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.tips', action:'player:tips' });
            items.push({ labelKey:'menu.player.howto', action:'player:howto' });
          }
          if(appId === 'clothes') items.push({ labelKey:'menu.clothes.sizing', action:'clothes:sizing' });
          if(appId === 'diev') items.push({ labelKey:'menu.diev.links', action:'diev:links' });
          if(appId === 'contact') items.push({ labelKey:'menu.contact.support', action:'contact:support' });
          if(appId === 'settings') items.push({ labelKey:'menu.settings.what', action:'settings:what' });
          if(appId === 'art') items.push({ labelKey:'menu.art.credits', action:'art:credits' });
          if(appId === 'games') items.push({ labelKey:'menu.games.requirements', action:'games:requirements' });
          if(appId === 'videos') items.push({ labelKey:'menu.videos.tips', action:'videos:tips' });
          if(appId === 'about') items.push({ labelKey:'menu.about.controls', action:'about:controls' });

          addSep();
          items.push({ labelKey:'menu.help.controls', action:'global:controls' });
          items.push({ labelKey:'menu.help.about', action:'global:about' });
        }

        return items;
      }

      function openWindowMenu(winEl, menuKey, anchorEl){
        if(!winEl) return;
        const drop = winEl.querySelector('.menu-drop');
        const appId = getWindowId(winEl);
        if(!drop || !appId) return;

        if(state.menuOpen && state.menuOpen.winId !== appId){
          closeWindowMenu();
        }
        const items = getMenuItems(appId, menuKey);
        if(items.length === 0){
          closeWindowMenu();
          return;
        }
        drop.innerHTML = renderMenuItems(items);
        drop.classList.remove('hidden');

        const winRect = winEl.getBoundingClientRect();
        const anchorRect = anchorEl.getBoundingClientRect();
        drop.style.top = (anchorRect.bottom - winRect.top) + 'px';
        drop.style.left = (anchorRect.left - winRect.left) + 'px';

        winEl.querySelectorAll('.menubar span').forEach(span => {
          span.classList.toggle('active', span.dataset.menu === menuKey);
        });

        state.menuOpen = { winId: appId, menuKey };
      }

      function closeWindowMenu(){
        if(!state.menuOpen) return;
        const winEl = document.getElementById(`win_${state.menuOpen.winId}`);
        if(winEl){
          const drop = winEl.querySelector('.menu-drop');
          if(drop) drop.classList.add('hidden');
          winEl.querySelectorAll('.menubar span').forEach(span => span.classList.remove('active'));
        }
        state.menuOpen = null;
      }

      const modalState = { onConfirm: null };

      function showModal({ title, body, actions }){
        const modal = $('#modal');
        if(!modal) return;
        $('#modalTitle').textContent = title || '';
        $('#modalBody').innerHTML = body || '';
        const actionsEl = $('#modalActions');
        actionsEl.innerHTML = (actions || []).map((a, idx) => `
          <button class="btn bevel" type="button" data-modal-action="${a.action}" style="${a.primary ? 'font-weight:700;' : ''}">${a.label}</button>
        `).join('');
        modal.classList.remove('hidden');
        const firstBtn = actionsEl.querySelector('button');
        if(firstBtn) firstBtn.focus();
      }

      function closeModal(){
        const modal = $('#modal');
        if(!modal) return;
        modal.classList.add('hidden');
        $('#modalBody').innerHTML = '';
        $('#modalActions').innerHTML = '';
        modalState.onConfirm = null;
      }

      function showMessage(titleKey, bodyKey){
        showModal({
          title: t(titleKey),
          body: `<p style="margin:0;">${t(bodyKey)}</p>`,
          actions: [{ label: t('common.ok'), action: 'close', primary: true }]
        });
      }

      function showSelectDialog({ titleKey, descKey, options, confirmKey, onConfirm, selected }){
        const opts = options.map(o => {
          const sel = (selected !== undefined && String(selected) === String(o.value)) ? ' selected' : '';
          return `<option value="${o.value}"${sel}>${o.label}</option>`;
        }).join('');
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <select id="modalSelect" class="bevel-in" style="width:100%; height:26px;">${opts}</select>
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      function showInputDialog({ titleKey, descKey, value, confirmKey, onConfirm }){
        const safeValue = value ? String(value).replace(/"/g, '&quot;') : '';
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <input id="modalInput" class="bevel-in" type="text" value="${safeValue}" style="width:100%; height:26px;" />
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      async function copyText(text){
        if(!text) return false;
        try{
          await navigator.clipboard.writeText(text);
          return true;
        } catch {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand('copy');
          ta.remove();
          return ok;
        }
      }

      function selectAllInWindow(winId){
        const winEl = document.getElementById(`win_${winId}`);
        if(!winEl) return;
        const content = winEl.querySelector('.content');
        if(!content) return;
        const range = document.createRange();
        range.selectNodeContents(content);
        const sel = window.getSelection();
        if(sel){
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }

      function getSelectedText(){
        const sel = window.getSelection();
        return sel ? String(sel.toString()) : '';
      }

      function copySelectedTextOrWarn(){
        const text = getSelectedText();
        if(!text){
          showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
          return;
        }
        copyText(text).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
      }

      function openLink(url, appId){
        if(!url) return;
        if(appId === 'music'){
          if(state.music.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        if(appId === 'videos'){
          if(state.videos.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        window.open(url, '_blank', 'noreferrer');
      }

      function handleMenuAction(action){
        const winId = state.menuOpen ? state.menuOpen.winId : null;
        if(!action) return;

        if(action === 'global:newWindow'){
          const options = APPS.filter(a => a.showInStart !== false).map(a => ({ value: a.id, label: t(a.titleKey) }));
          showSelectDialog({
            titleKey: 'dialog.newWindow.title',
            descKey: 'dialog.newWindow.desc',
            options,
            confirmKey: 'dialog.newWindow.open',
            onConfirm: (val)=>{ openApp(val); }
          });
          return;
        }
        if(action === 'global:close' && winId){
          closeApp(winId);
          return;
        }
        if(action === 'global:logoff'){
          doLogoff();
          return;
        }
        if(action === 'global:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'global:about'){
          openApp('about');
          return;
        }

        if(action === 'music:openLink'){
          const options = MUSIC_LINKS.map(l => ({ value: l.id, label: l.label }));
          const selectedId = Array.from(state.music.selected)[0];
          showSelectDialog({
            titleKey: 'dialog.openLink.title',
            descKey: 'dialog.openLink.desc',
            options,
            confirmKey: 'dialog.openLink.open',
            selected: selectedId,
            onConfirm: (val)=>{
              const link = MUSIC_LINKS.find(l => l.id === val);
              if(link) openLink(link.url, 'music');
            }
          });
          return;
        }
        if(action === 'music:copyLink'){
          const ids = Array.from(state.music.selected);
          const selected = ids.length ? ids : [];
          if(selected.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const urls = selected.map(id => (MUSIC_LINKS.find(l => l.id === id) || {}).url).filter(Boolean);
          copyText(urls.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'music:selectAll'){
          state.music.selected = new Set(MUSIC_LINKS.map(l => l.id));
          applyMusicState();
          return;
        }
        if(action === 'music:clearSelection'){
          state.music.selected = new Set();
          applyMusicState();
          return;
        }
        if(action === 'music:tileSmall'){
          state.music.tileSize = 'small';
          applyMusicState();
          return;
        }
        if(action === 'music:tileLarge'){
          state.music.tileSize = 'large';
          applyMusicState();
          return;
        }
        if(action === 'music:toggleNewTab'){
          state.music.openNewTab = !state.music.openNewTab;
          return;
        }
        if(action === 'music:toggleIcons'){
          state.music.showIcons = !state.music.showIcons;
          applyMusicState();
          return;
        }
        if(action === 'music:where'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'player:openTrack'){
          const options = mp.tracks.map((tr, i) => ({ value: String(i), label: tr.title }));
          if(options.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          showSelectDialog({
            titleKey: 'dialog.openTrack.title',
            descKey: 'dialog.openTrack.desc',
            options,
            confirmKey: 'dialog.openTrack.open',
            selected: mp.idx,
            onConfirm: (val)=>{
              const idx = Number(val);
              state.mediaplayer.selected = new Set([idx]);
              mpSetTrack(idx);
              mpPlay();
            }
          });
          return;
        }
        if(action === 'player:reload'){
          mpLoadTracks();
          return;
        }
        if(action === 'player:selectAll'){
          state.mediaplayer.selected = new Set(mp.tracks.map((_, i) => i));
          mpRender();
          return;
        }
        if(action === 'player:copyName'){
          const ids = Array.from(state.mediaplayer.selected);
          if(ids.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const names = ids.map(i => (mp.tracks[i] ? mp.tracks[i].title : '')).filter(Boolean);
          copyText(names.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'player:clearSelection'){
          state.mediaplayer.selected = new Set();
          mpRender();
          return;
        }
        if(action === 'player:toggleShuffle'){
          state.mediaplayer.shuffle = !state.mediaplayer.shuffle;
          mpRender();
          return;
        }
        if(action === 'player:repeatOff'){
          state.mediaplayer.repeat = 'off';
          mpRender();
          return;
        }
        if(action === 'player:repeatOne'){
          state.mediaplayer.repeat = 'one';
          mpRender();
          return;
        }
        if(action === 'player:repeatAll'){
          state.mediaplayer.repeat = 'all';
          mpRender();
          return;
        }
        if(action === 'player:togglePlaylist'){
          state.mediaplayer.showPlaylist = !state.mediaplayer.showPlaylist;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:toggleCompact'){
          state.mediaplayer.compact = !state.mediaplayer.compact;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }
        if(action === 'player:howto'){
          showMessage('dialog.playerHowTo.title', 'dialog.playerHowTo.body');
          return;
        }

        if(action === 'clothes:openLookbook' || action === 'clothes:shop' || action === 'clothes:sizing' || action === 'clothes:viewGrid' || action === 'clothes:sortNew' || action === 'clothes:sortPopular' || action === 'clothes:togglePreview'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'clothes:copy' || action === 'clothes:selectAll'){
          if(action === 'clothes:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'clothes:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'diev:openPress' || action === 'diev:copyBio'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'diev:copy' || action === 'diev:selectAll'){
          if(action === 'diev:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'diev:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'diev:textSmall'){
          state.diev.textSize = 'small';
          applyDievState();
          return;
        }
        if(action === 'diev:textNormal'){
          state.diev.textSize = 'normal';
          applyDievState();
          return;
        }
        if(action === 'diev:textLarge'){
          state.diev.textSize = 'large';
          applyDievState();
          return;
        }
        if(action === 'diev:toggleContrast'){
          state.diev.highContrast = !state.diev.highContrast;
          applyDievState();
          return;
        }
        if(action === 'diev:links'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'contact:support'){
          showMessage('dialog.support.title', 'dialog.support.body');
          return;
        }
        if(action === 'contact:copyEmail' || action === 'contact:openInstagram' || action === 'contact:showQr' || action === 'contact:compact'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'contact:copy' || action === 'contact:selectAll'){
          if(action === 'contact:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'contact:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'settings:apply'){
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:reset'){
          setLang('en');
          applyWallpaper('classic');
          setAnimations(true);
          state.settings.scanlines = false;
          applyScanlines();
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:undo'){
          showMessage('dialog.noUndo.title', 'dialog.noUndo.body');
          return;
        }
        if(action === 'settings:redo'){
          showMessage('dialog.noRedo.title', 'dialog.noRedo.body');
          return;
        }
        if(action === 'settings:fullscreen'){
          if(!document.fullscreenElement){
            document.documentElement.requestFullscreen().catch(()=>{});
          } else {
            document.exitFullscreen().catch(()=>{});
          }
          return;
        }
        if(action === 'settings:scanlines'){
          state.settings.scanlines = !state.settings.scanlines;
          applyScanlines();
          return;
        }
        if(action === 'settings:wallpaper'){
          openSettingsAndTab('appearance', 'settingsWallpaper');
          return;
        }
        if(action === 'settings:what'){
          showMessage('dialog.settingsWhat.title', 'dialog.settingsWhat.body');
          return;
        }

        if(action === 'art:openGallery' || action === 'art:saveImage' || action === 'art:slideshow' || action === 'art:credits'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'art:copy' || action === 'art:selectAll'){
          if(action === 'art:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'art:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'art:zoom50'){
          state.art.zoom = 50;
          applyArtState();
          return;
        }
        if(action === 'art:zoom100'){
          state.art.zoom = 100;
          applyArtState();
          return;
        }
        if(action === 'art:zoom200'){
          state.art.zoom = 200;
          applyArtState();
          return;
        }

        if(action === 'games:openFolder' || action === 'games:download' || action === 'games:grid' || action === 'games:sortNew' || action === 'games:sortFavorite' || action === 'games:requirements'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'games:copy' || action === 'games:selectAll'){
          if(action === 'games:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'games:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'videos:openChannel'){
          openLink(VIDEO_CHANNEL_URL, 'videos');
          return;
        }
        if(action === 'videos:copyLink'){
          copyText(VIDEO_CHANNEL_URL).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
          return;
        }
        if(action === 'videos:copy' || action === 'videos:selectAll'){
          if(action === 'videos:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'videos:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'videos:thumbSmall'){
          state.videos.thumbSize = 'small';
          return;
        }
        if(action === 'videos:thumbLarge'){
          state.videos.thumbSize = 'large';
          return;
        }
        if(action === 'videos:toggleNewTab'){
          state.videos.openNewTab = !state.videos.openNewTab;
          return;
        }
        if(action === 'videos:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }

        if(action === 'about:version'){
          showMessage('dialog.version.title', 'dialog.version.body');
          return;
        }
        if(action === 'about:credits'){
          showMessage('dialog.credits.title', 'dialog.credits.body');
          return;
        }
        if(action === 'about:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'about:copy' || action === 'about:selectAll'){
          if(action === 'about:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'about:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
      }

      function updateOpenWindowTitles(){
        // Update stored titles and the DOM titlebars
        state.windows.forEach((w, id) => {
          const app = APPS.find(a => a.id === id);
          const title = app ? t(app.titleKey) : (w.titleKey ? t(w.titleKey) : id);
          w.title = title;
          const winEl = document.getElementById(`win_${id}`);
          if(winEl){
            const titleEl = winEl.querySelector('.title-left strong');
            if(titleEl) titleEl.textContent = title;

            const c = winEl.querySelector('.content');
            if(c && CONTENT[id]) {
              c.innerHTML = CONTENT[id]();
            }
            applyI18nTo(winEl);
            applyWindowState(winEl, id);

            const minCtl = winEl.querySelector('[data-action="min"]');
            const maxCtl = winEl.querySelector('[data-action="max"]');
            const closeCtl = winEl.querySelector('[data-action="close"]');
            const resizeCtl = winEl.querySelector('.resize');
            if(minCtl) minCtl.title = t('win.minimize');
            if(maxCtl) maxCtl.title = t('win.maximize');
            if(closeCtl) closeCtl.title = t('win.close');
            if(resizeCtl) resizeCtl.title = t('win.resize');
            const status = winEl.querySelector('.statusbar');
            if(status){
              let center = status.querySelector('.status-center');
              if(!center){
                center = document.createElement('span');
                center.className = 'status-center';
                center.setAttribute('data-i18n', 'about.footer');
                status.insertBefore(center, status.lastElementChild);
              }
              center.textContent = t('about.footer');
            }

          if(id === 'mediaplayer') {
            setTimeout(mpInitInWindow, 0);
          }
          if(id === 'trash'){
            updateTrashIconUI();
          }
          if(id === 'poetry'){
            renderPoetryWindow();
          }
          if(id === 'clothes'){
            initClothesWindow(winEl);
          }
          if(id === 'settings'){
            initSettingsTabs(winEl);
          }
          if(id === 'videos'){
            initVideosWindow(winEl);
          }
        }
      });
      }

      function iconSVG(type){
        const common = `viewBox="0 0 16 16" class="pixel" aria-hidden="true"`;
        switch(type){
          case 'folder':
            return `<svg ${common}><rect width="16" height="16" fill="none"/><path d="M1 4h6l1 2h7v8H1z" fill="#ffcc66" stroke="#000" stroke-width="1"/><path d="M1 4h6l1 2H1z" fill="#ffd88a" stroke="#000" stroke-width="1"/></svg>`;
          case 'music':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><path d="M10 3v7.5a2 2 0 1 1-1-1.7V5h-3V3z" fill="#000080"/></svg>`;
          case 'art':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="3" y="3" width="10" height="10" fill="#c0c0c0" stroke="#000"/><path d="M4 11l2-2 2 2 2-3 3 3" stroke="#000080" stroke-width="1" fill="none"/></svg>`;
          case 'game':
            return `<svg ${common}><rect x="2" y="5" width="12" height="7" rx="2" fill="#c0c0c0" stroke="#000"/><rect x="5" y="7" width="1" height="3" fill="#000"/><rect x="4" y="8" width="3" height="1" fill="#000"/><circle cx="11" cy="8" r="1" fill="#ff3366"/><circle cx="12.8" cy="9.5" r="1" fill="#66ccff"/></svg>`;
          case 'video':
            return `<svg ${common}><rect x="1" y="3" width="12" height="10" fill="#fff" stroke="#000"/><path d="M13 6l2-1v6l-2-1z" fill="#000"/></svg>`;
          case 'info':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="5" r="1" fill="#000"/><rect x="7" y="7" width="2" height="6" fill="#000080"/></svg>`;
          case 'mail':
            return `<svg ${common}><rect x="1" y="3" width="14" height="10" fill="#fff" stroke="#000"/><path d="M1 4l7 5 7-5" fill="none" stroke="#000080" stroke-width="1"/></svg>`;
          case 'user':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="6" r="2" fill="#000080"/><path d="M4 13c1-2 7-2 8 0" stroke="#000080" fill="none"/></svg>`;
          case 'settings':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="8" r="3" fill="#c0c0c0" stroke="#000"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.5 3.5l1.4 1.4M11.1 11.1l1.4 1.4M12.5 3.5l-1.4 1.4M4.9 11.1l-1.4 1.4" stroke="#000080"/></svg>`;
          case 'trash':
            return `<svg ${common}><rect x="1" y="3" width="14" height="12" fill="#fff" stroke="#000"/><rect x="4" y="1" width="8" height="2" fill="#c0c0c0" stroke="#000"/><path d="M5 5v8M8 5v8M11 5v8" stroke="#000080"/></svg>`;
          default:
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="4" y="4" width="8" height="8" fill="#000080"/></svg>`;
        }
      }

      const APPS = [
        { id:'trash', titleKey:'app.trash', icon:'trash', iconFile:getTrashIconFile, showInStart:false },
        { id:'poetry', titleKey:'app.poetry', icon:'file', iconFile:'/assets/icons/poetry.png' },
        { id:'clothes', titleKey:'app.clothes', icon:'folder', iconFile:'/assets/icons/Clothes.png' },
        { id:'music', titleKey:'app.music', icon:'music', iconFile:'/assets/icons/Music.png' },
        { id:'mediaplayer', titleKey:'app.mediaplayer', icon:'music', iconFile:'/assets/icons/BLISS%20mediaplayer.png' },
        { id:'art', titleKey:'app.art', icon:'art', iconFile:'/assets/icons/Art.png' },
        { id:'games', titleKey:'app.games', icon:'game', iconFile:'/assets/icons/Games.png' },
        { id:'videos', titleKey:'app.videos', icon:'video', iconFile:'/assets/icons/Videos.png' },
        { id:'about', titleKey:'app.about', icon:'info', iconFile:'/assets/icons/About.png' },
        { id:'contact', titleKey:'app.contact', icon:'mail', iconFile:'/assets/icons/Contact.png' },
        { id:'diev', titleKey:'app.diev', icon:'user', iconFile:'/assets/icons/DIEV.png' },
        { id:'settings', titleKey:'app.settings', icon:'settings', iconFile:'/assets/icons/Settings.png' },
      ];

      const MUSIC_LINKS = [
        {
          id: 'spotify',
          label: 'Spotify',
          url: 'https://open.spotify.com/artist/6bjnHKF2yjUlKyYD15cNGq',
          icon: '/assets/icons/spotify.png'
        },
        {
          id: 'youtubemusic',
          label: 'YouTube Music',
          url: 'https://music.youtube.com/channel/UCSjAU7hceaYUQPZml7HUFgA',
          icon: '/assets/icons/youtubemusic.png'
        },
        {
          id: 'applemusic',
          label: 'Apple Music',
          url: 'https://music.apple.com/us/artist/diev/1586153318',
          icon: '/assets/icons/applemusic.png'
        },
        {
          id: 'amazonmusic',
          label: 'Amazon Music',
          url: 'https://music.amazon.com.br/artists/B00F5I7CC6/diev',
          icon: '/assets/icons/amazonmusic.png'
        },
        {
          id: 'soundcloud',
          label: 'SoundCloud',
          url: 'https://soundcloud.com/die_v/tracks',
          icon: '/assets/icons/soundcloud.png'
        },
        {
          id: 'deezer',
          label: 'Deezer',
          url: 'https://www.deezer.com/en/artist/5170963',
          icon: '/assets/icons/deezer.png'
        }
      ];

      // Update the fallback list with real Instagram thumbnails when needed.
      const CLOTHES_FALLBACK = [
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' }
      ];

      const VIDEO_CHANNEL_HANDLE = 'DIEVBLISS';
      const VIDEO_CHANNEL_URL = 'https://www.youtube.com/@DIEVBLISS';

      // Add new poems here. Always provide body_en and body_pt.
      const POEMS = [
        {
          id: 'evolve',
          title: 'Evolve',
          body_en: `To evolve is to change
More than it is to progress
The human race is in its teenager phase
We break everything
And apologize for nothing

And the ones closer to the truth
Are the ones who say, “I know nothing”

But it’s different when it comes from the temple
And when it comes from the streets
Because insanity is a common trait
Associated with unearned wisdom`,
          body_pt: `Evoluir é mudar
Mais do que é progredir
A raça humana vive sua fase adolescente
Quebramos tudo
E não pedimos desculpas por nada

E os que estão mais perto da verdade
São os que dizem: “Eu nada sei”

Mas é diferente quando vem do templo
E quando vem das ruas
Porque a insanidade é um traço comum
Associado à sabedoria não conquistada`
        },
        {
          id: 'tedio',
          title: 'Tedio',
          body_en: `Boredom

The walls bore me
The floor bores me
The blue sky with the bright sun bores me
Sometimes I think I understand
But the eternal boredom ends up taking me
I think about having a beer
Maybe that will cheer me up
The idea excites more than the act
After the first sip
I feel only boredom
They told me that growing old was good
Knowledge
Maturity
All of that brought me boredom
Now I sit doing nothing inside buildings
Waiting for the invitation that changes
The novelty that arrives
While I carry a cigarette
Around the boredom
In the idea I am happy
In the idea I am free and excited
In the act I find myself dull
In this eternal hell of boredom`,
          body_pt: `Tedio

As paredes me entediam
O chão me entedia
O céu azul com o sol brilhando me entedia
As vezes acho que entendo
Mas o tédio eterno acaba me tomando
Penso em tomar uma cerveja
Talvez isso me anime
A ideia anima mais que o ato
Depois do primeiro gole
Sinto apenas o tédio
Me disseram que envelhecer era bom
Conhecimento
Amadurecimento
Tudo isso me trouxe tédio
Agora fico sem fazer nada dentro de prédios
Esperando o convite que mude
A novidade que traga
Enquanto trago um cigarro
Em volta do tédio
Na ideia sou feliz
Na ideia sou livre e animado
No ato me encontro chato
Nesse inferno eterno tédio`
        },
        {
          id: 'la-vai-ela',
          title: 'La vai ela',
          body_en: `There she goes

There she goes to the phone
There I go to the music and a distant stare
There we go, arguing
There we go, hating and loving each other
She drinks from my sip
We share the same visions
We argue hard about the differences
We fight
We love
We look at ourselves
Who are we
Two lost children
Two angry children
In the end we love each other
As always, we love each other`,
          body_pt: `La vai ela

La vai ela pro celular
La vai eu pra musica e olhar distante
La vamos nos discutindo
La vamos nos se odiando e se amando
Ela bebe do meu gole
Dividimos mesmas visões
Discutimos forte as diferenças
Brigamos
Nos amamos
No olhamos
Quem somo nos
Duas crianças perdidas
Duas crianças bravas
No fim nos amamos
Como sempre nos amamos`
        },
        {
          id: 'falta-de-palavras',
          title: 'A falta de palavras',
          body_en: `The lack of words
Is the poet’s suicide
And she wanted me to try harder
To be with her
Cooking dinner
And I wanted to be far away`,
          body_pt: `A falta de palavras
É o suicido do poeta
E ela queria que eu me esforçasse mais
Pra estar com ela
Cozinhando a janta
E eu querendo estar longe`
        },
        {
          id: 'no-fim-foi-isso',
          title: 'No fim foi isso',
          body_en: `In the end, that was it
In the end, that was it
A balancing of egos
One had too much
Another had too little
But it is all right
The scale goes up and down
And in the end, maybe
It levels`,
          body_pt: `No fim foi isso
No fim foi isso
Um balanceamento de egos
Um tinha demais
Outro tinha de menos
Mas esta tudo bem
A balança sobe e desce
E no fim talvez
Nivele`
        },
        {
          id: 'sua-interpretacao',
          title: 'Sua interpretação',
          body_en: `Your interpretation

Why do I feel so much empathy
For the mad?

Me, who considers myself so sane

Did you read this in a sarcastic tone
Or not?`,
          body_pt: `Sua interpretação

Porque tenho tanta empatia
Pelos loucos?

Logo eu que me considero tão são

Você leu isso em tom de sarcasmo
Ou não?`
        },
        {
          id: 'um-sanduiche',
          title: 'Um sanduíche',
          body_en: `A sandwich

When I see lives at the edge of the limit
I realize my life
doesn’t have enough strength
to drive me insane
While I sit at the table
to make a sandwich
My father speaks arrogantly
that no one does anything in this house
except him
So I get up
I pour myself a glass of coke
I observe things
And as always
they remain the same
They seem to never change
But I
I did something
A sandwich`,
          body_pt: `Um sanduíche

Quando vejo vidas a beira do limite
Percebo que a minha vida
não tem forças o suficiente
Para me enlouquecer
Enquanto me sento a mesa
para fazer um sanduíche
Meu pai fala com arrogância
que ninguém faz nada nessa casa
a não ser ele
Ai então me levanto
Me sirvo um copo de coca
Observo as coisas
E como sempre
se mantém iguais
Parecem nunca mudar
Mas eu
Eu fiz algo
Um sanduíche`
        },
        {
          id: 'conversas',
          title: 'Conversas',
          body_en: `Conversations

Conversations are poems
That we throw against the wind
My life looks like yours
I did that to have this
I went through pains like yours
I smiled in some moments
I cried in others
I wish I had made more of these poems`,
          body_pt: `Conversas

Conversas são poesias
Que jogamos contra o vento
Minha vida parece com a sua
Eu fiz aquilo para ter isso
Eu passei por dores como a suas
Eu sorri em momentos
Eu chorei em outros
Queria ter feito mais dessas poesias`
        },
        {
          id: 'a-surpresa-em-sentir-se-livre',
          title: 'A surpresa em sentir-se livre',
          body_en: `The surprise of feeling free

That feeling that catches me by surprise
In a trivial activity
In the midst of total boredom
That feeling of freedom
That arrives between a deep sigh
Arrives unexpectedly
Like the visit
Of an old friend`,
          body_pt: `A surpresa em sentir-se livre

Essa sensação que me pega de surpresa
Em uma atividade banal
Em meio ao tédio total
Essa sensação de liberdade
Que chega entre o suspiro profundo
Chega de surpresa
Como a visita
De um velho amigo`
        },
        {
          id: 'morte-e-compromisso',
          title: 'Morte e compromisso',
          body_en: `Death and commitment

Sometimes I feel taken over
By an idea
An idea that I can die
At any moment
Maybe now...
And that creates a fear
At the same time it creates an excitement
Because it is all so mysterious
How will I die?
What is death like?
And what comes after?
Then time passes
And all of that goes away
And I go back to worrying about life
And about my living problems
And I forget
I forget that death
Death doesn’t care about my commitments`,
          body_pt: `Morte e compromisso

As vezes me sinto tomado
Por uma ideia
Uma ideia de que posso morrer
A qualquer momento
Talvez agora...
E isso gera um medo
ao mesmo tempo que gera uma excitação
Porque é tudo tão misterioso
Como será que vou morrer?
Como será que é a morte?
E oque vem depois?
Ai então o tempo passa
E tudo isso vai embora
E volto a me preocupar com a vida
E com meus problemas de vivo
E me esqueço
Me esqueço de que a morte
A morte não liga pro meus compromissos`
        },
        {
          id: 'quieto',
          title: 'Quieto',
          body_en: `Quiet

All my life I have always found myself
Quiet
In the middle of people always
Quiet
In the middle of family
Quiet
In the middle of friends
Quiet
In the middle of women
Quiet
All my life I have always been very quiet
What should I say?
What difference would it make?
I don’t know
Now I will be silent

2019`,
          body_pt: `Quieto

Minha vida inteira eu sempre me encontrei
Quieto
No meio das pessoas sempre
Quieto
No meio da família
Quieto
No meio dos amigos
Quieto
No meio das mulheres
Quieto
Minha vida inteira eu sempre fui muito quieto
Oque eu deveria dizer?
Que diferença faria?
Não sei
Agora vou me calar

2019`
        },
        {
          id: 'buffalo-branco-extinto',
          title: 'Buffalo branco extinto',
          body_en: `Extinct white buffalo

In the streets people look at me with strangeness
People who spend their whole lives seeing their own reflection
Wherever they go they always see the same
And when something like this appears, they find it strange
A figure so different
So rare
Strange
And interesting
Among the buffalo
I am the extinct white buffalo`,
          body_pt: `Buffalo branco extinto

Nas ruas pessoas me olham com estranheza
Pessoas que passam a vida toda vendo seu próprio reflexo
Aonde quer que vão veem sempre o mesmo
E quando algo assim aparece, estranham
Uma figura tão diferente
Tão rara
Estranha
E Interessante
Em meio aos buffalos
Eu sou o buffalo branco extinto`
        }
      ];

      const CONTENT = {
        about: () => `
          <h2>${t('about.title')}</h2>
          <p>${t('about.p1')}</p>
          <p>${t('about.p2')}</p>
          <p>${t('about.p3')}</p>
          <p>${t('about.p4')}</p>
          <p>${t('about.p5')}</p>
          <p>${t('about.p6')}</p>
        `,
        clothes: () => `
          <h2>${t('clothes.title')}</h2>
          <p class="tiny" data-i18n="clothes.subtitle">${t('clothes.subtitle')}</p>
          <div class="clothes-grid" id="clothesGrid"></div>
          <div class="tiny clothes-status" id="clothesStatus" data-i18n="clothes.loading">${t('clothes.loading')}</div>
        `,
        music: () => `
  <h2>${t('music.title')}</h2>
  <p style="margin:0 0 10px 0;">${t('music.subtitle')}</p>

  <div class="music-grid">
    ${MUSIC_LINKS.map(link => `
      <button class="music-item" type="button" data-music-id="${link.id}" data-music-link="${link.url}">
        <div class="music-icon pixel">
          <img class="pixel" src="${link.icon}" width="48" height="48" alt="${link.label}" style="display:block;" />
        </div>
        <span class="music-label" style="font-weight:700;">${link.label}</span>
      </button>
    `).join('')}
  </div>

  <div class="hr98"></div>
  <div class="tiny">${t('music.tip')}</div>
`,

        mediaplayer: () => `
          <div class="mp-mini bevel">
            <div class="mp-now">
              <span class="tiny" data-i18n="player.now">Now playing:</span>
              <span class="mp-title" id="mpNow">—</span>
            </div>

            <audio id="mpAudio" preload="metadata"></audio>

            <div class="mp-controls">
              <button class="btn bevel" type="button" data-mp-action="prev">⏮ ${t('player.prev')}</button>
              <button class="btn bevel" type="button" data-mp-action="toggle">▶ ${t('player.play')}</button>
              <button class="btn bevel" type="button" data-mp-action="next">⏭ ${t('player.next')}</button>
              <button class="btn bevel" type="button" data-mp-action="shuffle"></button>
              <button class="btn bevel" type="button" data-mp-action="repeat"></button>
            </div>

            <div class="mp-seek-row">
              <input class="mp-seek" id="mpSeek" type="range" min="0" max="1000" step="1" value="0" />
              <div class="mp-time"><span data-mp-current>0:00</span> / <span data-mp-total>--:--</span></div>
            </div>

            <div class="mp-bottom">
              <div class="mp-actions">
                <button class="btn bevel" type="button" data-mp-action="add" data-i18n="player.addSongs">Add songs…</button>
                <button class="btn bevel hidden" type="button" data-mp-action="reimport" data-i18n="player.reimport">Re-import files</button>
              </div>
              <div class="tiny mp-status" id="mpMsg"></div>
              <div class="mp-vol">
                <span class="kbd" data-i18n="player.vol">Vol</span>
                <input id="mpVol" type="range" min="0" max="1" step="0.01" value="0.8" />
              </div>
            </div>
            <div class="tiny mp-drop hidden" id="mpDropHint" data-i18n="player.drop">Drop audio files here</div>
            <input id="mpFileInput" class="hidden" type="file" multiple accept=".flac,.mp3,.wav,.ogg,audio/*" />
          </div>
        `,

        art: () => `<h2>BLISS — ${t('app.art')}</h2><p>${t('common.soon')}</p>`,
        games: () => {
          if(state.games.view === 'snake'){
            return `
              <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                <button class="btn bevel" type="button" data-games-action="back" data-i18n="games.back">Back</button>
              </div>
              <h2>BLISS — ${t('games.snake')}</h2>
              <div class="snake-layout">
                <div class="snake-board bevel-in" id="snakeBoard">
                  <canvas id="snakeCanvas" class="pixel" width="320" height="320"></canvas>
                  <div class="snake-overlay hidden" id="snakeOverlay">
                    <div class="snake-overlay-box bevel">
                      <strong data-i18n="snake.gameOver">Game Over</strong>
                      <div class="tiny"><span data-i18n="snake.score">Score:</span> <span data-snake-over-score>0</span></div>
                      <button class="btn bevel" type="button" data-snake-action="playAgain" data-i18n="snake.playAgain">Play again</button>
                    </div>
                  </div>
                </div>
                <div class="snake-side">
                  <div class="snake-controls">
                    <button class="btn bevel" type="button" data-snake-action="start" data-i18n="snake.start">Start</button>
                    <button class="btn bevel" type="button" data-snake-action="pause" data-i18n="snake.pause">Pause</button>
                    <div class="tiny"><span data-i18n="snake.score">Score:</span> <strong data-snake-score>0</strong></div>
                    <div class="tiny"><span data-i18n="snake.highScore">High Score:</span> <strong data-snake-high>0</strong></div>
                    <label class="snake-speed">
                      <span class="tiny" data-i18n="snake.speed">Speed:</span>
                      <select data-snake-speed>
                        <option value="slow" data-i18n="snake.speed.slow">Slow</option>
                        <option value="normal" data-i18n="snake.speed.normal">Normal</option>
                        <option value="fast" data-i18n="snake.speed.fast">Fast</option>
                      </select>
                    </label>
                  </div>
                  <div class="tiny snake-instructions" data-i18n="snake.instructions">Use arrow keys or WASD. On mobile, swipe.</div>
                </div>
              </div>
            `;
          }
          const items = (state.folders.games || []).map(id => {
            if(id === 'snake'){
              return `
                <button class="games-item" type="button" data-game-id="snake">
                  <div class="games-icon pixel">
                    <img class="pixel" src="/assets/icons/snake.png" width="32" height="32" alt="${t('games.snake')}" style="display:block;" />
                  </div>
                  <span data-i18n="games.snake">Snake</span>
                </button>
              `;
            }
            const app = getAppById(id);
            if(!app) return '';
            const label = t(app.titleKey);
            const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
            const iconHtml = iconFile
              ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
              : iconSVG(app.icon);
            return `
              <button class="games-item" type="button" data-game-id="${id}">
                <div class="games-icon pixel">${iconHtml}</div>
                <span>${label}</span>
              </button>
            `;
          }).join('');

          return `
            <h2>BLISS — ${t('app.games')}</h2>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:10px;">
              <button class="btn bevel" type="button" data-games-view="grid" data-i18n="games.viewGrid">Grid view</button>
              <button class="btn bevel" type="button" data-games-view="list" data-i18n="games.viewList">List view</button>
              <button class="btn bevel" type="button" data-games-big="toggle" data-i18n="games.bigIcons">Bigger Icons</button>
            </div>
            <div id="gamesList" class="${state.games.layout === 'list' ? 'games-list' : 'games-grid'}${state.games.bigIcons && state.games.layout === 'grid' ? ' games-big' : ''}">
              ${items || `<div class="tiny" data-i18n="games.empty">${t('games.empty')}</div>`}
            </div>
          `;
        },
        videos: () => `
          <div class="videos-shell">
            <div class="videos-header">
              <a href="${VIDEO_CHANNEL_URL}" target="_blank" rel="noopener noreferrer" data-i18n="videos.channelLink">YouTube: @DIEVBLISS</a>
            </div>
            <div class="videos-player">
              <div class="videos-player-head">
                <strong data-i18n="videos.watchTitle">Watch inside BLISS 98</strong>
                <div class="videos-player-actions">
                  <button class="btn bevel" type="button" data-videos-action="openChannel" data-i18n="videos.openChannel">Open channel videos</button>
                  <button class="btn bevel" type="button" data-videos-action="addKey" data-i18n="videos.addKey">Add YouTube API Key…</button>
                </div>
              </div>
              <div class="videos-embed bevel-in">
                <div class="videos-embed-inner">
                  <iframe id="videosPlayer" title="YouTube Player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
                </div>
              </div>
              <div class="tiny" id="videosStatus"></div>
            </div>
            <div class="videos-list" id="videosList"></div>
          </div>
        `,
        poetry: () => {
          if(POEMS.length === 0){
            return `<h2>${t('app.poetry')}</h2><p>${t('poetry.empty')}</p>`;
          }
          if(state.poetry.view === 'read' && state.poetry.currentId){
            const poem = getPoemById(state.poetry.currentId);
            if(!poem){
              state.poetry.view = 'list';
            } else {
              return `
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                  <button class="btn bevel" type="button" data-poetry-action="back">${t('poetry.back')}</button>
                  <button class="btn bevel" type="button" data-poetry-action="toggleLang">${t('poetry.language')}</button>
                  <span class="kbd">${state.poetry.readLang.toUpperCase()}</span>
                </div>
                <h2>${poem.title}</h2>
                <div class="poem-body">${getPoemBody(poem, state.poetry.readLang)}</div>
              `;
            }
          }
          const grid = POEMS.map(poem => `
            <button class="poetry-item" type="button" data-poem-id="${poem.id}">
              <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">
                <img class="pixel" src="/assets/icons/poetry2.png" width="32" height="32" alt="${poem.title}" style="display:block;" />
              </div>
              <span>${poem.title}</span>
            </button>
          `).join('');
          return `
            <h2>${t('poetry.title')}</h2>
            <div class="poetry-grid">${grid}</div>
          `;
        },
        trash: () => {
          const items = Array.from(state.trash);
          if(items.length === 0){
            return `<div class="trash-empty-msg">${t('dialog.trash.empty')}</div>`;
          }
          const grid = items.map(id => {
            const app = APPS.find(a => a.id === id);
            const label = app ? getIconLabel(app) : id;
            const iconFile = app && app.iconFile
              ? (typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile)
              : null;
            const iconHtml = iconFile
              ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
              : iconSVG(app ? app.icon : 'file');
            return `
                  <button class="trash-item" type="button" data-trash-id="${id}">
                <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
                <span>${label}</span>
              </button>
            `;
          }).join('');
          return `<div class="trash-grid">${grid}</div>`;
        },
        contact: () => `
          <h2>${t('contact.title')}</h2>
          <div class="contact-list" style="display:flex; flex-direction:column; gap:8px;">
            <div><strong>${t('contact.label.instagramDIEV')}</strong> <a href="https://www.instagram.com/die.verson/" target="_blank" rel="noopener noreferrer">@die.verson</a></div>
            <div><strong>${t('contact.label.twitterDIEV')}</strong> <a href="https://x.com/DIE_VERSON" target="_blank" rel="noopener noreferrer">@die_verson</a></div>
            <div><strong>${t('contact.label.emailBusiness')}</strong> <a href="mailto:die.versonbusiness@gmail.com">die.versonbusiness@gmail.com</a></div>
            <div><strong>${t('contact.label.instagramBLISS')}</strong> <a href="https://www.instagram.com/blissworldweb/" target="_blank" rel="noopener noreferrer">@blissworldweb</a></div>
          </div>
        `,
        diev: () => `<h2>${t('diev.title')}</h2><p>${t('diev.p1')}</p>`,
        settings: () => `
          <h2 data-i18n="settings.title">Settings</h2>
          <div class="settings-shell">
            <div class="settings-tabs" role="tablist" aria-label="Settings">
              <button class="settings-tab" type="button" role="tab" data-tab="general" aria-controls="settingsPanel_general" data-i18n="settings.tab.general">General</button>
              <button class="settings-tab" type="button" role="tab" data-tab="language" aria-controls="settingsPanel_language" data-i18n="settings.tab.language">Language</button>
              <button class="settings-tab" type="button" role="tab" data-tab="appearance" aria-controls="settingsPanel_appearance" data-i18n="settings.tab.appearance">Appearance</button>
              <button class="settings-tab" type="button" role="tab" data-tab="performance" aria-controls="settingsPanel_performance" data-i18n="settings.tab.performance">Performance</button>
            </div>
            <div class="settings-panels">
              <div class="settings-panel" role="tabpanel" data-tab="general" id="settingsPanel_general">
                <div class="settings-general">
                  <div class="settings-logo">
                    <img class="pixel" src="/assets/icons/computer.png" width="48" height="48" alt="" />
                  </div>
                  <div class="settings-summary">
                    <strong data-i18n="settings.general.title">BLISS 98</strong>
                    <div class="tiny" data-i18n="settings.general.desc">System properties and preferences for BLISS 98.</div>
                    <div class="settings-block tiny">
                      <span data-i18n="settings.general.user">User:</span>
                      <strong>${state.user ? state.user : t('settings.general.guest')}</strong>
                    </div>
                    <div class="tiny">
                      <span data-i18n="settings.general.version">Version:</span>
                      <span>BLISS 98 — Build 98.0</span>
                    </div>
                    <div class="settings-block tiny">
                      <div data-i18n="settings.general.registeredTo">Registered to:</div>
                      <strong data-i18n="settings.general.registeredName">A Bad Motherfucker</strong>
                      <div data-i18n="settings.general.registeredCode">616-FTP-420-333</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="language" id="settingsPanel_language">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/language.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.languageTab">Language</strong>
                    <div class="tiny" data-i18n="settings.languageDesc">Choose your language for BLISS 98.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-lang="en"><span class="kbd" style="margin-right:6px;">EN</span><span data-i18n="settings.lang.en">English</span></button>
                  <button class="btn bevel" type="button" data-set-lang="pt"><span class="kbd" style="margin-right:6px;">PT</span><span data-i18n="settings.lang.pt">Português (BR)</span></button>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="appearance" id="settingsPanel_appearance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/appearance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.appearanceTab">Appearance</strong>
                    <div class="tiny" data-i18n="settings.appearanceDesc">Customize how BLISS 98 looks.</div>
                  </div>
                </div>
                <div class="settings-block" id="settingsThemes">
                  <strong data-i18n="settings.themes.title">Themes</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.themes.desc">Select a theme to change wallpaper, title color, and dark mode.</p>
                  <div class="theme-grid">
                    <button class="theme-thumb bevel" type="button" data-set-theme="default" data-theme-thumb="default">
                      <div class="theme-preview theme-preview-default">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.default">Default</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="totvers" data-theme-thumb="totvers">
                      <div class="theme-preview theme-preview-totvers">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.totvers">Totvers</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="matrix" data-theme-thumb="matrix">
                      <div class="theme-preview theme-preview-matrix">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body" style="background:linear-gradient(180deg, #000 0%, #0a1a0f 100%);"></div>
                      </div>
                      <span data-i18n="theme.matrix">Matrix</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="xp98" data-theme-thumb="xp98">
                      <div class="theme-preview theme-preview-xp98">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body" style="background:url('/assets/wallpapers/bliss98.png') center/cover no-repeat;"></div>
                      </div>
                      <span data-i18n="theme.xp98">XP98</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="blank" data-theme-thumb="blank">
                      <div class="theme-preview theme-preview-blank">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.blank">Blank</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-theme-custom="load" data-theme-thumb="custom">
                      <div class="theme-preview theme-preview-custom">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-theme-custom-label data-i18n="theme.custom">Custom</span>
                    </button>
                  </div>
                  <div style="display:flex; gap:8px; margin-top:8px; align-items:center; flex-wrap:wrap;">
                    <button class="btn bevel" type="button" data-theme-custom="save" data-i18n="theme.save">Save Custom</button>
                    <div class="tiny"><span data-i18n="settings.themes.current">Current theme:</span> <span data-theme-current></span></div>
                  </div>
                </div>
                <div class="settings-block" id="settingsTitlebar">
                  <strong data-i18n="settings.titlebar.title">Window Title Color</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.titlebar.desc">Choose the color of the window title bars.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-titlebar="defaultBlue">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#000080,#1084d0);"></span>
                      <span data-i18n="titlebar.defaultBlue">Default Blue</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="pinkLight">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#f6a6cf,#e46aa9);"></span>
                      <span data-i18n="titlebar.pinkLight">Light Pink</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="purpleDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#3a1c5a,#1b0f30);"></span>
                      <span data-i18n="titlebar.purpleDark">Dark Purple</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="offWhite">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#e6e6e6,#cfcfcf);"></span>
                      <span data-i18n="titlebar.offWhite">Off-white</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="greenDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#1b4a2a,#0e2e1a);"></span>
                      <span data-i18n="titlebar.greenDark">Dark Green</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="redDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#5a1a1a,#2f0b0b);"></span>
                      <span data-i18n="titlebar.redDark">Dark Red</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="blank">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#b6b6b6,#c9c9c9);"></span>
                      <span data-i18n="titlebar.blank">Blank</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="xpBlue">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#0a246a,#3a6ea5);"></span>
                      <span data-i18n="titlebar.xpBlue">XP Blue</span>
                    </button>
                  </div>
                </div>
                <div class="settings-block" id="settingsDarkMode">
                  <strong data-i18n="settings.darkMode.title">Dark Mode</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.darkMode.desc">Makes BLISS 98 darker and easier on the eyes.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-darkmode="on"><span data-i18n="settings.darkMode.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-darkmode="off"><span data-i18n="settings.darkMode.off">Off</span></button>
                  </div>
                </div>
                <div class="settings-block" id="settingsRetro">
                  <strong data-i18n="settings.retro.title">Retro Glow</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.retro.desc">Add a soft glow to windows and icons.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-retro="on"><span data-i18n="settings.retro.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-retro="off"><span data-i18n="settings.retro.off">Off</span></button>
                  </div>
                </div>
                <div class="settings-block" id="settingsWallpaper">
                  <strong data-i18n="settings.wallpaperTab">Wallpaper</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.wallpaperDesc">Choose a wallpaper for your desktop.</p>
                  <div class="grid2">
                    <button class="btn bevel" type="button" data-set-wallpaper="classic">
                      <span class="wallpaper-swatch" style="background:#008080;"></span>
                      <span data-i18n="wallpaper.classic">Classic Teal</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="bliss">
                      <span class="wallpaper-swatch" style="background:radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%);"></span>
                      <span data-i18n="wallpaper.bliss">Sunrise</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="clouds">
                      <span class="wallpaper-swatch" style="background:linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%);"></span>
                      <span data-i18n="wallpaper.clouds">Clouds</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="diev">
                      <span class="wallpaper-swatch" style="background:repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), linear-gradient(135deg, #0a2333, #114b6a);"></span>
                      <span data-i18n="wallpaper.diev">Grid</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="tot">
                      <span class="wallpaper-swatch" style="background:radial-gradient(circle at 20% 20%, #ffd1e6 0%, #ff9fcb 45%, #ff7fb7 100%);"></span>
                      <span data-i18n="wallpaper.tot">Tot (Pink)</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="matrix">
                      <span class="wallpaper-swatch" style="background:repeating-linear-gradient(90deg, rgba(0,255,90,0.6) 0 2px, transparent 2px 5px), linear-gradient(180deg, #000 0%, #0a1a0f 100%);"></span>
                      <span data-i18n="wallpaper.matrix">Matrix</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="xp98bliss">
                      <span class="wallpaper-swatch" style="background:url('/assets/wallpapers/bliss98.png') center/cover no-repeat;"></span>
                      <span data-i18n="wallpaper.xp98bliss">XP Bliss 98</span>
                    </button>
                  </div>
                </div>
                <div class="settings-block">
                  <strong data-i18n="settings.scanlinesTab">Scanlines</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.scanlinesDesc">Add scanline effect to the display.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-scanlines="on"><span data-i18n="settings.scanlines.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-scanlines="off"><span data-i18n="settings.scanlines.off">Off</span></button>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="performance" id="settingsPanel_performance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/performance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.animationsTab">Animations</strong>
                    <div class="tiny" data-i18n="settings.animationsDesc">Toggle window animations.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-animations="on"><span data-i18n="settings.animations.on">On</span></button>
                  <button class="btn bevel" type="button" data-set-animations="off"><span data-i18n="settings.animations.off">Off</span></button>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      function getDisplayTime(){
        const d = new Date();
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        return `${hh}:${mm}`;
      }
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }


      // --- BLISS Media Player ---
      // NOTE: Browsers cannot scan/list a folder on static hosting (GitHub Pages). We use a manifest file.
      // Create: /assets/music/manifest.json or /assets/audio/tracks.json  Example: ["WOW.mp3","People Change.mp3"]
      const MP_MANIFEST_URL = '/assets/audio/tracks.json';
      const MP_LIBRARY_URLS = ['/assets/music/manifest.json', MP_MANIFEST_URL];
      const MP_STATE_KEY = 'bliss98_mp_state';
      const MP_IMPORT_KEY = 'bliss98_mp_imports';

      let mp = {
        tracks: [],
        manifestTracks: [],
        imported: [],
        importedNames: [],
        idx: 0,
        playing: false,
        vol: 0.8,
        loaded: false,
        seeking: false,
        supportsFlac: true,
      };

      function mpSafeTitleFromFilename(name){
        try{
          const base = String(name).split('/').pop();
          const noExt = base.replace(/\.[^/.]+$/,'');
          return decodeURIComponent(noExt);
        } catch {
          return String(name).replace(/\.[^/.]+$/,'');
        }
      }

      function mpLoadState(){
        try{
          const raw = localStorage.getItem(MP_STATE_KEY);
          if(raw){
            const s = JSON.parse(raw);
            if(typeof s.idx === 'number') mp.idx = s.idx;
            if(typeof s.vol === 'number') mp.vol = clamp(s.vol, 0, 1);
          }
        } catch {}
        try{
          const rawImports = localStorage.getItem(MP_IMPORT_KEY);
          mp.importedNames = rawImports ? JSON.parse(rawImports) : [];
          state.mediaplayer.needsReimport = Array.isArray(mp.importedNames) && mp.importedNames.length > 0;
        } catch {
          mp.importedNames = [];
          state.mediaplayer.needsReimport = false;
        }
      }

      function mpSaveState(){
        try{ localStorage.setItem(MP_STATE_KEY, JSON.stringify({ idx: mp.idx, vol: mp.vol })); } catch {}
      }

      function mpResolveTitleFromSrc(src){
        return mpSafeTitleFromFilename(src);
      }

      function mpNormalizeManifest(data, baseDir){
        if(!Array.isArray(data)) return [];
        return data.map(item => {
          if(typeof item === 'string'){
            const file = item.trim();
            const isAbs = /^(https?:)?\//.test(file);
            const src = (isAbs || file.startsWith('.')) ? file : (baseDir + file);
            return { src, title: mpResolveTitleFromSrc(file), kind: 'manifest' };
          }
          if(item && typeof item === 'object' && (item.src || item.file)){
            const raw = String(item.src || item.file);
            const isAbs = /^(https?:)?\//.test(raw);
            const src = (isAbs || raw.startsWith('.')) ? raw : (baseDir + raw);
            return { src, title: item.title ? String(item.title) : mpResolveTitleFromSrc(raw), kind: 'manifest' };
          }
          return null;
        }).filter(Boolean);
      }

      function mpRebuildTracks(){
        mp.tracks = [...mp.manifestTracks, ...mp.imported];
      }

      function mpAddFiles(fileList){
        const files = Array.from(fileList || []);
        if(files.length === 0) return;
        const accepted = files.filter(f => {
          const name = String(f.name || '').toLowerCase();
          const ext = name.split('.').pop();
          return ['flac','mp3','wav','ogg'].includes(ext) || (f.type && f.type.startsWith('audio/'));
        });
        if(accepted.length === 0) return;

        const added = [];
        accepted.forEach(file => {
          const name = String(file.name || '');
          const ext = name.toLowerCase().split('.').pop();
          const src = URL.createObjectURL(file);
          added.push({
            src,
            title: mpSafeTitleFromFilename(name),
            kind: 'local',
            ext,
            file,
          });
        });

        mp.imported = [...mp.imported, ...added];
        mp.importedNames = mp.imported.map(tr => tr.title);
        state.mediaplayer.needsReimport = false;
        try{ localStorage.setItem(MP_IMPORT_KEY, JSON.stringify(mp.importedNames)); } catch {}

        mpRebuildTracks();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        } else {
          mpRender();
        }
      }

      function mpEls(){
        const win = document.getElementById('win_mediaplayer');
        if(!win) return null;
        return {
          win,
          audio: win.querySelector('#mpAudio'),
          now: win.querySelector('#mpNow'),
          msg: win.querySelector('#mpMsg'),
          seek: win.querySelector('#mpSeek'),
          current: win.querySelector('[data-mp-current]'),
          total: win.querySelector('[data-mp-total]'),
          vol: win.querySelector('#mpVol'),
          toggleBtn: win.querySelector('[data-mp-action="toggle"]'),
          shuffleBtn: win.querySelector('[data-mp-action="shuffle"]'),
          repeatBtn: win.querySelector('[data-mp-action="repeat"]'),
          addBtn: win.querySelector('[data-mp-action="add"]'),
          reimportBtn: win.querySelector('[data-mp-action="reimport"]'),
          dropHint: win.querySelector('#mpDropHint'),
          fileInput: win.querySelector('#mpFileInput'),
        };
      }

      function mpRender(){
        const els = mpEls();
        if(!els) return;
        const { now, msg, vol, toggleBtn, audio, shuffleBtn, repeatBtn, reimportBtn } = els;

        if(vol){
          vol.value = String(mp.vol);
        }
        if(audio){
          audio.volume = mp.vol;
        }

        if(msg){
          const hasFlac = mp.tracks.some(tr => {
            const src = String(tr.src || '').toLowerCase();
            return src.endsWith('.flac') || tr.ext === 'flac';
          });
          if(!mp.loaded){
            msg.textContent = t('player.loading');
          } else if(state.mediaplayer.needsReimport){
            msg.textContent = t('player.reimportHint');
          } else if(mp.tracks.length === 0){
            msg.textContent = t('player.notfound');
          } else if(!mp.supportsFlac && hasFlac){
            msg.textContent = t('player.flacUnsupported');
          } else {
            msg.textContent = '';
          }
        }

        const cur = mp.tracks[mp.idx];
        if(now) now.textContent = cur ? cur.title : '—';
        if(toggleBtn) toggleBtn.innerHTML = mp.playing ? `⏸ ${t('player.pause')}` : `▶ ${t('player.play')}`;
        if(shuffleBtn){
          shuffleBtn.textContent = t('player.shuffle');
          shuffleBtn.classList.toggle('pressed', state.mediaplayer.shuffle);
        }
        if(repeatBtn){
          const repeatKey = `player.repeat.${state.mediaplayer.repeat}`;
          repeatBtn.textContent = `${t('player.repeat')} ${t(repeatKey)}`;
          repeatBtn.classList.toggle('pressed', state.mediaplayer.repeat !== 'off');
        }
        if(reimportBtn){
          reimportBtn.classList.toggle('hidden', !state.mediaplayer.needsReimport);
        }
        mpUpdateTime();
      }

      function mpApplyVolume(els){
        if(!els || !els.audio) return;
        if(els.vol){
          els.vol.value = String(mp.vol);
        }
        els.audio.volume = mp.vol;
      }

      function mpBindAudioEventsOnce(audio){
        if(!audio || audio.dataset.mpBound === '1') return;
        audio.dataset.mpBound = '1';
        audio.addEventListener('ended', ()=> mpNext());
        audio.addEventListener('timeupdate', mpUpdateTime);
        audio.addEventListener('loadedmetadata', mpUpdateTime);
        audio.addEventListener('durationchange', mpUpdateTime);
        audio.addEventListener('canplay', mpUpdateTime);
      }

      function mpBindUiEventsOnce(win, els){
        if(!win || win.dataset.mpUiBound === '1') return;
        win.dataset.mpUiBound = '1';

        if(els.vol){
          els.vol.addEventListener('input', ()=>{
            mp.vol = Number(els.vol.value);
            if(els.audio) els.audio.volume = mp.vol;
            mpSaveState();
          });
        }

        if(els.seek){
          els.seek.addEventListener('input', ()=>{
            mp.seeking = true;
            mpSeekTo(els.seek.value);
          });
          els.seek.addEventListener('change', ()=>{
            mp.seeking = false;
            mpSeekTo(els.seek.value);
          });
          els.seek.addEventListener('pointerdown', ()=>{
            mp.seeking = true;
          });
          els.seek.addEventListener('pointerup', ()=>{
            mp.seeking = false;
          });
          els.seek.addEventListener('pointercancel', ()=>{
            mp.seeking = false;
          });
        }

        if(els.fileInput){
          els.fileInput.addEventListener('change', ()=>{
            mpAddFiles(els.fileInput.files);
            mpRender();
          });
        }

        const dropTarget = win.querySelector('.mp-mini');
        if(dropTarget && !dropTarget.dataset.mpDrop){
          dropTarget.dataset.mpDrop = '1';
          const showDrop = (on)=>{
            if(!els.dropHint) return;
            els.dropHint.classList.toggle('hidden', !on);
            els.dropHint.classList.toggle('active', !!on);
          };
          dropTarget.addEventListener('dragover', (e)=>{
            e.preventDefault();
            showDrop(true);
          });
          dropTarget.addEventListener('dragleave', ()=>{
            showDrop(false);
          });
          dropTarget.addEventListener('drop', (e)=>{
            e.preventDefault();
            showDrop(false);
            if(e.dataTransfer && e.dataTransfer.files){
              mpAddFiles(e.dataTransfer.files);
              mpRender();
            }
          });
        }
      }

      function mpFormatTime(raw){
        if(!Number.isFinite(raw)) return '--:--';
        const total = Math.max(0, Math.floor(raw));
        const hours = Math.floor(total / 3600);
        const mins = Math.floor((total % 3600) / 60);
        const secs = total % 60;
        if(hours > 0){
          return `${hours}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
        }
        return `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
      }

      function mpUpdateTime(){
        const els = mpEls();
        if(!els) return;
        const { audio, seek, current, total } = els;
        const dur = Number.isFinite(audio.duration) ? audio.duration : 0;
        const cur = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;

        if(seek){
          seek.disabled = !dur;
          if(!dur){
            seek.value = '0';
          } else if(!mp.seeking){
            const ratio = cur / dur;
            seek.value = String(Math.round(ratio * 1000));
          }
        }
        if(current) current.textContent = mpFormatTime(cur);
        if(total) total.textContent = dur ? mpFormatTime(dur) : '--:--';
      }

      function mpSeekTo(value){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        const dur = Number.isFinite(audio.duration) ? audio.duration : 0;
        if(!dur) return;
        const ratio = clamp(Number(value) / 1000, 0, 1);
        audio.currentTime = ratio * dur;
        mpUpdateTime();
      }

      function mpOpenFilePicker(){
        const els = mpEls();
        if(!els || !els.fileInput) return;
        els.fileInput.value = '';
        els.fileInput.click();
      }

      function schedulePlayerAutoplay(){
        if(state.didAutoPlayThisSession) return;
        if(state.autoPlayTimer) clearTimeout(state.autoPlayTimer);
        state.autoPlayTimer = setTimeout(async ()=>{
          if(state.didAutoPlayThisSession) return;
          if(mp.playing) return;
          if(!state.windows.has('mediaplayer')) openApp('mediaplayer');

          const tryPlay = async () => {
            if(mp.tracks.length === 0){
              await mpLoadTracks();
            }
            if(mp.tracks.length === 0) return false;
            if(mp.idx < 0 || mp.idx >= mp.tracks.length){
              mp.idx = 0;
              mpSetTrack(0);
            }
            await mpPlay();
            return mp.playing;
          };

          let ok = await tryPlay();
          if(!ok){
            for(let i=0;i<3;i++){
              await new Promise(r => setTimeout(r, 500));
              ok = await tryPlay();
              if(ok) break;
            }
          }
          if(ok) state.didAutoPlayThisSession = true;
        }, 6000);
      }

      function mpSetTrack(i){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        mp.idx = clamp(i, 0, mp.tracks.length - 1);
        const cur = mp.tracks[mp.idx];
        audio.src = cur.src;
        audio.volume = mp.vol;
        audio.currentTime = 0;
        mpSaveState();
        mpRender();
      }

      async function mpPlay(){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        try{
          await audio.play();
          mp.playing = true;
        } catch {
          mp.playing = false;
        }
        mpRender();
      }

      function mpPause(){
        const els = mpEls();
        if(!els) return;
        els.audio.pause();
        mp.playing = false;
        mpRender();
      }

      function mpNext(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle){
          let next = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && next === mp.idx){
            next = (next + 1) % mp.tracks.length;
          }
          mpSetTrack(next);
          mpPlay();
          return;
        }
        if(!manual && state.mediaplayer.repeat === 'one'){
          mpSetTrack(mp.idx);
          mpPlay();
          return;
        }
        const atEnd = (mp.idx === mp.tracks.length - 1);
        if(atEnd && !manual && state.mediaplayer.repeat === 'off'){
          mpPause();
          return;
        }
        const nextIdx = atEnd ? 0 : mp.idx + 1;
        mpSetTrack(nextIdx);
        mpPlay();
      }

      function mpPrev(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle && !manual){
          let prev = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && prev === mp.idx){
            prev = (prev + 1) % mp.tracks.length;
          }
          mpSetTrack(prev);
          mpPlay();
          return;
        }
        const prevIdx = (mp.idx - 1 + mp.tracks.length) % mp.tracks.length;
        mpSetTrack(prevIdx);
        mpPlay();
      }

      async function mpLoadTracks(){
        mp.loaded = false;
        mp.manifestTracks = [];
        mpRebuildTracks();
        mpRender();

        try{
          let loaded = false;
          for(const url of MP_LIBRARY_URLS){
            const res = await fetch(url, { cache: 'no-store' });
            if(!res.ok) continue;
            const data = await res.json();
            if(Array.isArray(data) || Array.isArray(data.tracks)){
              const baseDir = url.includes('/assets/music/') ? '/assets/music/' : '/assets/audio/';
              const list = Array.isArray(data) ? data : data.tracks;
              mp.manifestTracks = mpNormalizeManifest(list, baseDir);
              loaded = true;
              break;
            }
          }
          if(!loaded){
            mp.manifestTracks = [];
          }
        } catch {
          mp.manifestTracks = [];
        }

        mp.loaded = true;
        mpLoadState();
        mpRebuildTracks();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        }
        mpRender();
      }

      function mpInitInWindow(){
        const els = mpEls();
        if(!els) return;
        const { audio, win } = els;
        mpBindAudioEventsOnce(audio);
        mpBindUiEventsOnce(win, els);
        mp.supportsFlac = !!audio.canPlayType('audio/flac');
        mpApplyVolume(els);
        mpUpdateTime();
        // Load tracks each time window is (re)rendered
        mpLoadTracks();
      }

      // Delegate Media Player button clicks
      document.addEventListener('click', (e)=>{
        const actBtn = e.target.closest && e.target.closest('[data-mp-action]');
        if(actBtn){
          const action = actBtn.dataset.mpAction;
          if(action === 'toggle'){
            if(mp.playing) mpPause(); else mpPlay();
          }
          if(action === 'next') mpNext(true);
          if(action === 'prev') mpPrev(true);
          if(action === 'shuffle'){
            state.mediaplayer.shuffle = !state.mediaplayer.shuffle;
            mpRender();
          }
          if(action === 'repeat'){
            const order = ['off', 'one', 'all'];
            const idx = order.indexOf(state.mediaplayer.repeat);
            state.mediaplayer.repeat = order[(idx + 1) % order.length];
            mpRender();
          }
          if(action === 'add' || action === 'reimport'){
            mpOpenFilePicker();
          }
        }

        const pickBtn = e.target.closest && e.target.closest('[data-mp-pick]');
        if(pickBtn){
          const idx = Number(pickBtn.dataset.mpPick);
          state.mediaplayer.selected = new Set([idx]);
          mpSetTrack(idx);
          mpPlay();
        }
      });

      document.addEventListener('dblclick', (e)=>{
        const card = e.target.closest && e.target.closest('[data-music-id]');
        if(card && card.dataset && card.dataset.musicLink){
          e.preventDefault();
          openLink(card.dataset.musicLink, 'music');
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem && poemItem.dataset && poemItem.dataset.poemId){
          e.preventDefault();
          state.poetry.view = 'read';
          state.poetry.currentId = poemItem.dataset.poemId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem && trashItem.dataset && trashItem.dataset.trashId){
          e.preventDefault();
          restoreFromTrash([trashItem.dataset.trashId]);
        }
      });

      let lastPoetryTap = { id: null, time: 0 };
      document.addEventListener('pointerdown', (e)=>{
        if(e.pointerType !== 'touch') return;
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard && musicCard.dataset && musicCard.dataset.musicLink){
          const id = musicCard.dataset.musicId;
          state.music.selected = new Set([id]);
          applyMusicState();
          musicCard.dataset.touchOpened = '1';
          openLink(musicCard.dataset.musicLink, 'music');
          return;
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(!poemItem || !poemItem.dataset) return;
        const id = poemItem.dataset.poemId;
        const now = Date.now();
        if(lastPoetryTap.id === id && (now - lastPoetryTap.time) < 320){
          state.poetry.view = 'read';
          state.poetry.currentId = id;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
          lastPoetryTap = { id: null, time: 0 };
        } else {
          lastPoetryTap = { id, time: now };
        }
      });

      document.addEventListener('mouseover', (e)=>{
        if(!state.menuOpen) return;
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          openWindowMenu(winEl, menuKey, menuToggle);
        }
      });

      // Prevent browser text selection on desktop drags (keep selection inside .content and inputs)
      document.addEventListener('selectstart', (e)=>{
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(tag === 'input' || tag === 'textarea') return;
        if(e.target && e.target.closest && e.target.closest('.content')) return;
        e.preventDefault();
      });

      function setUser(name){
        state.user = name;
        localStorage.setItem('bliss98_user', name);
        $('#who').textContent = name ? name : '';
      }

      function showDesktop(){
        $('#login').classList.add('hidden');
        $('#desktop').classList.remove('hidden');
        $('#username').blur();
        themeApplying = true;
        applyWallpaper(state.wallpaper);
        themeApplying = false;
        renderIcons();
        renderStartMenu();
        tickClock();
      }
      let logoffInProgress = false;

      function showLogin(playBoot = false){
        $('#desktop').classList.add('hidden');
        $('#login').classList.remove('hidden');
        $('#username').focus();
        if(playBoot && SFX.boot && !SFX.boot.played){
          playSfxOnce('boot', { allowPending: true }).then((ok)=>{
            if(!ok && !SFX.boot.played) armBootUnlock();
          });
        }
      }

      function doLogoff(){
        if(logoffInProgress) return;
        logoffInProgress = true;
        if(state.autoPlayTimer){
          clearTimeout(state.autoPlayTimer);
          state.autoPlayTimer = null;
        }
        state.didAutoPlayThisSession = false;
        closeStartMenu();
        closeCtxMenu();
        closeWindowMenu();
        closeModal();
        playSfxAndWait('logoff').finally(()=>{
          showLogin(false);
          logoffInProgress = false;
        });
      }

function renderIcons(){
  const grid = $('#iconGrid');
  grid.innerHTML = '';

  const saved = loadIconPositions();
  const metrics = getGridMetrics();
  const occupied = new Map();
  let needsSave = false;
  const defaultLayout = getDefaultIconLayout();

  const desktopItems = [
    ...APPS.filter(app => app.showOnDesktop !== false).map(app => ({ type:'app', item: app })),
    ...VIRTUAL_ICONS.map(v => ({ type:'virtual', item: v }))
  ];

  desktopItems.forEach(({ type, item }, idx) => {
    const id = item.id;
    if(id !== 'trash' && state.trash.has(id)) return;
    if(isInFolder(id)) return;
    const el = document.createElement('div');
    el.className = 'icon';
    el.dataset.appId = id;

    const def = defaultLayout[id] || legacyDefaultIconPos(idx);
    const pos = (saved && saved[id]) ? saved[id] : def;
    const placed = placeOnFreeCell(pos.x, pos.y, occupied, metrics);
    el.style.left = placed.x + 'px';
    el.style.top = placed.y + 'px';
    if(placed.changed || !saved[id]){
      saved[id] = { x: placed.x, y: placed.y };
      needsSave = true;
    }

    const label = (type === 'virtual') ? t(item.titleKey) : getIconLabel(item);
    const iconFile = type === 'virtual' ? item.iconFile : (typeof item.iconFile === 'function' ? item.iconFile() : item.iconFile);
    const iconHtml = iconFile
      ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
      : iconSVG(item.icon);

          el.innerHTML = `
            <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
            <span>${label}</span>
          `;
    if(state.trash.has(id)) el.classList.add('trashed');

          // Click select
          el.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(el.dataset.dragged === '1'){
              // prevent post-drag click from changing selection unexpectedly
              el.dataset.dragged = '0';
              return;
            }
      selectIcon(id);
    });

          // Double click open
          el.addEventListener('dblclick', (e)=>{
            e.stopPropagation();
      openIconById(id);
    });

    makeIconDraggable(el);
    el.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      openCtxMenu(ev.clientX, ev.clientY, 'icon', id);
    });
    installLongPress(el, ()=>({ target:'icon', appId: id }));
    grid.appendChild(el);
  });
        if(needsSave) saveIconPositions(saved);
      }
      function selectIcon(id){
        state.selectedIconId = id;
        $$('.icon').forEach(i=>i.classList.toggle('selected', i.dataset.appId === id));
      }

      function makeIconDraggable(iconEl){
        let down = false;
        let dragging = false;
        let pointerId = null;
        let movedToLayer = false;

        let startX = 0, startY = 0;
        let group = [];
        let startPositions = []; // { el, id, x, y }

        // group bounds + allowed delta range
        let dxMin = 0, dxMax = 0, dyMin = 0, dyMax = 0;

        const dragLayer = $('#dragLayer');
        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;

          e.stopPropagation();
          closeStartMenu();
          closeCtxMenu();

          // If multiple icons are selected and the one we grabbed is selected, drag the whole group.
          const selectedEls = $$('.icon.selected');
          const isSelected = iconEl.classList.contains('selected');
          if(selectedEls.length > 1 && isSelected){
            group = selectedEls;
          } else {
            // Otherwise, single-select the grabbed icon
            selectIcon(iconEl.dataset.appId);
            group = [iconEl];
          }

          down = true;
          dragging = false;
          pointerId = e.pointerId;
          startX = e.clientX;
          startY = e.clientY;
          movedToLayer = false;

          // Snapshot starting positions
          startPositions = group.map(el => ({
            el,
            id: el.dataset.appId,
            x: parseInt(el.style.left || '0', 10),
            y: parseInt(el.style.top || '0', 10)
          }));

          // Compute bounds in desktop coordinates (relative to desktopArea)
          const area = $('#desktopArea').getBoundingClientRect();
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          startPositions.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x + ICON_SIZE.w);
            maxY = Math.max(maxY, p.y + ICON_SIZE.h);
          });

          // Right/bottom limits match `clampIconPos` behavior (icon right edge <= area.width - 6)
          dxMin = -minX;
          dxMax = (Math.floor(area.width - 6) - maxX);
          dyMin = -minY;
          dyMax = (Math.floor(area.height - 6) - maxY);

          // Prevent accidental post-drag clicks
          group.forEach(el => (el.dataset.dragged = '0'));

          document.body.classList.add('dragging');
          try{ iconEl.setPointerCapture(pointerId); } catch {}

          iconEl.addEventListener('pointermove', onPointerMove);
          iconEl.addEventListener('pointerup', onPointerUp);
          iconEl.addEventListener('pointercancel', onPointerUp);

          e.preventDefault();
        };

        const moveGroupToLayer = ()=>{
          if(movedToLayer || !dragLayer) return;
          dragLayer.classList.add('active');
          group.forEach(el => {
            dragLayer.appendChild(el);
            el.style.zIndex = '9999';
          });
          movedToLayer = true;
        };

        const restoreGroupLayer = ()=>{
          if(!movedToLayer) return;
          const grid = $('#iconGrid');
          group.forEach(el => {
            grid.appendChild(el);
            el.style.zIndex = '';
          });
          if(dragLayer) dragLayer.classList.remove('active');
          movedToLayer = false;
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const dxRaw = e.clientX - startX;
          const dyRaw = e.clientY - startY;

          if(!dragging && (Math.abs(dxRaw) + Math.abs(dyRaw) > 4)){
            dragging = true;
            moveGroupToLayer();
          }
          if(!dragging) return;

          // Clamp movement so the whole group stays within the desktop
          const dx = clamp(dxRaw, dxMin, dxMax);
          const dy = clamp(dyRaw, dyMin, dyMax);

          // Move all icons in the group
          startPositions.forEach(p => {
            p.el.style.left = (p.x + dx) + 'px';
            p.el.style.top = (p.y + dy) + 'px';
          });

          e.preventDefault();
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ iconEl.releasePointerCapture(e.pointerId); } catch {}

          iconEl.removeEventListener('pointermove', onPointerMove);
          iconEl.removeEventListener('pointerup', onPointerUp);
          iconEl.removeEventListener('pointercancel', onPointerUp);

          document.body.classList.remove('dragging');

          if(dragging){
            const ids = startPositions.map(p => p.id);
            if(isOverTrashWindow(e.clientX, e.clientY) || isOverTrash(e.clientX, e.clientY)){
              restoreGroupLayer();
              moveIconsToTrash(ids);
            } else if(isOverGamesWindow(e.clientX, e.clientY)){
              addToFolder('games', ids);
              const saved = loadIconPositions();
              ids.forEach(id => { delete saved[id]; });
              saveIconPositions(saved);
              restoreGroupLayer();
              renderIcons();
              renderGamesWindow();
            } else {
              restoreGroupLayer();
              // Save all moved positions in one write
              const saved = loadIconPositions();
              const metrics = getGridMetrics();
              const movedIds = new Set(ids);
              const occupied = new Map();

              APPS.forEach((app, idx) => {
                if(movedIds.has(app.id)) return;
                const base = saved[app.id] || defaultIconPos(idx);
                const placed = placeOnFreeCell(base.x, base.y, occupied, metrics);
                if(placed.changed || !saved[app.id]){
                  saved[app.id] = { x: placed.x, y: placed.y };
                }
              });

              startPositions.forEach(p => {
                let x = parseInt(p.el.style.left || '0', 10);
                let y = parseInt(p.el.style.top || '0', 10);

                if(state.gridSnap){
                  const snapped = snapToGrid(x, y);
                  x = snapped.x;
                  y = snapped.y;
                }

                const placed = placeOnFreeCell(x, y, occupied, metrics);
                p.el.style.left = placed.x + 'px';
                p.el.style.top = placed.y + 'px';
                saved[p.id] = { x: placed.x, y: placed.y };
                p.el.dataset.dragged = '1';
              });
              saveIconPositions(saved);
            }
          }

          dragging = false;
          pointerId = null;
        };

        // Pointer events handle mouse + touch + pen
        iconEl.addEventListener('pointerdown', onPointerDown);
      }

      $('#desktopArea').addEventListener('click', ()=>{
        // If a selection drag just happened, do not treat it as a click
        if($('#desktopArea').dataset.selDragged === '1'){
          $('#desktopArea').dataset.selDragged = '0';
          return;
        }
        state.selectedIconId = null;
        $$('.icon').forEach(i=>i.classList.remove('selected'));
        closeStartMenu();
        closeCtxMenu();
      });

      // Right-click / two-finger click on desktop
      $('#desktopArea').addEventListener('contextmenu', (e)=>{
        if($('#desktop').classList.contains('hidden')) return;
        if(e.target && e.target.closest && e.target.closest('.icon')) return;
        e.preventDefault();
        openCtxMenu(e.clientX, e.clientY, 'desktop', null);
      });

      // Long-press on desktop (mobile/touch)
      installLongPress($('#desktopArea'), ()=>({ target:'desktop', appId:null }));

      // Rubber-band selection (Windows 98 style)
      (function installRubberbandSelection(){
        const areaEl = $('#desktopArea');
        const rb = $('#rubberband');
        if(!areaEl || !rb) return;

        let down = false;
        let active = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let lastRect = null;

        function rectFrom(aX, aY, bX, bY){
          const x1 = Math.min(aX, bX);
          const y1 = Math.min(aY, bY);
          const x2 = Math.max(aX, bX);
          const y2 = Math.max(aY, bY);
          return { x:x1, y:y1, w:(x2-x1), h:(y2-y1) };
        }

        function intersects(r, elRect){
          return !(elRect.right < r.x || elRect.left > (r.x + r.w) || elRect.bottom < r.y || elRect.top > (r.y + r.h));
        }

        function updateRubberband(r){
          rb.style.left = r.x + 'px';
          rb.style.top = r.y + 'px';
          rb.style.width = r.w + 'px';
          rb.style.height = r.h + 'px';
        }

        function clearRubberband(){
          rb.classList.add('hidden');
          rb.style.width = '0px';
          rb.style.height = '0px';
          lastRect = null;
          document.body.classList.remove('dragging');
        }

        function selectByRect(r){
          // Select icons whose bounding boxes intersect with the rubberband rect
          const icons = $$('.icon');
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const area = areaEl.getBoundingClientRect();
            const rel = {
              left: rect.left - area.left,
              right: rect.right - area.left,
              top: rect.top - area.top,
              bottom: rect.bottom - area.top,
            };
            const hit = intersects(r, rel);
            icon.classList.toggle('selected', hit);
          });
        }

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Don't start a box if user is interacting with icons/windows/menus
          if(e.target && e.target.closest && (e.target.closest('.icon') || e.target.closest('.window') || e.target.closest('#startMenu') || e.target.closest('#ctxMenu'))){
            return;
          }

          down = true;
          active = false;
          pointerId = e.pointerId;

          const area = areaEl.getBoundingClientRect();
          startX = e.clientX - area.left;
          startY = e.clientY - area.top;

          try{ areaEl.setPointerCapture(pointerId); } catch {}
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const area = areaEl.getBoundingClientRect();
          const curX = e.clientX - area.left;
          const curY = e.clientY - area.top;

          const dx = curX - startX;
          const dy = curY - startY;

          // Activate after small movement threshold
          if(!active && (Math.abs(dx) + Math.abs(dy) > 6)){
            active = true;
            rb.classList.remove('hidden');
            document.body.classList.add('dragging');
            // Close menus
            closeStartMenu();
            closeCtxMenu();
            // Clear single selection
            state.selectedIconId = null;
          }
          if(!active) return;

          e.preventDefault();

          const r = rectFrom(startX, startY, curX, curY);
          lastRect = r;
          updateRubberband(r);
          selectByRect(r);
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ areaEl.releasePointerCapture(e.pointerId); } catch {}

          if(active){
            // Prevent click clear right after box select
            areaEl.dataset.selDragged = '1';
            active = false;
            clearRubberband();
          }
          pointerId = null;
        };

        areaEl.addEventListener('pointerdown', onPointerDown);
        areaEl.addEventListener('pointermove', onPointerMove);
        areaEl.addEventListener('pointerup', onPointerUp);
        areaEl.addEventListener('pointercancel', onPointerUp);
      })();

      function renderStartMenu(){
        const list = $('#startList');
        list.innerHTML = '';
        APPS.filter(app => app.showInStart !== false).forEach(app => {
          const item = document.createElement('div');
          item.className = 'menu-item';
          const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
          item.innerHTML = `
            <div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;">${iconFile ? `<img class="pixel" src="${iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${app.id}" />` : iconSVG(app.icon)}</div>
            <div>${t(app.titleKey)}</div>
          `;
          item.addEventListener('click', ()=>{ openApp(app.id); closeStartMenu(); });
          list.appendChild(item);
        });

        const sep = document.createElement('div');
        sep.className = 'menu-sep';
        list.appendChild(sep);

        const logout = document.createElement('div');
        logout.className = 'menu-item';
        logout.innerHTML = `<div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;"><img class="pixel" src="/assets/icons/logout.png" width="16" height="16" alt="" style="display:block;" /></div><div>${t('menu.logoff')}</div>`;
        logout.addEventListener('click', ()=>{ closeStartMenu(); doLogoff(); });
        list.appendChild(logout);
      }

      function toggleStartMenu(){
        const menu = $('#startMenu');
        const btn = $('#startBtn');
        const isOpen = !menu.classList.contains('hidden');
        if(isOpen) closeStartMenu();
        else { menu.classList.remove('hidden'); btn.classList.add('pressed'); }
      }
      function closeStartMenu(){
        $('#startMenu').classList.add('hidden');
        $('#startBtn').classList.remove('pressed');
      }
      $('#startBtn').addEventListener('click', (e)=>{ e.stopPropagation(); toggleStartMenu(); });

      function defaultWindowRect(){
        const area = $('#desktopArea').getBoundingClientRect();
        const w = clamp(Math.round(area.width * 0.56), 320, 720);
        const h = clamp(Math.round(area.height * 0.58), 240, 640);
        const left = Math.round((area.width - w) * (0.18 + Math.random()*0.18));
        const top = Math.round((area.height - h) * (0.12 + Math.random()*0.18));
        return { left, top, width:w, height:h };
      }

      function sizeWindowToContent(winEl, appId){
        if(!winEl) return;
        const frame = winEl.querySelector('.frame');
        const content = winEl.querySelector('.content');
        if(!frame || !content) return;

        const area = $('#desktopArea').getBoundingClientRect();
        const frameRect = frame.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const extraW = frameRect.width - contentRect.width;
        const extraH = frameRect.height - contentRect.height;

        const targetW = Math.ceil(Math.max(content.scrollWidth, content.clientWidth) + extraW);
        const targetH = Math.ceil(Math.max(content.scrollHeight, content.clientHeight) + extraH);

        const maxW = Math.max(280, Math.floor(area.width));
        const maxH = Math.max(200, Math.floor(area.height));
        const newW = clamp(targetW, 280, maxW);
        const newH = clamp(targetH, 200, maxH);

        let newL = parseFloat(winEl.style.left) || 0;
        let newT = parseFloat(winEl.style.top) || 0;
        if(newL + newW > maxW) newL = Math.max(0, maxW - newW);
        if(newT + newH > maxH) newT = Math.max(0, maxH - newH);

        winEl.style.width = newW + 'px';
        winEl.style.height = newH + 'px';
        winEl.style.left = newL + 'px';
        winEl.style.top = newT + 'px';

        const w = state.windows.get(appId);
        if(w){
          w.width = newW;
          w.height = newH;
          w.left = newL;
          w.top = newT;
        }
      }

      function openApp(appId){
        const app = APPS.find(a=>a.id===appId);
        if(!app) return;

        if(state.windows.has(appId)){
          const w = state.windows.get(appId);
          w.minimized = false;
          const el = document.getElementById(`win_${appId}`);
          if(el) el.classList.remove('hidden');
          focusWindow(appId);
          renderTaskButtons();
          return;
        }

        const rect = defaultWindowRect();
        if(appId === 'mediaplayer'){
          const area = $('#desktopArea').getBoundingClientRect();
          const maxW = Math.max(260, Math.floor(area.width - 40));
          const maxH = Math.max(180, Math.floor(area.height - 80));
          rect.width = clamp(360, 260, maxW);
          rect.height = clamp(210, 180, maxH);
        }
        const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
        const wstate = {
          id: appId,
          title: t(app.titleKey),
          titleKey: app.titleKey,
          icon: app.icon,
          iconFile: iconFile || null,
          minimized: false,
          fit: false,
          prevRect: null,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          z: ++state.zTop,
        };
        state.windows.set(appId, wstate);
        createWindowElement(wstate);
        focusWindow(appId);
        renderTaskButtons();
      }

      function closeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        if(appId === 'games'){
          snakeStop();
          state.games.view = 'list';
          state.games.selectedId = null;
        }
        state.windows.delete(appId);
        const el = document.getElementById(`win_${appId}`);
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
        if(el){
          if(state.animations){
            el.classList.add('anim-close');
            el.addEventListener('animationend', ()=>{ el.remove(); }, { once:true });
          } else {
            el.remove();
          }
        }
      }
      function minimizeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.minimized = true;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          if(state.animations){
            const winRect = el.getBoundingClientRect();
            const taskbar = document.getElementById('taskbar');
            const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
            const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
            const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
            const dx = targetX - winRect.left;
            const dy = targetY - winRect.top;
            el.style.setProperty('--min-x', `${dx}px`);
            el.style.setProperty('--min-y', `${dy}px`);
            el.classList.add('anim-minimize');
            el.addEventListener('animationend', ()=>{
              el.classList.remove('anim-minimize');
              el.classList.add('hidden');
              el.style.removeProperty('--min-x');
              el.style.removeProperty('--min-y');
            }, { once:true });
          } else {
            el.classList.add('hidden');
          }
        }
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
      }

      function toggleFitWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        const winEl = document.getElementById(`win_${appId}`);
        if(!winEl) return;

        if(w.fit && w.prevRect){
          w.left = w.prevRect.left;
          w.top = w.prevRect.top;
          w.width = w.prevRect.width;
          w.height = w.prevRect.height;
          w.fit = false;
          w.prevRect = null;
          winEl.style.left = w.left + 'px';
          winEl.style.top = w.top + 'px';
          winEl.style.width = w.width + 'px';
          winEl.style.height = w.height + 'px';
          return;
        }

        const frame = winEl.querySelector('.frame');
        const content = winEl.querySelector('.content');
        if(!frame || !content) return;

        w.prevRect = { left: w.left, top: w.top, width: w.width, height: w.height };

        const frameRect = frame.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const extraW = frameRect.width - contentRect.width;
        const extraH = frameRect.height - contentRect.height;
        const targetContentW = Math.max(content.scrollWidth, content.clientWidth);
        const targetContentH = Math.max(content.scrollHeight, content.clientHeight);

        const area = $('#desktopArea').getBoundingClientRect();
        const maxW = Math.max(320, Math.floor(area.width));
        const maxH = Math.max(220, Math.floor(area.height));

        let newW = Math.ceil(targetContentW + extraW);
        let newH = Math.ceil(targetContentH + extraH);

        newW = clamp(newW, 280, maxW);
        newH = clamp(newH, 200, maxH);

        let newL = w.left;
        let newT = w.top;
        if(newL + newW > maxW) newL = Math.max(0, maxW - newW);
        if(newT + newH > maxH) newT = Math.max(0, maxH - newH);

        w.left = newL;
        w.top = newT;
        w.width = newW;
        w.height = newH;
        w.fit = true;

        winEl.style.left = newL + 'px';
        winEl.style.top = newT + 'px';
        winEl.style.width = newW + 'px';
        winEl.style.height = newH + 'px';
      }

      function getAppIdFromWindowEl(winEl){
        if(!winEl || !winEl.id) return null;
        if(winEl.id.startsWith('win_')) return winEl.id.slice(4);
        return winEl.dataset.appId || null;
      }

      function focusWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.z = ++state.zTop;
        state.activeWindowId = appId;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          el.style.zIndex = String(w.z);
          $$('.window').forEach(winEl=>{
            winEl.dataset.active = (winEl.id === `win_${appId}`) ? '1' : '0';
            const tb = winEl.querySelector('.titlebar');
            if(tb) tb.style.filter = (winEl.dataset.active==='1') ? 'none' : 'grayscale(0.35) brightness(0.9)';
          });
        }
        renderTaskButtons();
      }

      function installTouchFocusFix(){
        if(installTouchFocusFix._done) return;
        installTouchFocusFix._done = true;

        const isCoarse = window.matchMedia && window.matchMedia('(hover:none) and (pointer:coarse)').matches;

        // CAPTURE: runs before any handler that might stop propagation
        document.addEventListener('pointerdown', (e)=>{
          // Never touch desktop mouse
          if(e.pointerType === 'mouse') return;

          // If pointerType is empty/undefined (some Safari), treat as touch when coarse
          if(e.pointerType == null && !isCoarse) return;

          const winEl = e.target && e.target.closest ? e.target.closest('.window') : null;
          if(!winEl) return;

          const appId = getAppIdFromWindowEl(winEl);
          if(!appId) return;

          // Avoid extra work
          if(state.activeWindowId !== appId){
            focusWindow(appId);
          }
          // IMPORTANT: NOT calling preventDefault or stopping propagation
        }, true);

        // Fallback for browsers/states where pointer events fail
        document.addEventListener('touchstart', (e)=>{
          if(!isCoarse) return;
          const t = e.target;
          const winEl = t && t.closest ? t.closest('.window') : null;
          if(!winEl) return;
          const appId = getAppIdFromWindowEl(winEl);
          if(!appId) return;
          if(state.activeWindowId !== appId){
            focusWindow(appId);
          }
        }, { capture:true, passive:true });
      }

      function createWindowElement(wstate){
        const appId = wstate.id;
        const el = document.createElement('div');
        el.className = 'window';
        el.id = `win_${appId}`;
        el.style.left = wstate.left + 'px';
        el.style.top = wstate.top + 'px';
        el.style.width = wstate.width + 'px';
        el.style.height = wstate.height + 'px';
        el.style.zIndex = String(wstate.z);
        el.style.visibility = 'hidden';
        if(state.animations) el.classList.add('anim-open');

        const bodyHTML = (CONTENT[appId] ? CONTENT[appId]() : `<h2>${wstate.title}</h2><p>Sem conteúdo.</p>`);

        el.innerHTML = `
          <div class="frame bevel">
            <div class="titlebar" data-drag="1">
              <div class="title-left">
                <span style="width:16px;height:16px;display:inline-flex;">${wstate.iconFile ? `<img class="pixel" src="${wstate.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(wstate.icon)}</span>
                <strong>${wstate.title}</strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" title="${t('win.minimize')}" data-action="min">_</div>
                <div class="wctl bevel" title="${t('win.maximize')}" data-action="max">[]</div>
                <div class="wctl bevel" title="${t('win.close')}" data-action="close">×</div>
              </div>
            </div>
            ${appId === 'trash'
              ? `<div class="trash-actions">
                  <button class="btn bevel" type="button" data-trash-action="restore">${t('dialog.trash.restore')}</button>
                  <button class="btn bevel" type="button" data-trash-action="restoreAll">${t('dialog.trash.restoreAll')}</button>
                  <button class="btn bevel" type="button" data-trash-action="empty">${t('dialog.trash.emptyAction')}</button>
                  <button class="btn bevel" type="button" data-trash-action="help">${t('menu.help.controls')}</button>
                </div>`
              : `<div class="menubar">
                  <span data-menu="file" data-i18n="menubar.file">${t('menubar.file')}</span>
                  <span data-menu="edit" data-i18n="menubar.edit">${t('menubar.edit')}</span>
                  <span data-menu="view" data-i18n="menubar.view">${t('menubar.view')}</span>
                  <span data-menu="help" data-i18n="menubar.help">${t('menubar.help')}</span>
                </div>
                <div class="menu-drop hidden"></div>`}
            <div class="content">${bodyHTML}</div>
            <div class="statusbar">
              <span data-i18n="status.ready">${t('status.ready')}</span>
              <span class="status-center" data-i18n="about.footer">${t('about.footer')}</span>
              <span>BLISS 98</span>
            </div>
          </div>
          <div class="resize" title="${t('win.resize')}"></div>
        `;

        el.addEventListener('mousedown', (e)=>{ e.stopPropagation(); focusWindow(appId); closeStartMenu(); });
        el.addEventListener('click', (e)=>{
          const act = e.target?.dataset?.action;
          if(!act) return;
          e.stopPropagation();
          if(act==='close') closeApp(appId);
          if(act==='min') minimizeApp(appId);
          if(act==='max') toggleFitWindow(appId);
        });

        makeDraggable(el, appId);
        makeResizable(el, appId);

        if(appId === 'mediaplayer') { setTimeout(mpInitInWindow, 0); }
        if(appId === 'trash') { updateTrashIconUI(); }
        if(appId === 'clothes') { setTimeout(()=>initClothesWindow(el), 0); }
        if(appId === 'settings') { setTimeout(()=>initSettingsTabs(el), 0); }
        if(appId === 'games') { setTimeout(()=>initGamesWindow(el), 0); }
        if(appId === 'videos') { setTimeout(()=>initVideosWindow(el), 0); }

        $('#windows').appendChild(el);
        applyI18nTo(el);
        applyWindowState(el, appId);
        if(appId === 'trash') updateTrashIconUI();
        sizeWindowToContent(el, appId);
        el.style.visibility = 'visible';
        if(state.animations){
          el.addEventListener('animationend', ()=>{ el.classList.remove('anim-open'); }, { once:true });
        }
      }

      function makeDraggable(winEl, appId){
        const titlebar = winEl.querySelector('[data-drag="1"]');
        if(!titlebar) return;

        let dragging = false;
        let pointerId = null;
        let startX = 0, startY = 0, startL = 0, startT = 0;

        const onPointerDown = (e)=>{
          // Ignore non-primary mouse buttons
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Ignore clicks on window control buttons
          if(e.target && e.target.dataset && e.target.dataset.action) return;

          e.preventDefault();
          dragging = true;
          document.body.classList.add('dragging');
          pointerId = e.pointerId;

          // Focus window when starting drag
          try{ focusWindow(appId); } catch {}

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startL = rect.left;
          startT = rect.top;

          // Capture pointer so drag continues even if the finger leaves the titlebar
          try{ titlebar.setPointerCapture(pointerId); } catch {}

          titlebar.addEventListener('pointermove', onPointerMove);
          titlebar.addEventListener('pointerup', onPointerUp);
          titlebar.addEventListener('pointercancel', onPointerUp);
        };

        const onPointerMove = (e)=>{
          if(!dragging) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const newL = clamp(startL + dx - area.left, 0, area.width - 80);
          const newT = clamp(startT + dy - area.top, 0, area.height - 60);

          winEl.style.left = newL + 'px';
          winEl.style.top = newT + 'px';

          const w = state.windows.get(appId);
          if(w){ w.left = newL; w.top = newT; }
        };

        const onPointerUp = (e)=>{
          if(pointerId !== null && e.pointerId !== pointerId) return;

          dragging = false;
          pointerId = null;
          document.body.classList.remove('dragging');

          try{ titlebar.releasePointerCapture(e.pointerId); } catch {}

          titlebar.removeEventListener('pointermove', onPointerMove);
          titlebar.removeEventListener('pointerup', onPointerUp);
          titlebar.removeEventListener('pointercancel', onPointerUp);
        };

        // Pointer events handle mouse + touch + pen
        titlebar.addEventListener('pointerdown', onPointerDown);
      }

      function makeResizable(winEl, appId){
        const handle = winEl.querySelector('.resize');
        const EDGE = 6; // px

        let resizing = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let startW = 0, startH = 0;
        let startL = 0, startT = 0;
        let dir = '';

        function getDir(clientX, clientY){
          const r = winEl.getBoundingClientRect();
          const left = (clientX - r.left) <= EDGE;
          const right = (r.right - clientX) <= EDGE;
          const top = (clientY - r.top) <= EDGE;
          const bottom = (r.bottom - clientY) <= EDGE;

          let d = '';
          if(top) d += 'n';
          else if(bottom) d += 's';
          if(left) d += 'w';
          else if(right) d += 'e';
          return d;
        }

        function cursorFor(d){
          if(d === 'n' || d === 's') return 'ns-resize';
          if(d === 'e' || d === 'w') return 'ew-resize';
          if(d === 'ne' || d === 'sw') return 'nesw-resize';
          if(d === 'nw' || d === 'se') return 'nwse-resize';
          return '';
        }

        function beginResize(e, resizeDir){
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          e.preventDefault();

          resizing = true;
          pointerId = e.pointerId;
          dir = resizeDir;
          document.body.classList.add('dragging');
          const w = state.windows.get(appId);
          if(w){
            w.fit = false;
            w.prevRect = null;
          }

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startW = rect.width;
          startH = rect.height;
          startL = rect.left;
          startT = rect.top;

          try{ winEl.setPointerCapture(pointerId); } catch {}

          winEl.addEventListener('pointermove', onPointerMove);
          winEl.addEventListener('pointerup', onPointerUp);
          winEl.addEventListener('pointercancel', onPointerUp);
        }

        function onPointerMove(e){
          if(!resizing) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;
          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const MIN_W = 280;
          const MIN_H = 200;

          let newW = startW;
          let newH = startH;
          let newL = startL;
          let newT = startT;

          if(dir.includes('e')) newW = clamp(startW + dx, MIN_W, 920);
          if(dir.includes('s')) newH = clamp(startH + dy, MIN_H, 780);

          if(dir.includes('w')){
            newW = clamp(startW - dx, MIN_W, 920);
            newL = startL + (startW - newW);
          }
          if(dir.includes('n')){
            newH = clamp(startH - dy, MIN_H, 780);
            newT = startT + (startH - newH);
          }

          // Clamp to desktop bounds
          newL = clamp(newL - area.left, 0, area.width - 60) + area.left;
          newT = clamp(newT - area.top, 0, area.height - 40) + area.top;

          winEl.style.width = newW + 'px';
          winEl.style.height = newH + 'px';
          winEl.style.left = (newL - area.left) + 'px';
          winEl.style.top = (newT - area.top) + 'px';

          const w = state.windows.get(appId);
          if(w){
            w.width = newW;
            w.height = newH;
            w.left = (newL - area.left);
            w.top = (newT - area.top);
          }
        }

        function onPointerUp(e){
          if(pointerId !== null && e.pointerId !== pointerId) return;
          resizing = false;
          pointerId = null;
          dir = '';
          document.body.classList.remove('dragging');

          try{ winEl.releasePointerCapture(e.pointerId); } catch {}

          winEl.removeEventListener('pointermove', onPointerMove);
          winEl.removeEventListener('pointerup', onPointerUp);
          winEl.removeEventListener('pointercancel', onPointerUp);
        }

        // Mouse hover cursor change near edges
        winEl.addEventListener('mousemove', (e)=>{
          if(resizing) return;
          // don't override cursor on controls/titlebar
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          const c = cursorFor(d);
          winEl.style.cursor = c || '';
        });
        winEl.addEventListener('mouseleave', ()=>{
          if(!resizing) winEl.style.cursor = '';
        });

        // Edge/corner resize start
        winEl.addEventListener('pointerdown', (e)=>{
          if(resizing) return;
          // ignore titlebar drag and window control clicks
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          if(!d) return;
          beginResize(e, d);
        });

        // Keep the existing bottom-right handle resize too
        if(handle){
          handle.addEventListener('pointerdown', (e)=>{
            // If we already started edge resize, ignore
            if(resizing) return;
            beginResize(e, 'se');
          });
        }
      }

      function renderTaskButtons(){
        const host = $('#taskButtons');
        host.innerHTML = '';
        const wins = Array.from(state.windows.values()).sort((a,b)=>a.title.localeCompare(b.title));
        wins.forEach(w => {
          const b = document.createElement('div');
          b.className = 'btn bevel';
          const isActive = (state.activeWindowId === w.id && !w.minimized);
          if(isActive) b.classList.add('pressed');
          b.style.maxWidth = '240px';
          b.style.overflow = 'hidden';
          b.style.whiteSpace = 'nowrap';
          b.style.textOverflow = 'ellipsis';
          b.innerHTML = `
            <span style="width:16px;height:16px;display:inline-flex;">${w.iconFile ? `<img class="pixel" src="${w.iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${w.id}" />` : iconSVG(w.icon)}</span>
            <span>${w.title}</span>
          `;
          b.addEventListener('click', (e)=>{
            e.stopPropagation();
            closeStartMenu();
            if(w.minimized){
              w.minimized = false;
              const el = document.getElementById(`win_${w.id}`);
              if(el){
                el.classList.remove('hidden');
                if(state.animations){
                  const winRect = el.getBoundingClientRect();
                  const taskbar = document.getElementById('taskbar');
                  const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
                  const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
                  const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
                  const dx = targetX - winRect.left;
                  const dy = targetY - winRect.top;
                  el.style.setProperty('--min-x', `${dx}px`);
                  el.style.setProperty('--min-y', `${dy}px`);
                  el.classList.add('anim-restore');
                  el.addEventListener('animationend', ()=>{
                    el.classList.remove('anim-restore');
                    el.style.removeProperty('--min-x');
                    el.style.removeProperty('--min-y');
                  }, { once:true });
                }
              }
              focusWindow(w.id);
            } else if(state.activeWindowId === w.id){
              minimizeApp(w.id);
            } else {
              focusWindow(w.id);
            }
          });
          host.appendChild(b);
        });
      }

      function tickClock(){
        $('#clock').textContent = getDisplayTime();
        setTimeout(tickClock, 1000);
      }

      function enter(){
        const name = $('#username').value.trim();
        if(!name){
          showMessage('dialog.loginEmpty.title', 'dialog.loginEmpty.body');
          $('#username').focus();
          return;
        }
        state.didAutoPlayThisSession = false;
        setUser(name);
        showDesktop();
        if(!state.windows.has('mediaplayer')) openApp('mediaplayer');
        if(!state.windows.has('music')) openApp('music');
        setTimeout(()=>{ mpInitInWindow(); }, 0);
        schedulePlayerAutoplay();
      }

      $('#enter').addEventListener('click', enter);
      $('#username').addEventListener('keydown', (e)=>{ if(e.key==='Enter') enter(); });
      $('#langBtn').addEventListener('click', (e)=>{ e.preventDefault(); toggleLang(); });

      $('#clearProfile').addEventListener('click', ()=>{
        localStorage.removeItem('bliss98_user');
        $('#username').value = '';
        $('#username').focus();
      });

      document.addEventListener('keydown', (e)=>{
        if(e.key==='Escape'){
          closeStartMenu();
          closeCtxMenu();
          closeWindowMenu();
          closeModal();
        }
        if(snakeHandleKey(e)) return;
        if(e.key === 'Enter' && state.activeWindowId === 'poetry' && state.poetry.view === 'list' && state.poetry.selectedId){
          state.poetry.view = 'read';
          state.poetry.currentId = state.poetry.selectedId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        if(e.key === 'Enter' && state.activeWindowId === 'games' && state.games.view === 'list' && state.games.selectedId){
          openGameFromHub(state.games.selectedId);
        }

        // Keyboard context menu (Shift+F10)
        if(e.shiftKey && e.key === 'F10'){
          if($('#desktop').classList.contains('hidden')) return;
          e.preventDefault();
          const area = $('#desktopArea').getBoundingClientRect();
          openCtxMenu(area.left + area.width/2, area.top + area.height/2, 'desktop', null);
        }

        // Basic keyboard navigation inside context menu
        const menu = $('#ctxMenu');
        if(menu && !menu.classList.contains('hidden')){
          const items = Array.from(menu.querySelectorAll('.ctx-item'));
          const idx = items.indexOf(document.activeElement);
          if(e.key === 'ArrowDown'){
            e.preventDefault();
            const next = items[Math.min(items.length-1, Math.max(0, idx+1))] || items[0];
            if(next) next.focus();
          }
          if(e.key === 'ArrowUp'){
            e.preventDefault();
            const prev = items[Math.max(0, idx-1)] || items[items.length-1];
            if(prev) prev.focus();
          }
        }
      });
      document.addEventListener('click', (e)=>{
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem){
          const id = poemItem.dataset.poemId;
          if(e.detail > 1) return;
          selectPoetryItem(id);
          return;
        }
        const poemAction = e.target.closest && e.target.closest('[data-poetry-action]');
        if(poemAction && poemAction.dataset && poemAction.dataset.poetryAction){
          if(poemAction.dataset.poetryAction === 'back'){
            state.poetry.view = 'list';
            state.poetry.currentId = null;
            renderPoetryWindow();
          }
          if(poemAction.dataset.poetryAction === 'toggleLang'){
            state.poetry.readLang = (state.poetry.readLang === 'en') ? 'pt' : 'en';
            renderPoetryWindow();
          }
          return;
        }

        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem){
          const id = trashItem.dataset.trashId;
          if(e.ctrlKey || e.metaKey){
            if(state.trashSelection.has(id)) state.trashSelection.delete(id);
            else state.trashSelection.add(id);
          } else {
            state.trashSelection = new Set([id]);
          }
          renderTrashWindow();
          return;
        }

        const trashBtn = e.target.closest && e.target.closest('[data-trash-action]');
        if(trashBtn && trashBtn.dataset){
          const action = trashBtn.dataset.trashAction;
          if(action === 'help'){
            showMessage('dialog.controls.title', 'dialog.controls.body');
            return;
          }
          if(action === 'restore'){
            const ids = state.trashSelection.size ? Array.from(state.trashSelection) : [];
            if(ids.length){
              restoreFromTrash(ids);
              state.trashSelection = new Set();
            }
          }
          if(action === 'restoreAll'){
            restoreFromTrash(Array.from(state.trash));
            state.trashSelection = new Set();
          }
          if(action === 'empty'){
            emptyTrash();
            state.trashSelection = new Set();
          }
          return;
        }

        const modalAction = e.target.closest && e.target.closest('[data-modal-action]');
        if(modalAction && modalAction.dataset && modalAction.dataset.modalAction){
          const act = modalAction.dataset.modalAction;
          if(act === 'confirm' && typeof modalState.onConfirm === 'function'){
            const select = $('#modalSelect');
            const input = $('#modalInput');
            const value = input ? input.value : (select ? select.value : null);
            modalState.onConfirm(value);
          }
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modal'){
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modalClose'){
          closeModal();
          return;
        }

        const menuItem = e.target.closest && e.target.closest('[data-menu-action]');
        if(menuItem && menuItem.dataset && menuItem.dataset.menuAction){
          e.preventDefault();
          e.stopPropagation();
          handleMenuAction(menuItem.dataset.menuAction);
          closeWindowMenu();
          return;
        }
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          e.preventDefault();
          e.stopPropagation();
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          if(state.menuOpen && state.menuOpen.winId === getWindowId(winEl) && state.menuOpen.menuKey === menuKey){
            closeWindowMenu();
          } else {
            openWindowMenu(winEl, menuKey, menuToggle);
          }
          return;
        }

        const btn = e.target.closest && e.target.closest('[data-set-lang]');
        if(btn && btn.dataset && btn.dataset.setLang){
          setLang(btn.dataset.setLang);
        }
        const wpBtn = e.target.closest && e.target.closest('[data-set-wallpaper]');
        if(wpBtn && wpBtn.dataset && wpBtn.dataset.setWallpaper){
          applyWallpaper(wpBtn.dataset.setWallpaper);
        }
        const animBtn = e.target.closest && e.target.closest('[data-set-animations]');
        if(animBtn && animBtn.dataset && animBtn.dataset.setAnimations){
          setAnimations(animBtn.dataset.setAnimations === 'on');
        }
        const scanBtn = e.target.closest && e.target.closest('[data-set-scanlines]');
        if(scanBtn && scanBtn.dataset && scanBtn.dataset.setScanlines){
          setScanlines(scanBtn.dataset.setScanlines === 'on');
        }
        const darkBtn = e.target.closest && e.target.closest('[data-set-darkmode]');
        if(darkBtn && darkBtn.dataset && darkBtn.dataset.setDarkmode){
          setDarkMode(darkBtn.dataset.setDarkmode === 'on');
        }
        const retroBtn = e.target.closest && e.target.closest('[data-set-retro]');
        if(retroBtn && retroBtn.dataset && retroBtn.dataset.setRetro){
          setRetroGlow(retroBtn.dataset.setRetro === 'on');
        }
        const titleBtn = e.target.closest && e.target.closest('[data-set-titlebar]');
        if(titleBtn && titleBtn.dataset && titleBtn.dataset.setTitlebar){
          setTitlebarTheme(titleBtn.dataset.setTitlebar);
        }
        const themeBtn = e.target.closest && e.target.closest('[data-set-theme]');
        if(themeBtn && themeBtn.dataset && themeBtn.dataset.setTheme){
          setThemePreset(themeBtn.dataset.setTheme);
        }
        const themeCustomBtn = e.target.closest && e.target.closest('[data-theme-custom]');
        if(themeCustomBtn && themeCustomBtn.dataset && themeCustomBtn.dataset.themeCustom){
          const act = themeCustomBtn.dataset.themeCustom;
          if(act === 'save'){
            saveCustomThemeFromState();
          }
          if(act === 'load'){
            if(!themeCustomBtn.classList.contains('disabled')) applyCustomTheme();
          }
        }
        const gamesViewBtn = e.target.closest && e.target.closest('[data-games-view]');
        if(gamesViewBtn && gamesViewBtn.dataset && gamesViewBtn.dataset.gamesView){
          state.games.layout = gamesViewBtn.dataset.gamesView;
          saveGamesLayout();
          renderGamesWindow();
        }
        const gamesBigBtn = e.target.closest && e.target.closest('[data-games-big]');
        if(gamesBigBtn && gamesBigBtn.dataset && gamesBigBtn.dataset.gamesBig){
          state.games.bigIcons = !state.games.bigIcons;
          saveGamesBigIcons();
          renderGamesWindow();
        }
        const videosAction = e.target.closest && e.target.closest('[data-videos-action]');
        if(videosAction && videosAction.dataset && videosAction.dataset.videosAction){
          const act = videosAction.dataset.videosAction;
          if(act === 'openChannel'){
            renderVideoPlayer(null, null, { force:true });
          }
          if(act === 'addKey'){
            showInputDialog({
              titleKey: 'videos.keyTitle',
              descKey: 'videos.keyDesc',
              value: loadYouTubeApiKey(),
              confirmKey: 'common.save',
              onConfirm: (val)=>{
                const next = (val || '').trim();
                saveYouTubeApiKey(next);
                initVideosWindow();
              }
            });
          }
        }
        const videoItem = e.target.closest && e.target.closest('[data-video-id]');
        if(videoItem && videoItem.dataset && videoItem.dataset.videoId){
          state.videos.selectedId = videoItem.dataset.videoId;
          renderVideoPlayer(null, state.videos.selectedId, { force:true });
          renderVideosList(null, state.videos.items);
          return;
        }
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard){
          if(musicCard.dataset && musicCard.dataset.touchOpened === '1'){
            delete musicCard.dataset.touchOpened;
            return;
          }
          const id = musicCard.dataset.musicId;
          if(e.ctrlKey || e.metaKey){
            if(state.music.selected.has(id)) state.music.selected.delete(id);
            else state.music.selected.add(id);
          } else {
            state.music.selected = new Set([id]);
          }
          applyMusicState();
          return;
        }

        const ctxBtn = e.target.closest && e.target.closest('[data-ctx-action]');
        if(ctxBtn && ctxBtn.dataset && ctxBtn.dataset.ctxAction){
          e.preventDefault();
          e.stopPropagation();
          handleCtxAction(ctxBtn.dataset.ctxAction);
          closeCtxMenu();
        }
        if(!e.target.closest || (!e.target.closest('.menu-drop') && !e.target.closest('.menubar'))){
          closeWindowMenu();
        }
      });

      (function init(){
        const savedLang = localStorage.getItem('bliss98_lang') || 'en';
        state.lang = (savedLang === 'pt') ? 'pt' : 'en';

        const saved = localStorage.getItem('bliss98_user');
        if(saved){ setUser(saved); $('#username').value = saved; }

        state.gridSnap = loadGridSnap();
        state.wallpaper = loadWallpaper();
        state.animations = loadAnimations();
        state.settings.scanlines = loadScanlines();
        state.settings.darkMode = loadDarkMode();
        state.settings.retroGlow = loadRetroGlow();
        state.theme.preset = loadThemePreset();
        state.theme.titlebar = loadTitlebarTheme();
        if(state.theme.titlebar === 'transparent') state.theme.titlebar = 'blank';
        const customTheme = loadCustomTheme();
        state.theme.palette = (state.theme.preset === 'xp98') ? 'xp98' : 'default';
        if(state.theme.preset === 'custom' && customTheme && customTheme.palette){
          state.theme.palette = customTheme.palette;
        }
        state.games.layout = loadGamesLayout();
        state.games.bigIcons = loadGamesBigIcons();
        state.folders = loadFolders();
        state.snake.highScore = loadSnakeHighScore();
        state.trash = new Set(loadTrash());
        state.iconLabels = loadIconLabels();
        state.trashSelection = new Set();

        if(state.theme.preset && state.theme.preset !== 'custom'){
          setThemePreset(state.theme.preset, { init:true });
        } else {
          applyThemePalette();
          applyTitlebarTheme();
        }

        // Apply translations immediately (default is English)
        applyI18n();
        applyDarkMode();
        applyScanlines();
        applyRetroGlow();
        updateTrashIconUI();

        initSfx();
        installTouchFocusFix();
        showLogin(true);
        document.addEventListener('click', ()=>{ closeStartMenu(); closeCtxMenu(); });
        const cm = $('#ctxMenu');
        if(cm){
          cm.addEventListener('click', (ev)=>{
            const btn = ev.target.closest && ev.target.closest('[data-ctx-action]');
            if(btn && btn.dataset && btn.dataset.ctxAction){
              ev.preventDefault();
              ev.stopPropagation();
              handleCtxAction(btn.dataset.ctxAction);
              closeCtxMenu();
              return;
            }
            // Prevent clicks inside the menu from bubbling to the document closer
            ev.stopPropagation();
          });
        }
      })();
    </script>
  </body>
</html>
