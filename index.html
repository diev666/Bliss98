<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BLISS 98</title>
    <style>
      :root{
        --bg:#008080;
        --shadow-dark:#0a0a0a;
        --shadow-mid:#808080;
        --shadow-light:#dfdfdf;
        --shadow-white:#ffffff;
        --title:#000080;
        --title2:#1084d0;
        --task:#c0c0c0;
        --text:#000;
        --menu:#c0c0c0;
        --select:#000080;
      }

      html,body{height:100%;margin:0;}
      body{
        background:var(--bg);
        color:var(--text);
        font-family:"MS Sans Serif", Tahoma, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        font-size:13px;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        -webkit-touch-callout:none;
        -webkit-tap-highlight-color: transparent;
      }
      .hidden{display:none !important;}
      .pixel{image-rendering:pixelated; image-rendering:crisp-edges;}

      .bevel{
        background:var(--task);
        border-top:2px solid var(--shadow-white);
        border-left:2px solid var(--shadow-white);
        border-right:2px solid var(--shadow-dark);
        border-bottom:2px solid var(--shadow-dark);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .bevel-in{
        background:#fff;
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .btn{
        height:24px;
        padding:0 10px;
        display:inline-flex;
        align-items:center;
        gap:6px;
        cursor:pointer;
      }
      .btn:active{ filter:brightness(0.97); }
      .btn.pressed{
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }

      #app{height:100%;}

      #login{
        position:absolute; inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:radial-gradient(circle at 40% 35%, rgba(255,255,255,.15), rgba(255,255,255,0) 45%), var(--bg);
      }
      .login-panel{
        width:min(520px, calc(100% - 32px));
        padding:14px;
      }
      .login-title{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        margin-bottom:10px;
      }
      .login-left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .lang-btn{
        min-width:70px;
        justify-content:center;
        font-weight:700;
      }
      .logo{ width:34px; height:34px; }
      .login-title h1{
        font-size:18px;
        margin:0;
        letter-spacing:0.2px;
      }
      .login-sub{opacity:.9;margin:2px 0 0 0;}
      .field-row{display:flex; gap:8px; align-items:center; margin-top:12px;}
      label{white-space:nowrap;}
      input[type="text"]{
        flex:1;
        height:26px;
        padding:0 8px;
        outline:none;
      }
      .login-footer{display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:10px;}
      .tiny{font-size:12px; opacity:.85; user-select:text;}
      .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:#fff; padding:1px 5px; border:1px solid #999;}

      #desktop{ position:absolute; inset:0; background:var(--bg); }
      .desktop-area{
        position:absolute; inset:0 0 30px 0;
        padding:10px;
      }

      .icons{
        position:relative;
        width:100%;
        height:100%;
      }
      .icon{
        position:absolute;
        width:92px;
        height:88px;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        gap:6px;
        padding:6px 4px;
        border:1px solid transparent;
        cursor:default;
      }
      .icon.selected{
        border:1px dotted rgba(255,255,255,0.9);
        background:rgba(0,0,0,0.12);
      }
      .icon span{
        color:#fff;
        text-align:center;
        line-height:1.1;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.65);
        padding:1px 2px;
        max-width:86px;
        word-break:break-word;
      }
      .icon.selected span{
        background:rgba(0,0,128,0.9);
        outline:1px dotted #fff;
      }
      .icon.trashed{
        opacity:0.65;
      }
      .wallpaper-swatch{
        width:18px;
        height:18px;
        border:1px solid #000;
        box-shadow: inset 1px 1px 0 rgba(255,255,255,0.35);
      }

      .taskbar{
        position:absolute;
        left:0; right:0; bottom:0;
        height:30px;
        display:flex;
        align-items:center;
        gap:6px;
        padding:2px 6px;
      }
      .task-left{display:flex; align-items:center; gap:6px;}
      .task-buttons{
        display:flex;
        align-items:center;
        gap:4px;
        flex:1;
        overflow:auto hidden;
        padding:0 6px;
      }
      .task-buttons::-webkit-scrollbar{height:8px;}
      .task-buttons::-webkit-scrollbar-thumb{background:#9a9a9a;}
      .task-right{ display:flex; align-items:center; gap:8px; }
      .tray{
        height:24px;
        display:flex;
        align-items:center;
        padding:0 8px;
      }
      .clock{min-width:72px; text-align:right; font-variant-numeric:tabular-nums;}

      .start-menu{
        position:absolute;
        left:6px;
        bottom:32px;
        width:260px;
        display:flex;
        padding:0;
      }
      .start-side{
        width:30px;
        background:linear-gradient(#000080, #000);
        color:#fff;
        display:flex;
        align-items:flex-end;
        justify-content:center;
        padding:8px 0;
      }
      .start-side span{
        writing-mode:vertical-rl;
        transform:rotate(180deg);
        letter-spacing:1px;
        font-weight:700;
      }
      .start-list{ flex:1; padding:2px; }
      .start-list .menu-item{
        width:100%;
        box-sizing:border-box;
        overflow:hidden;
      }
      .start-list .menu-item > div:last-child{
        flex:1;
        min-width:0;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }
      .menu-item{
        display:flex;
        align-items:center;
        gap:10px;
        padding:6px 8px;
        cursor:pointer;
      }
      .menu-item:hover{
        background:var(--select);
        color:#fff;
      }
      .menu-sep{height:1px; background:#9a9a9a; margin:2px 0;}
      /* Desktop context menu (Win98 style) */
.ctx-menu{
  position:absolute;
  min-width:220px;
  padding:2px;
  z-index:9999;
}
.ctx-item{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:6px 8px;
  background:transparent;
  border:0;
  font:inherit;
  color:inherit;
  cursor:pointer;
  text-align:left;
}
.ctx-item:hover,
.ctx-item:focus{
  background:var(--select);
  color:#fff;
  outline:none;
}
.ctx-left{display:flex; align-items:center; gap:10px;}
.ctx-sep{height:1px; background:#9a9a9a; margin:2px 0;}
.ctx-check{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  opacity:.95;
}
.ctx-shortcut{opacity:.85; font-size:12px;}
.ctx-item:hover .ctx-shortcut,
.ctx-item:focus .ctx-shortcut{opacity:1;}

@media (max-width: 720px){
  .ctx-menu{min-width:200px;}
  .ctx-item{padding:10px 10px;}
}

      .window{ position:absolute; min-width:320px; min-height:220px; }
      .window.anim-open{
        animation:winOpen 160ms ease-out;
        transform-origin:top left;
      }
      .window.anim-close{
        animation:winClose 140ms ease-in forwards;
        transform-origin:top left;
        pointer-events:none;
      }
      .window.anim-minimize{
        animation:winMinimize 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window.anim-restore{
        animation:winRestore 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window .frame{height:100%; display:flex; flex-direction:column;}
      .titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 3px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:#fff;
        cursor:move;
        touch-action:none;
      }
      .title-left{display:flex; align-items:center; gap:6px;}
      .title-left strong{font-weight:700; font-size:12px;}
      .title-controls{display:flex; gap:4px;}
      .wctl{
        width:18px; height:18px;
        display:flex; align-items:center; justify-content:center;
        cursor:pointer;
        font-size:12px;
        line-height:1;
      }
      .menubar{
        height:22px;
        display:flex;
        align-items:center;
        gap:14px;
        padding:0 8px;
        background:var(--task);
        border-bottom:1px solid #9a9a9a;
        user-select:none;
      }
      .menubar span{
        cursor:default;
        padding:0 6px;
      }
      .menubar span.active{
        background:#000080;
        color:#fff;
      }
      .menu-drop{
        position:absolute;
        min-width:190px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:5;
      }
      .menu-drop.hidden{display:none;}
      .menu-item{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        width:100%;
        padding:4px 8px;
        background:transparent;
        border:0;
        text-align:left;
        font:inherit;
        cursor:default;
        position:relative;
      }
      .menu-item:hover,
      .menu-item:focus{
        background:#000080;
        color:#fff;
        outline:none;
      }
      .menu-left{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .menu-check{
        width:16px;
        display:inline-flex;
        justify-content:center;
      }
      .menu-right{
        min-width:16px;
        text-align:right;
      }
      .menu-sep{
        height:1px;
        background:#9a9a9a;
        margin:2px 0;
      }
      .menu-item.has-sub:hover > .menu-sub,
      .menu-item.has-sub:focus-within > .menu-sub{
        display:block;
      }
      .menu-sub{
        position:absolute;
        top:-4px;
        left:100%;
        margin-left:2px;
        display:none;
        min-width:180px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:6;
      }
      .content{
        flex:1;
        padding:10px;
        overflow:auto;
        background:#fff;
        color:#000;
        user-select:text;
        -webkit-user-select:text;
      }
      .content.trash-empty{
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
      }
      .trash-actions{
        display:flex;
        align-items:center;
        gap:8px;
        padding:2px 8px;
        height:auto;
        background:var(--task);
        border-bottom:1px solid #9a9a9a;
        flex-wrap:wrap;
      }
      .trash-actions .btn{
        height:20px;
        padding:0 8px;
        white-space:nowrap;
      }
      @media (max-width: 420px){
        .trash-actions .btn{
          height:auto;
          line-height:1.1;
          white-space:normal;
          padding:2px 6px;
          flex:1 1 45%;
          min-width:120px;
        }
      }
      .content h2{margin:0 0 8px 0; font-size:16px;}
      .content p{margin:0 0 10px 0; line-height:1.35;}
      .content .card{ padding:10px; margin:10px 0; }
      .content a{color:#0000ee;}
      .statusbar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:0 8px;
        background:var(--task);
        border-top:1px solid #9a9a9a;
        font-size:12px;
        position:relative;
      }
      .status-center{
        position:absolute;
        left:50%;
        transform:translateX(-50%);
        pointer-events:none;
      }

      .resize{
        position:absolute;
        width:14px; height:14px;
        right:2px; bottom:2px;
        cursor:nwse-resize;
        background:conic-gradient(from 225deg, #0000 0 25%, #666 0 35%, #0000 0 50%, #666 0 60%, #0000 0 75%, #666 0 85%, #0000 0 100%);
        opacity:.55;
        touch-action:none;
      }

      /* Desktop selection box (Win98-like) */
      .rubberband{
        position:absolute;
        pointer-events:none;
        border:1px dotted #ffffff;
        background:rgba(0,0,128,0.18);
        box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset;
      }

      /* While dragging/resizing/selecting, hard-disable selection everywhere */
      body.dragging, body.dragging *{
        user-select:none !important;
        -webkit-user-select:none !important;
      }

      /* Keep normal selection inside content and inputs */
      .content, .content *{
        user-select:text;
        -webkit-user-select:text;
      }
      input, textarea{
        user-select:text;
        -webkit-user-select:text;
      }

      .hr98{height:1px; background:#b0b0b0; border-bottom:1px solid #fff; margin:10px 0;}
      .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
      .list98{padding-left:18px; margin:0;}
      .tag{
        display:inline-block;
        padding:1px 6px;
        border:1px solid #999;
        background:#f2f2f2;
        margin-right:6px;
        font-size:12px;
      }
      .music-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .music-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        width:92px;
        max-width:92px;
        padding:6px 4px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
      }
      .music-item.selected{
        border:1px dotted #000080;
        background:#d6e6ff;
      }
      .music-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .music-small .music-item{padding:6px; gap:6px;}
      .music-small .music-label{font-size:12px;}
      .music-hide-icons .music-icon{display:none;}
      .games-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .games-item{
        background:transparent;
        border:1px solid transparent;
        width:92px;
        max-width:92px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:default;
      }
      .games-item.selected{
        border:1px dotted #000080;
        background:#d6e6ff;
      }
      .games-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .snake-layout{
        display:flex;
        gap:12px;
        flex-wrap:wrap;
        align-items:stretch;
      }
      .snake-board{
        flex:1 1 260px;
        min-width:220px;
        min-height:240px;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        padding:8px;
        background:#fff;
      }
      .snake-side{
        width:200px;
        min-width:180px;
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .snake-controls{
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .snake-controls .btn{
        justify-content:center;
      }
      .snake-speed{
        display:flex;
        flex-direction:column;
        gap:4px;
      }
      .snake-speed select{
        height:24px;
      }
      .snake-overlay{
        position:absolute;
        inset:8px;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(233,233,233,0.85);
      }
      .snake-overlay-box{
        display:flex;
        flex-direction:column;
        gap:8px;
        padding:10px 12px;
        min-width:160px;
        text-align:center;
      }
      .snake-instructions{
        line-height:1.3;
      }
      @media (max-width: 520px){
        .music-grid{
          grid-template-columns:1fr;
        }
        .music-item{
          width:100%;
          max-width:100%;
          flex-direction:row;
          justify-content:flex-start;
        }
        .music-item span{
          max-width:none;
          text-align:left;
        }
        .games-grid{
          grid-template-columns:repeat(2, minmax(0, 1fr));
        }
        .games-item{
          width:100%;
          max-width:100%;
        }
        .snake-side{
          width:100%;
          min-width:0;
        }
      }
      .settings-shell{
        display:flex;
        flex-direction:column;
        gap:0;
      }
      .settings-tabs{
        display:flex;
        gap:4px;
        padding:4px 6px 0;
        overflow-x:auto;
        -webkit-overflow-scrolling:touch;
      }
      .settings-tab{
        padding:4px 10px;
        background:#c0c0c0;
        border:1px solid #808080;
        border-bottom:none;
        cursor:pointer;
        white-space:nowrap;
      }
      .settings-tab[aria-selected="true"]{
        background:#e9e9e9;
        position:relative;
        top:1px;
        z-index:1;
      }
      .settings-panels{
        padding:0 6px 6px;
      }
      .settings-panel{
        display:none;
        padding:12px;
        background:#e9e9e9;
        border:1px solid #808080;
        box-shadow:inset 1px 1px #fff, inset -1px -1px #404040;
        min-height:200px;
      }
      .settings-panel.active{display:block;}
      .settings-general{
        display:flex;
        gap:14px;
        flex-wrap:wrap;
        align-items:flex-start;
      }
      .settings-panel-header{
        display:flex;
        align-items:center;
        gap:10px;
        margin-bottom:10px;
      }
      .settings-panel-icon{
        width:48px;
        height:48px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:1px solid #808080;
        box-shadow:inset 1px 1px #fff, inset -1px -1px #404040;
        background:#e9e9e9;
        flex-shrink:0;
      }
      .settings-panel-icon img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .settings-logo{
        width:96px;
        height:72px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:2px solid #808080;
        box-shadow:inset 1px 1px #fff, inset -1px -1px #404040;
        background:#e9e9e9;
      }
      .settings-logo img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .settings-summary{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .settings-block{
        margin-top:8px;
        padding-top:8px;
        border-top:1px solid #b0b0b0;
      }
      .settings-actions{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
      }
      @media (max-width: 520px){
        .settings-general{flex-direction:column;}
        .settings-logo{width:100%; height:72px;}
        .settings-panel-header{align-items:flex-start;}
      }
      .clothes-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap:12px;
        align-items:start;
      }
      .clothes-item{
        display:flex;
        align-items:center;
        justify-content:center;
        padding:6px;
        border:1px solid transparent;
        background:transparent;
      }
      .clothes-item:focus,
      .clothes-item:focus-visible{
        outline:1px dotted #000080;
        background:#d6e6ff;
      }
      .clothes-thumb{
        width:100%;
        height:auto;
        aspect-ratio:1/1;
        object-fit:cover;
        border:1px solid #777;
        background:#fff;
        display:block;
      }
      .clothes-status{
        margin-top:10px;
      }
      @media (max-width: 520px){
        .clothes-grid{
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .poetry-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        justify-items:start;
      }
      .poetry-item{
        background:transparent;
        border:1px solid transparent;
        width:92px;
        max-width:92px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:default;
      }
      .poetry-item.selected{
        border:1px dotted #000080;
        background:#d6e6ff;
      }
      .poetry-item span{
        text-align:center;
        line-height:1.1;
        max-width:110px;
        word-break:break-word;
      }
      .poem-body{
        white-space:pre-line;
        line-height:1.4;
      }
      .trash-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .trash-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        width:92px;
        max-width:92px;
        padding:6px 4px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
      }
      .trash-item.selected{
        border:1px dotted #000080;
        background:#d6e6ff;
      }
      .trash-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .trash-empty-msg{
        font-weight:700;
      }
      .mp-compact .content{padding:6px;}
      .mp-compact .card{padding:6px;}
      .mp-hide-list #mpList,
      .mp-hide-list #mpMsg{display:none;}
      .mp-item.selected{
        outline:1px dotted #000080;
        background:#d6e6ff;
      }
      .diev-small .content{font-size:12px;}
      .diev-large .content{font-size:15px;}
      .diev-contrast .content{
        background:#000;
        color:#fff;
      }
      .diev-contrast .content a{color:#9ad0ff;}
      .art-zoom-50 .content{font-size:12px;}
      .art-zoom-100 .content{font-size:13px;}
      .art-zoom-200 .content{font-size:16px;}
      body.scanlines::before{
        content:"";
        position:fixed;
        inset:0;
        background:repeating-linear-gradient(
          0deg,
          rgba(0,0,0,0.15) 0,
          rgba(0,0,0,0.15) 1px,
          rgba(255,255,255,0) 2px,
          rgba(255,255,255,0) 3px
        );
        pointer-events:none;
        z-index:9999;
      }
      .modal{
        position:fixed;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(0,0,0,0.25);
        z-index:9998;
        padding:12px;
        box-sizing:border-box;
        overflow:auto;
      }
      .modal.hidden{display:none;}
      .modal-box{
        min-width:280px;
        max-width:520px;
        width:100%;
        max-height:calc(100% - 12px);
        display:flex;
        flex-direction:column;
      }
      .modal-titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 4px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:#fff;
      }
      .modal-body{
        padding:10px;
        background:#fff;
        color:#000;
        overflow:auto;
        max-height:calc(100% - 72px);
      }
      .modal-body input,
      .modal-body select{
        max-width:100%;
        box-sizing:border-box;
      }
      .modal-actions{
        display:flex;
        justify-content:flex-end;
        gap:8px;
        padding:10px;
        background:var(--task);
        border-top:1px solid #9a9a9a;
      }
      @keyframes winOpen{
        from{opacity:0; transform:scale(0.98);}
        to{opacity:1; transform:scale(1);}
      }
      @keyframes winClose{
        from{opacity:1; transform:scale(1);}
        to{opacity:0; transform:scale(0.96);}
      }
      @keyframes winMinimize{
        0%{opacity:1; transform:translate(0,0) scale(1);}
        100%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
      }
      @keyframes winRestore{
        0%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
        100%{opacity:1; transform:translate(0,0) scale(1);}
      }

      @media (max-width: 720px){
        .icons{grid-template-rows: repeat(5, 88px);}
        .window{min-width:280px;}
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="login">
        <div class="login-panel bevel">
          <div class="login-title">
            <div class="login-left">
              <img class="logo pixel" src="/assets/icons/bliss.png" width="34" height="34" alt="" style="display:block;" />
              <div>
                <h1>BLISS 98</h1>
                <p class="login-sub" data-i18n="login.sub">Enter your name to login</p>
              </div>
            </div>
            <button id="langBtn" class="btn bevel lang-btn" type="button" aria-label="Language" data-i18n-aria="aria.language">
              EN
            </button>
          </div>

          <div class="bevel-in" style="padding:12px;">
            <div class="field-row">
              <label for="username" data-i18n="login.labelName">Name:</label>
              <input id="username" class="bevel-in" type="text" autocomplete="name" placeholder="Enter your name" data-i18n-placeholder="login.placeholder" />
            </div>

            <div class="login-footer">
              <div class="tiny" data-i18n="login.hint">Hint: Ignorance is BLISS</div>
              <div style="display:flex; gap:6px;">
                <button id="clearProfile" class="btn bevel" type="button" data-i18n="login.clear">Clear</button>
                <button id="enter" class="btn bevel" type="button"><strong data-i18n="login.enter">Enter</strong></button>
              </div>
            </div>
          </div>

          <div class="tiny" style="margin-top:10px; opacity:.9;">
            <span data-i18n="login.copyright">© BLISS / DIEV — Bliss 98 OS</span>
          </div>
        </div>
      </div>

      <div id="desktop" class="hidden">
        <div class="desktop-area" id="desktopArea">
          <div class="icons" id="iconGrid"></div>
          <div id="windows"></div>
          <div id="rubberband" class="rubberband hidden"></div>
        </div>

        <div class="taskbar bevel" id="taskbar">
          <div class="task-left">
            <div id="startBtn" class="btn bevel" title="Menu" data-i18n-title="start.menu">
              <img class="pixel" src="/assets/icons/bliss.png" width="16" height="16" alt="" style="display:block;" />
              <strong>Bliss</strong>
            </div>
          </div>

          <div class="task-buttons" id="taskButtons"></div>

          <div class="task-right">
            <div class="tray bevel">
              <span id="who" style="margin-right:10px;"></span>
              <span class="clock" id="clock"></span>
            </div>
          </div>
        </div>

        <div id="startMenu" class="start-menu bevel hidden" role="menu" aria-label="Menu Bliss" data-i18n-aria="aria.startMenu">
          <div class="start-side"><span>BLISS 98</span></div>
          <div class="start-list" id="startList"></div>
        </div>

        <!-- Desktop context menu -->
        <div id="ctxMenu" class="ctx-menu bevel hidden" role="menu" aria-label="Context menu" data-i18n-aria="aria.contextMenu">
          <!-- items injected by JS -->
        </div>

        <div id="modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
          <div class="modal-box bevel">
            <div class="modal-titlebar">
              <div class="title-left">
                <strong id="modalTitle"></strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" id="modalClose" aria-label="Close" data-i18n-aria="aria.close">×</div>
              </div>
            </div>
            <div class="modal-body" id="modalBody"></div>
            <div class="modal-actions" id="modalActions"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      const state = {
        user: null,
        windows: new Map(),
        zTop: 10,
        activeWindowId: null,
        selectedIconId: null,
        lang: 'en',
        wallpaper: 'classic',
        animations: true,
        music: {
          selected: new Set(),
          tileSize: 'large',
          openNewTab: true,
          showIcons: true,
        },
        mediaplayer: {
          selected: new Set(),
          shuffle: false,
          repeat: 'off',
          showPlaylist: true,
          compact: false,
        },
        diev: {
          textSize: 'normal',
          highContrast: false,
        },
        videos: {
          openNewTab: true,
          thumbSize: 'large',
        },
        art: {
          zoom: 100,
        },
        settings: {
          scanlines: false,
          tab: 'general',
        },
        games: {
          view: 'list',
          selectedId: null,
        },
        snake: {
          speed: 'normal',
          highScore: 0,
        },
        trash: new Set(),
        iconLabels: {},
        trashSelection: new Set(),
        poetry: {
          view: 'list',
          selectedId: null,
          currentId: null,
          readLang: 'en',
        },
        menuOpen: null,
        gridSnap: true,
      };

      const ICON_POS_KEY = 'bliss98_icon_positions';
      const ICON_SIZE = { w: 92, h: 88 };
      const ICON_GAP = { x: 12, y: 8 };
      const WALLPAPER_KEY = 'bliss98_wallpaper';
      const ANIMATIONS_KEY = 'bliss98_animations';
      const SCANLINES_KEY = 'bliss98_scanlines';
      const TRASH_KEY = 'bliss98_trash';
      const ICON_LABELS_KEY = 'bliss98_icon_labels';
      const CLOTHES_CACHE_KEY = 'bliss98_clothes_cache';
      const CLOTHES_CACHE_TTL = 1000 * 60 * 60 * 3;
      const SNAKE_HIGH_KEY = 'bliss98_snake_highscore';
      const SFX = {
        boot: {
          src: '/assets/audio/boot.mp3',
          audio: null,
          played: false,
          pending: false,
          unlockArmed: false,
          playing: false,
        },
        logoff: {
          src: '/assets/audio/logoff.mp3',
          audio: null,
          playing: false,
        }
      };
      const WALLPAPERS = [
        {
          id: 'classic',
          labelKey: 'wallpaper.classic',
          background: '#008080',
          size: 'auto',
          repeat: 'repeat'
        },
        {
          id: 'bliss',
          labelKey: 'wallpaper.bliss',
          background: 'radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'clouds',
          labelKey: 'wallpaper.clouds',
          background: 'linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'diev',
          labelKey: 'wallpaper.diev',
          background: 'repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), linear-gradient(135deg, #0a2333, #114b6a)',
          size: 'auto',
          repeat: 'repeat'
        },
      ];

      function initSfx(){
        Object.values(SFX).forEach(entry => {
          entry.audio = new Audio(entry.src);
          entry.audio.preload = 'auto';
          entry.audio.volume = 0.5;
        });
      }

      function playSfx(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        try{
          entry.audio.currentTime = 0;
          const p = entry.audio.play();
          if(p && typeof p.then === 'function'){
            return p.then(()=>{
              entry.playing = false;
              return true;
            }).catch(()=>{
              entry.playing = false;
              return false;
            });
          }
          entry.playing = false;
          return Promise.resolve(true);
        } catch {
          entry.playing = false;
          return Promise.resolve(false);
        }
      }

      function playSfxOnce(name, opts = {}){
        const entry = SFX[name];
        if(!entry || entry.played) return Promise.resolve(false);
        return playSfx(name).then((ok)=>{
          if(ok){
            entry.played = true;
            entry.pending = false;
          } else if(opts.allowPending){
            entry.pending = true;
          }
          return ok;
        });
      }

      function playSfxAndWait(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        return new Promise(resolve => {
          const audio = entry.audio;
          const cleanup = ()=>{
            audio.removeEventListener('ended', onEnd);
            audio.removeEventListener('error', onError);
          };
          const onEnd = ()=>{
            cleanup();
            entry.playing = false;
            resolve(true);
          };
          const onError = ()=>{
            cleanup();
            entry.playing = false;
            resolve(false);
          };
          audio.addEventListener('ended', onEnd, { once: true });
          audio.addEventListener('error', onError, { once: true });
          try{
            audio.currentTime = 0;
            const p = audio.play();
            if(p && typeof p.then === 'function'){
              p.catch(()=>{ onError(); });
            }
          } catch {
            onError();
          }
        });
      }

      function armBootUnlock(){
        const entry = SFX.boot;
        if(!entry || entry.played || !entry.pending || entry.unlockArmed) return;
        entry.unlockArmed = true;
        const loginEl = $('#login');
        if(!loginEl){
          entry.unlockArmed = false;
          return;
        }
        const handler = ()=>{
          if($('#login').classList.contains('hidden')){
            entry.pending = false;
            entry.unlockArmed = false;
            return;
          }
          playSfxOnce('boot').finally(()=>{
            entry.pending = false;
            entry.unlockArmed = false;
          });
        };
        const wrapped = ()=>{
          loginEl.removeEventListener('pointerdown', wrapped, true);
          loginEl.removeEventListener('keydown', wrapped, true);
          handler();
        };
        loginEl.addEventListener('pointerdown', wrapped, true);
        loginEl.addEventListener('keydown', wrapped, true);
      }

      function loadIconPositions(){
        try{
          const raw = localStorage.getItem(ICON_POS_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch {
          return {};
        }
      }

      function saveIconPositions(pos){
        try{
          localStorage.setItem(ICON_POS_KEY, JSON.stringify(pos));
        } catch {}
      }

      function legacyDefaultIconPos(index){
        // Layout similar to the old grid: 6 rows then new column
        const rows = 6;
        const col = Math.floor(index / rows);
        const row = index % rows;
        return {
          x: col * (ICON_SIZE.w + ICON_GAP.x),
          y: row * (ICON_SIZE.h + ICON_GAP.y)
        };
      }

      function clampIconPos(x, y){
        const area = $('#desktopArea').getBoundingClientRect();
        const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
        const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));
        return {
          x: clamp(Math.floor(x), 0, maxX),
          y: clamp(Math.floor(y), 0, maxY)
        };
      }
      const GRID_SNAP_KEY = 'bliss98_grid_snap';

function loadGridSnap(){
  try{
    const raw = localStorage.getItem(GRID_SNAP_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveGridSnap(){
  try{
    localStorage.setItem(GRID_SNAP_KEY, state.gridSnap ? '1' : '0');
  } catch {}
}

function snapToGrid(x, y){
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const sx = Math.round(x / stepX) * stepX;
  const sy = Math.round(y / stepY) * stepY;
  return clampIconPos(sx, sy);
}

function getGridMetrics(){
  const area = $('#desktopArea').getBoundingClientRect();
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const cols = Math.max(1, Math.floor((area.width - 6) / stepX));
  const rows = Math.max(1, Math.floor((area.height - 6) / stepY));
  return { stepX, stepY, cols, rows };
}

function snapToGridClamped(x, y, metrics){
  const snapped = snapToGrid(x, y);
  const maxX = (metrics.cols - 1) * metrics.stepX;
  const maxY = (metrics.rows - 1) * metrics.stepY;
  return {
    x: clamp(snapped.x, 0, maxX),
    y: clamp(snapped.y, 0, maxY)
  };
}

function gridCellFromPos(x, y, metrics){
  return {
    col: clamp(Math.round(x / metrics.stepX), 0, metrics.cols - 1),
    row: clamp(Math.round(y / metrics.stepY), 0, metrics.rows - 1)
  };
}

function gridPosFromCell(cell, metrics){
  return { x: cell.col * metrics.stepX, y: cell.row * metrics.stepY };
}

function findFreeCell(startCell, occupied, metrics){
  const total = metrics.cols * metrics.rows;
  const startIdx = startCell.row * metrics.cols + startCell.col;
  for(let i = 0; i < total; i++){
    const idx = (startIdx + i) % total;
    const col = idx % metrics.cols;
    const row = Math.floor(idx / metrics.cols);
    const key = `${col},${row}`;
    if(!occupied.has(key)){
      return { col, row };
    }
  }
  return startCell;
}

function placeOnFreeCell(x, y, occupied, metrics){
  const snapped = snapToGridClamped(x, y, metrics);
  const cell = gridCellFromPos(snapped.x, snapped.y, metrics);
  const key = `${cell.col},${cell.row}`;
  const targetCell = occupied.has(key) ? findFreeCell(cell, occupied, metrics) : cell;
  const pos = gridPosFromCell(targetCell, metrics);
  occupied.set(`${targetCell.col},${targetCell.row}`, true);
  return {
    x: pos.x,
    y: pos.y,
    changed: targetCell.col !== cell.col || targetCell.row !== cell.row || pos.x !== snapped.x || pos.y !== snapped.y
  };
}

function getIconLabel(app){
  return state.iconLabels[app.id] || t(app.titleKey);
}

function getTrashIconFile(){
  return state.trash && state.trash.size > 0
    ? '/assets/icons/trash2.png'
    : '/assets/icons/trash1.png';
}

function updateTrashIconUI(){
  const trashFile = getTrashIconFile();

  const desktopIcon = document.querySelector('.icon[data-app-id="trash"] img');
  if(desktopIcon) desktopIcon.src = trashFile;

  const startIcon = document.querySelector('#startMenu .menu-item img[data-app-id="trash"]');
  if(startIcon) startIcon.src = trashFile;

  const win = document.getElementById('win_trash');
  if(win){
    const titleIcon = win.querySelector('.title-left img');
    if(titleIcon) titleIcon.src = trashFile;
  }

  const taskBtn = document.querySelector('#taskButtons img[data-app-id="trash"]');
  if(taskBtn) taskBtn.src = trashFile;
}

function buildOccupied(excludeIds, metrics){
  const occupied = new Map();
  const exclude = new Set(excludeIds || []);
  $$('.icon').forEach(el => {
    const id = el.dataset.appId;
    if(exclude.has(id)) return;
    const x = parseInt(el.style.left || '0', 10);
    const y = parseInt(el.style.top || '0', 10);
    const cell = gridCellFromPos(x, y, metrics);
    occupied.set(`${cell.col},${cell.row}`, true);
  });
  return occupied;
}

function getDefaultIconLayout(){
  const area = $('#desktopArea').getBoundingClientRect();
  const metrics = getGridMetrics();
  const isMobile = area.width <= 520;
  const order = ['settings','games','about','videos','mediaplayer','diev','art','contact','poetry','music','clothes'];
  const available = APPS.filter(app => app.showOnDesktop !== false && app.id !== 'trash' && !state.trash.has(app.id));
  const availableIds = new Set(available.map(app => app.id));
  const ordered = order.filter(id => availableIds.has(id)).concat(
    available.map(app => app.id).filter(id => !order.includes(id))
  );

  const layout = {};
  const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
  const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));

  if(isMobile){
    const cols = Math.max(1, Math.floor((area.width - 6) / metrics.stepX));
    const rows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    const trashCell = { col: cols - 1, row: rows - 1 };
    let i = 0;
    ordered.forEach(id => {
      let col = i % cols;
      let row = Math.floor(i / cols);
      if(col === trashCell.col && row === trashCell.row){
        i += 1;
        col = i % cols;
        row = Math.floor(i / cols);
      }
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      i += 1;
    });
  } else {
    let col = 0;
    let row = 0;
    const maxRows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    ordered.forEach(id => {
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      row += 1;
      if(row >= maxRows){
        row = 0;
        col += 1;
      }
    });
  }

  const trashX = snapToGridClamped(maxX, maxY, metrics).x;
  const trashY = snapToGridClamped(maxX, maxY, metrics).y;
  layout.trash = { x: trashX, y: trashY };

  return layout;
}

function isOverTrash(x, y){
  const trashEl = document.querySelector('.icon[data-app-id="trash"]');
  if(!trashEl) return false;
  const r = trashEl.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function moveIconsToTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.add(id));
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function restoreFromTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.delete(id));
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function emptyTrash(){
  state.trash = new Set();
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function renderTrashWindow(){
  const win = document.getElementById('win_trash');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.trash();
  applyI18nTo(win);
  content.classList.toggle('trash-empty', state.trash.size === 0);
  const items = win.querySelectorAll('[data-trash-id]');
  items.forEach(item => {
    const id = item.dataset.trashId;
    item.classList.toggle('selected', state.trashSelection.has(id));
  });
  const restoreBtn = win.querySelector('[data-trash-action="restore"]');
  const restoreAllBtn = win.querySelector('[data-trash-action="restoreAll"]');
  if(restoreBtn) restoreBtn.disabled = state.trash.size === 0;
  if(restoreAllBtn) restoreAllBtn.disabled = state.trash.size === 0;
}

function renderPoetryWindow(){
  const win = document.getElementById('win_poetry');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.poetry();
  applyI18nTo(win);
  const items = win.querySelectorAll('[data-poem-id]');
  items.forEach(item => {
    const id = item.dataset.poemId;
    item.classList.toggle('selected', state.poetry.selectedId === id);
  });
}

function renderGamesWindow(){
  const win = document.getElementById('win_games');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.games();
  applyI18nTo(win);

  if(state.games.view === 'list'){
    if(!state.games.selectedId) state.games.selectedId = 'snake';
    const items = Array.from(win.querySelectorAll('[data-game-id]'));
    items.forEach(item => {
      const id = item.dataset.gameId;
      item.classList.toggle('selected', state.games.selectedId === id);
      item.addEventListener('click', (e)=>{
        if(e.detail > 1) return;
        state.games.selectedId = id;
        items.forEach(btn => btn.classList.toggle('selected', btn === item));
      });
      item.addEventListener('dblclick', (e)=>{
        e.stopPropagation();
        openGameFromHub(id);
      });
      item.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          openGameFromHub(id);
        }
      });
    });
    return;
  }

  if(state.games.view === 'snake'){
    initSnakeInWindow(win);
  }
}

function initGamesWindow(){
  renderGamesWindow();
}

function openGameFromHub(id){
  if(id === 'snake'){
    state.games.view = 'snake';
    state.games.selectedId = 'snake';
    renderGamesWindow();
  }
}

function backToGamesHub(){
  state.games.view = 'list';
  state.games.selectedId = 'snake';
  snakeStop();
  renderGamesWindow();
}

const SNAKE_SPEEDS = {
  slow: 180,
  normal: 130,
  fast: 90,
};

let snake = {
  grid: 20,
  body: [],
  dir: { x: 1, y: 0 },
  nextDir: { x: 1, y: 0 },
  food: { x: 0, y: 0 },
  running: false,
  paused: false,
  score: 0,
  gameOver: false,
  started: false,
  speed: 'normal',
  timer: null,
  cell: 16,
  ctx: null,
  els: null,
  swipeStart: null,
};

function loadSnakeHighScore(){
  try{
    const raw = localStorage.getItem(SNAKE_HIGH_KEY);
    const parsed = parseInt(raw || '0', 10);
    return Number.isFinite(parsed) ? parsed : 0;
  } catch {
    return 0;
  }
}

function saveSnakeHighScore(score){
  try{ localStorage.setItem(SNAKE_HIGH_KEY, String(score)); } catch {}
}

function isSnakeActive(){
  return state.activeWindowId === 'games' && state.games.view === 'snake';
}

function initSnakeInWindow(winEl){
  const board = winEl.querySelector('#snakeBoard');
  const canvas = winEl.querySelector('#snakeCanvas');
  if(!board || !canvas) return;

  snake.els = {
    board,
    canvas,
    startBtn: winEl.querySelector('[data-snake-action="start"]'),
    pauseBtn: winEl.querySelector('[data-snake-action="pause"]'),
    playAgainBtn: winEl.querySelector('[data-snake-action="playAgain"]'),
    speedSelect: winEl.querySelector('[data-snake-speed]'),
    score: winEl.querySelector('[data-snake-score]'),
    high: winEl.querySelector('[data-snake-high]'),
    overlay: winEl.querySelector('#snakeOverlay'),
    overScore: winEl.querySelector('[data-snake-over-score]'),
    backBtn: winEl.querySelector('[data-games-action="back"]'),
  };

  snake.ctx = canvas.getContext('2d');
  snake.ctx.imageSmoothingEnabled = false;

  if(typeof state.snake.highScore !== 'number' || Number.isNaN(state.snake.highScore)){
    state.snake.highScore = loadSnakeHighScore();
  }
  snake.speed = state.snake.speed || 'normal';
  if(snake.els.speedSelect) snake.els.speedSelect.value = snake.speed;

  const fixedSize = 320;
  canvas.width = fixedSize;
  canvas.height = fixedSize;
  canvas.style.width = fixedSize + 'px';
  canvas.style.height = fixedSize + 'px';
  snake.cell = Math.max(8, Math.floor(fixedSize / snake.grid));
  snakeDraw();

  if(snake.els.backBtn){
    snake.els.backBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      backToGamesHub();
    });
  }
  if(snake.els.startBtn){
    snake.els.startBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeTogglePause();
    });
  }
  if(snake.els.playAgainBtn){
    snake.els.playAgainBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.speedSelect){
    snake.els.speedSelect.addEventListener('change', (e)=>{
      const val = e.target.value;
      state.snake.speed = val;
      snake.speed = val;
      if(snake.running) snakeStartLoop();
    });
  }

  board.addEventListener('touchstart', snakeHandleTouchStart, { passive: true });
  board.addEventListener('touchend', snakeHandleTouchEnd, { passive: true });

  snakePrepareBoard();
  updateSnakeUI();
}

function snakePrepareBoard(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  snake.score = 0;
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snakePlaceFood();
  snakeDraw();
  updateSnakeUI();
}

function snakeStartGame(){
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  snake.score = 0;
  snake.running = true;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = true;
  snakePlaceFood();
  snakeStartLoop();
  updateSnakeUI();
  snakeDraw();
}

function snakeStartLoop(){
  snakeStopLoop();
  const step = SNAKE_SPEEDS[snake.speed] || SNAKE_SPEEDS.normal;
  snake.timer = setInterval(snakeTick, step);
}

function snakeStopLoop(){
  if(snake.timer){
    clearInterval(snake.timer);
    snake.timer = null;
  }
}

function snakeTogglePause(){
  if(!snake.running) return;
  snake.paused = !snake.paused;
  updateSnakeUI();
}

function snakeStop(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  snake.els = null;
  snake.ctx = null;
}

function snakeTick(){
  if(!snake.running || snake.paused || snake.gameOver) return;
  snake.dir = { ...snake.nextDir };
  const head = snake.body[0];
  const next = {
    x: (head.x + snake.dir.x + snake.grid) % snake.grid,
    y: (head.y + snake.dir.y + snake.grid) % snake.grid,
  };
  if(snake.body.some(seg => seg.x === next.x && seg.y === next.y)){
    snakeGameOver();
    return;
  }

  snake.body.unshift(next);
  if(next.x === snake.food.x && next.y === snake.food.y){
    snake.score += 10;
    snakePlaceFood();
  } else {
    snake.body.pop();
  }
  snakeDraw();
  updateSnakeUI();
}

function snakePlaceFood(){
  let x = 0;
  let y = 0;
  let guard = 0;
  do{
    x = Math.floor(Math.random() * snake.grid);
    y = Math.floor(Math.random() * snake.grid);
    guard += 1;
  } while(snake.body.some(seg => seg.x === x && seg.y === y) && guard < 200);
  snake.food = { x, y };
}

function snakeGameOver(){
  snake.running = false;
  snake.paused = false;
  snake.gameOver = true;
  snakeStopLoop();
  if(snake.score > state.snake.highScore){
    state.snake.highScore = snake.score;
    saveSnakeHighScore(state.snake.highScore);
  }
  updateSnakeUI();
}

function snakeDraw(){
  if(!snake.ctx || !snake.els) return;
  const canvas = snake.els.canvas;
  const ctx = snake.ctx;
  const cell = snake.cell;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#1b7c1b';
  snake.body.forEach((seg, idx)=>{
    ctx.fillStyle = idx === 0 ? '#0f5c0f' : '#1b7c1b';
    ctx.fillRect(seg.x * cell, seg.y * cell, cell, cell);
  });

  ctx.fillStyle = '#b20000';
  ctx.fillRect(snake.food.x * cell, snake.food.y * cell, cell, cell);
}


function snakeHandleDirection(dx, dy){
  if(!isSnakeActive()) return;
  if(dx === -snake.dir.x && dy === -snake.dir.y) return;
  snake.nextDir = { x: dx, y: dy };
}

function snakeHandleKey(e){
  if(!isSnakeActive()) return false;
  const tag = e.target && e.target.tagName;
  if(tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return false;

  const key = e.key.toLowerCase();
  let handled = true;
  if(key === 'arrowup' || key === 'w') snakeHandleDirection(0, -1);
  else if(key === 'arrowdown' || key === 's') snakeHandleDirection(0, 1);
  else if(key === 'arrowleft' || key === 'a') snakeHandleDirection(-1, 0);
  else if(key === 'arrowright' || key === 'd') snakeHandleDirection(1, 0);
  else if(key === ' ' || key === 'spacebar') snakeTogglePause();
  else handled = false;

  if(handled){
    e.preventDefault();
  }
  return handled;
}

function snakeHandleTouchStart(e){
  if(state.windows.has('games') && state.activeWindowId !== 'games'){
    focusWindow('games');
  }
  if(!isSnakeActive()) return;
  const touch = e.changedTouches[0];
  snake.swipeStart = { x: touch.clientX, y: touch.clientY, t: Date.now() };
}

function snakeHandleTouchEnd(e){
  if(!isSnakeActive() || !snake.swipeStart) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - snake.swipeStart.x;
  const dy = touch.clientY - snake.swipeStart.y;
  const absX = Math.abs(dx);
  const absY = Math.abs(dy);
  if(Math.max(absX, absY) < 18){
    snake.swipeStart = null;
    return;
  }
  if(absX > absY){
    snakeHandleDirection(dx > 0 ? 1 : -1, 0);
  } else {
    snakeHandleDirection(0, dy > 0 ? 1 : -1);
  }
  snake.swipeStart = null;
}

function updateSnakeUI(){
  if(!snake.els) return;
  if(snake.els.score) snake.els.score.textContent = String(snake.score);
  if(snake.els.high) snake.els.high.textContent = String(state.snake.highScore || 0);
  if(snake.els.overScore) snake.els.overScore.textContent = String(snake.score);
  if(snake.els.overlay) snake.els.overlay.classList.toggle('hidden', !snake.gameOver);
  if(snake.els.startBtn){
    snake.els.startBtn.textContent = snake.started ? t('snake.restart') : t('snake.start');
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.classList.toggle('pressed', snake.paused);
  }
}

function loadClothesCache(){
  try{
    const raw = localStorage.getItem(CLOTHES_CACHE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.items)) return null;
    if(!parsed.ts || (Date.now() - parsed.ts) > CLOTHES_CACHE_TTL) return null;
    return parsed.items;
  } catch {
    return null;
  }
}

function saveClothesCache(items){
  try{
    localStorage.setItem(CLOTHES_CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch {}
}

function decodeInstagramUrl(url){
  if(!url) return '';
  return url
    .replace(/\\u0026/g, '&')
    .replace(/\\u003d/g, '=')
    .replace(/\\\//g, '/');
}

function parseInstagramHtml(html){
  if(!html) return [];
  const items = [];
  const re = /"shortcode":"(.*?)".*?"display_url":"(.*?)"/g;
  let match;
  while((match = re.exec(html)) && items.length < 12){
    const shortcode = match[1];
    const display = decodeInstagramUrl(match[2]);
    if(!shortcode || !display) continue;
    items.push({
      img: display,
      url: `https://www.instagram.com/p/${shortcode}/`
    });
  }
  return items;
}

function fetchClothesFromInstagram(){
  const url = 'https://r.jina.ai/http://www.instagram.com/blissworldweb/';
  return fetch(url, { cache: 'no-store' })
    .then(res => res.ok ? res.text() : Promise.reject(new Error('bad')))
    .then(html => parseInstagramHtml(html))
    .catch(() => []);
}

function renderClothesItems(winEl, items){
  const grid = winEl.querySelector('#clothesGrid');
  if(!grid) return;
  const profile = 'https://www.instagram.com/blissworldweb/';
  const alt = t('clothes.thumbAlt');
  grid.innerHTML = items.map(item => {
    const href = item.url || profile;
    const img = item.img || '/assets/icons/Clothes.png';
    return `
      <a class="clothes-item" href="${href}" target="_blank" rel="noopener noreferrer" aria-label="${alt}">
        <img class="clothes-thumb" src="${img}" alt="${alt}" loading="lazy" />
      </a>
    `;
  }).join('');
}

function updateClothesStatus(winEl, key){
  const status = winEl.querySelector('#clothesStatus');
  if(!status) return;
  if(!key){
    status.textContent = '';
    status.classList.add('hidden');
  } else {
    status.textContent = t(key);
    status.classList.remove('hidden');
  }
}

function initClothesWindow(winEl){
  const win = winEl || document.getElementById('win_clothes');
  if(!win) return;
  const cached = loadClothesCache();
  if(cached && cached.length){
    renderClothesItems(win, cached);
    updateClothesStatus(win, null);
    return;
  }
  updateClothesStatus(win, 'clothes.loading');
  fetchClothesFromInstagram().then(items => {
    if(items && items.length) saveClothesCache(items);
    const fallback = (items && items.length) ? items : CLOTHES_FALLBACK;
    if(fallback && fallback.length){
      renderClothesItems(win, fallback);
      updateClothesStatus(win, null);
    } else {
      renderClothesItems(win, []);
      updateClothesStatus(win, 'clothes.unavailable');
    }
  });
}

function initSettingsTabs(winEl){
  const win = winEl || document.getElementById('win_settings');
  if(!win) return;
  const tabs = Array.from(win.querySelectorAll('.settings-tab'));
  const panels = Array.from(win.querySelectorAll('.settings-panel'));
  if(!tabs.length || !panels.length) return;
  const panelMap = new Map(panels.map(p => [p.dataset.tab, p]));

  const activate = (tabId)=>{
    if(!panelMap.has(tabId)) return;
    state.settings.tab = tabId;
    tabs.forEach(tab => {
      const active = tab.dataset.tab === tabId;
      tab.setAttribute('aria-selected', active ? 'true' : 'false');
      tab.tabIndex = active ? 0 : -1;
    });
    panels.forEach(panel => {
      panel.classList.toggle('active', panel.dataset.tab === tabId);
    });
    updateWallpaperButtons(win);
    updateAnimationButtons(win);
    updateScanlinesButtons(win);
  };

  const current = (state.settings.tab && panelMap.has(state.settings.tab))
    ? state.settings.tab
    : tabs[0].dataset.tab;
  activate(current);

  tabs.forEach((tab, idx) => {
    tab.addEventListener('click', ()=>{
      activate(tab.dataset.tab);
    });
    tab.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(key === 'Enter' || key === ' '){
        e.preventDefault();
        activate(tab.dataset.tab);
        return;
      }
      if(key === 'ArrowRight' || key === 'ArrowLeft' || key === 'Home' || key === 'End'){
        e.preventDefault();
        let nextIdx = idx;
        if(key === 'ArrowRight') nextIdx = (idx + 1) % tabs.length;
        if(key === 'ArrowLeft') nextIdx = (idx - 1 + tabs.length) % tabs.length;
        if(key === 'Home') nextIdx = 0;
        if(key === 'End') nextIdx = tabs.length - 1;
        tabs[nextIdx].focus();
      }
    });
  });
}

function openSettingsAndTab(tabId, scrollId){
  state.settings.tab = tabId || 'general';
  openApp('settings');
  setTimeout(()=>{
    const winEl = document.getElementById('win_settings');
    if(winEl) initSettingsTabs(winEl);
    if(winEl && scrollId){
      const target = winEl.querySelector(`#${scrollId}`);
      if(target && target.scrollIntoView){
        target.scrollIntoView({ block: 'nearest' });
      }
    }
  }, 0);
}

function selectPoetryItem(id){
  state.poetry.selectedId = id;
  const win = document.getElementById('win_poetry');
  if(!win) return;
  win.querySelectorAll('[data-poem-id]').forEach(item => {
    item.classList.toggle('selected', item.dataset.poemId === id);
  });
}

function arrangeIcons(){
  const next = getDefaultIconLayout();
  saveIconPositions(next);
  renderIcons();
}

function resetIconPositions(){
  try{ localStorage.removeItem(ICON_POS_KEY); } catch {}
  renderIcons();
}

function loadAnimations(){
  try{
    const raw = localStorage.getItem(ANIMATIONS_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveAnimations(){
  try{
    localStorage.setItem(ANIMATIONS_KEY, state.animations ? '1' : '0');
  } catch {}
}

function updateAnimationButtons(root=document){
  $$('[data-set-animations]', root).forEach(btn => {
    const on = btn.dataset.setAnimations === 'on';
    btn.classList.toggle('pressed', on === state.animations);
  });
}

function setAnimations(enabled){
  state.animations = !!enabled;
  saveAnimations();
  updateAnimationButtons();
}

function updateScanlinesButtons(root=document){
  $$('[data-set-scanlines]', root).forEach(btn => {
    const on = btn.dataset.setScanlines === 'on';
    btn.classList.toggle('pressed', on === state.settings.scanlines);
  });
}

function setScanlines(enabled){
  state.settings.scanlines = !!enabled;
  applyScanlines();
  updateScanlinesButtons();
}

function loadScanlines(){
  try{
    const raw = localStorage.getItem(SCANLINES_KEY);
    if(raw === null) return false;
    return raw === '1';
  } catch {
    return false;
  }
}

function saveScanlines(){
  try{
    localStorage.setItem(SCANLINES_KEY, state.settings.scanlines ? '1' : '0');
  } catch {}
}

function loadTrash(){
  try{
    const raw = localStorage.getItem(TRASH_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function saveTrash(){
  try{
    localStorage.setItem(TRASH_KEY, JSON.stringify(Array.from(state.trash)));
  } catch {}
}

function loadIconLabels(){
  try{
    const raw = localStorage.getItem(ICON_LABELS_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function saveIconLabels(){
  try{
    localStorage.setItem(ICON_LABELS_KEY, JSON.stringify(state.iconLabels));
  } catch {}
}

function loadWallpaper(){
  try{
    const saved = localStorage.getItem(WALLPAPER_KEY);
    return saved || WALLPAPERS[0].id;
  } catch {
    return WALLPAPERS[0].id;
  }
}

function updateWallpaperButtons(root=document){
  $$('[data-set-wallpaper]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setWallpaper === state.wallpaper);
  });
}

function applyWallpaper(id){
  const wp = WALLPAPERS.find(w => w.id === id) || WALLPAPERS[0];
  state.wallpaper = wp.id;
  const desktop = $('#desktop');
  if(desktop){
    desktop.style.background = wp.background;
    desktop.style.backgroundSize = wp.size || 'auto';
    desktop.style.backgroundRepeat = wp.repeat || 'repeat';
  }
  try{ localStorage.setItem(WALLPAPER_KEY, wp.id); } catch {}
  updateWallpaperButtons();
  renderCtxMenu();
}

function applyMusicState(winEl){
  const win = winEl || document.getElementById('win_music');
  if(!win) return;
  const grid = win.querySelector('.music-grid');
  if(!grid) return;
  grid.classList.toggle('music-small', state.music.tileSize === 'small');
  win.classList.toggle('music-hide-icons', !state.music.showIcons);
  grid.querySelectorAll('[data-music-id]').forEach(card => {
    const id = card.dataset.musicId;
    card.classList.toggle('selected', state.music.selected.has(id));
  });
}

function applyMediaplayerState(winEl){
  const win = winEl || document.getElementById('win_mediaplayer');
  if(!win) return;
  win.classList.toggle('mp-hide-list', !state.mediaplayer.showPlaylist);
  win.classList.toggle('mp-compact', state.mediaplayer.compact);
}

function applyDievState(winEl){
  const win = winEl || document.getElementById('win_diev');
  if(!win) return;
  win.classList.toggle('diev-small', state.diev.textSize === 'small');
  win.classList.toggle('diev-large', state.diev.textSize === 'large');
  win.classList.toggle('diev-contrast', state.diev.highContrast);
}

function applyArtState(winEl){
  const win = winEl || document.getElementById('win_art');
  if(!win) return;
  win.classList.toggle('art-zoom-50', state.art.zoom === 50);
  win.classList.toggle('art-zoom-100', state.art.zoom === 100);
  win.classList.toggle('art-zoom-200', state.art.zoom === 200);
}

function applyScanlines(){
  document.body.classList.toggle('scanlines', state.settings.scanlines);
  saveScanlines();
  updateScanlinesButtons();
}

function applyWindowState(winEl, appId){
  if(appId === 'music') applyMusicState(winEl);
  if(appId === 'mediaplayer') applyMediaplayerState(winEl);
  if(appId === 'diev') applyDievState(winEl);
  if(appId === 'art') applyArtState(winEl);
}

function getPoemById(id){
  return POEMS.find(p => p.id === id) || null;
}

function getPoemBody(poem, lang){
  if(!poem) return '';
  if(lang === 'pt') return poem.body_pt || poem.body_en || '';
  return poem.body_en || poem.body_pt || '';
}

// Context menu state
let ctxState = { open:false, target:'desktop', appId:null };

function renderCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;

  const isIcon = ctxState.target === 'icon' && !!ctxState.appId;
  const gridMark = state.gridSnap ? '✓' : '';

  const items = [];
  if(isIcon){
    items.push({ action:'open', label:t('ctx.open') });
    items.push({ sep:true });
    if(ctxState.appId === 'trash'){
      items.push({ action:'emptyTrash', label:t('ctx.emptyTrash') });
      items.push({ sep:true });
    } else {
      items.push({ action:'rename', label:t('ctx.rename') });
      items.push({ action:'crop', label:t('ctx.crop') });
      items.push({ action:'copy', label:t('ctx.copy') });
      items.push({ sep:true });
      items.push({ action:'moveTrash', label:t('ctx.moveTrash') });
      items.push({ sep:true });
    }
  }

  if(!isIcon){
    items.push({ action:'arrange', label:t('ctx.arrange') });
    items.push({ action:'grid', label:t('ctx.grid'), check:gridMark });
    items.push({ action:'wallpaper', label:t('ctx.wallpaper') });
    items.push({ sep:true });
    items.push({ action:'settings', label:t('ctx.settings') });
    items.push({ action:'language', label:t('ctx.language'), right: state.lang.toUpperCase() });
    items.push({ action:'about', label:t('ctx.about') });
    items.push({ sep:true });
    items.push({ action:'logoff', label:t('ctx.logoff') });
  }

  menu.innerHTML = items.map(it => {
    if(it.sep) return `<div class="ctx-sep"></div>`;
    const check = it.check ? `<span class="ctx-check" aria-hidden="true">${it.check}</span>` : `<span class="ctx-check" aria-hidden="true"></span>`;
    const right = it.right ? `<span class="ctx-shortcut">${it.right}</span>` : `<span class="ctx-shortcut"></span>`;
    return `
      <button class="ctx-item" type="button" role="menuitem" data-ctx-action="${it.action}">
        <span class="ctx-left">${check}<span>${it.label}</span></span>
        ${right}
      </button>
    `;
  }).join('');
}

function positionCtxMenu(x, y){
  const menu = $('#ctxMenu');
  if(!menu) return;
  const area = $('#desktopArea').getBoundingClientRect();

  menu.classList.remove('hidden');
  menu.style.left = '0px';
  menu.style.top = '0px';
  const rect = menu.getBoundingClientRect();

  const maxX = area.left + area.width - rect.width - 6;
  const maxY = area.top + area.height - rect.height - 6;

  const px = clamp(x, area.left + 6, maxX);
  const py = clamp(y, area.top + 6, area.top + area.height - rect.height - 6);

  menu.style.left = (px - area.left) + 'px';
  menu.style.top = (py - area.top) + 'px';
}

function openCtxMenu(x, y, target='desktop', appId=null){
  if($('#desktop').classList.contains('hidden')) return;
  ctxState = { open:true, target, appId };
  closeStartMenu();
  closeWindowMenu();
  renderCtxMenu();
  positionCtxMenu(x, y);
  const menu = $('#ctxMenu');
  if(menu){
    menu.classList.remove('hidden');
    const first = menu.querySelector('.ctx-item');
    if(first) first.focus();
  }
}

function closeCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;
  menu.classList.add('hidden');
  ctxState = { open:false, target:'desktop', appId:null };
}

function handleCtxAction(action){
  if(action === 'open' && ctxState.target === 'icon' && ctxState.appId){
    openApp(ctxState.appId);
  }
  if(action === 'rename' && ctxState.target === 'icon' && ctxState.appId && ctxState.appId !== 'trash'){
    const app = APPS.find(a => a.id === ctxState.appId);
    if(!app) return;
    const current = state.iconLabels[app.id] || t(app.titleKey);
    showInputDialog({
      titleKey: 'dialog.rename.title',
      descKey: 'dialog.rename.desc',
      value: current,
      confirmKey: 'dialog.rename.confirm',
      onConfirm: (val)=>{
        const next = String(val || '').trim();
        if(next){
          state.iconLabels[app.id] = next;
        } else {
          delete state.iconLabels[app.id];
        }
        saveIconLabels();
        renderIcons();
      }
    });
  }
  if(action === 'crop' && ctxState.target === 'icon' && ctxState.appId){
    showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
  }
  if(action === 'copy' && ctxState.target === 'icon' && ctxState.appId){
    const app = APPS.find(a => a.id === ctxState.appId);
    const label = app ? getIconLabel(app) : '';
    if(label){
      copyText(label).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
    } else {
      showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
    }
  }
  if(action === 'moveTrash' && ctxState.target === 'icon' && ctxState.appId){
    moveIconsToTrash([ctxState.appId]);
  }
  if(action === 'emptyTrash' && ctxState.target === 'icon' && ctxState.appId === 'trash'){
    emptyTrash();
  }
  if(action === 'arrange') arrangeIcons();
  if(action === 'grid'){
    state.gridSnap = !state.gridSnap;
    saveGridSnap();
    renderCtxMenu();
  }
  if(action === 'wallpaper'){
    openSettingsAndTab('appearance', 'settingsWallpaper');
  }
  if(action === 'settings') openApp('settings');
  if(action === 'language') toggleLang();
  if(action === 'about') openApp('about');
  if(action === 'logoff'){
    closeCtxMenu();
    closeStartMenu();
    doLogoff();
  }
}

// Long-press support (mobile/touch)
function installLongPress(el, getTarget){
  let timer = null;
  let start = null;
  const threshold = 8;
  const delay = 520;

  const clear = ()=>{
    if(timer){ clearTimeout(timer); timer = null; }
    start = null;
  };

  el.addEventListener('pointerdown', (e)=>{
    if(e.pointerType !== 'touch') return;
    start = { x:e.clientX, y:e.clientY };
    timer = setTimeout(()=>{
      const tgt = getTarget ? getTarget() : { target:'desktop', appId:null };
      openCtxMenu(e.clientX, e.clientY, tgt.target, tgt.appId);
      clear();
    }, delay);
  });

  el.addEventListener('pointermove', (e)=>{
    if(!start || !timer) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    if(Math.hypot(dx,dy) > threshold){
      clear();
    }
  });

  el.addEventListener('pointerup', clear);
  el.addEventListener('pointercancel', clear);
}

      const I18N = {
        en: {
          'login.sub': 'Enter your name to login',
          'login.labelName': 'Name:',
          'login.placeholder': 'Enter your name',
          'login.hint': 'Hint: Ignorance is BLISS',
          'login.clear': 'Clear',
          'login.enter': 'Enter',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Soon.',
          'common.ok': 'OK',
          'common.cancel': 'Cancel',
          'common.open': 'Open',
          'common.copy': 'Copy',

          'aria.language': 'Language',
          'aria.startMenu': 'BLISS Menu',
          'aria.contextMenu': 'Context menu',
          'aria.close': 'Close',
          'start.menu': 'Menu',

          'menubar.file': 'File',
          'menubar.edit': 'Edit',
          'menubar.view': 'View',
          'menubar.help': 'Help',

          'status.ready': 'Ready',

          'win.minimize': 'Minimize',
          'win.close': 'Close',
          'win.resize': 'Resize',
          'win.maximize': 'Maximize',
          'win.restore': 'Restore',

          'app.clothes': 'Clothes',
          'app.music': 'Music',
          'app.art': 'Art',
          'app.games': 'Games',
          'app.videos': 'Videos',
          'app.about': 'About',
          'app.contact': 'Contact',
          'app.diev': 'DIEV',
          'app.settings': 'Settings',
          'app.poetry': 'Poetry',
          'app.trash': 'Recycle Bin',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.back': 'Back',
          'snake.title': 'Snake',
          'snake.start': 'Start',
          'snake.restart': 'Restart',
          'snake.pause': 'Pause',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Speed:',
          'snake.speed.slow': 'Slow',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Fast',
          'snake.instructions': 'Use arrow keys or WASD. On mobile, swipe.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Play again',

          'menu.logoff': 'Log off…',

          'ctx.open': 'Open',
          'ctx.rename': 'Rename',
          'ctx.crop': 'Crop',
          'ctx.copy': 'Copy',
          'ctx.moveTrash': 'Move to Recycle Bin',
          'ctx.emptyTrash': 'Empty Recycle Bin',
          'ctx.arrange': 'Arrange icons',
          'ctx.grid': 'Grid (snap)',
          'ctx.wallpaper': 'Wallpaper',
          'ctx.settings': 'Settings',
          'ctx.language': 'Language',
          'ctx.about': 'About',
          'ctx.logoff': 'Log off…',

          'settings.title': 'Settings',
          'settings.tab.general': 'General',
          'settings.tab.language': 'Language',
          'settings.tab.appearance': 'Appearance',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'System properties and preferences for BLISS 98.',
          'settings.general.user': 'User:',
          'settings.general.guest': 'Guest',
          'settings.general.version': 'Version:',
          'settings.general.registeredTo': 'Registered to:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Language',
          'settings.languageDesc': 'Choose your language for BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',
          'settings.appearanceTab': 'Appearance',
          'settings.appearanceDesc': 'Customize how BLISS 98 looks.',
          'settings.animationsTab': 'Animations',
          'settings.animationsDesc': 'Toggle window animations.',
          'settings.animations.on': 'On',
          'settings.animations.off': 'Off',
          'settings.wallpaperTab': 'Wallpaper',
          'settings.wallpaperDesc': 'Choose a wallpaper for your desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Add scanline effect to the display.',
          'settings.scanlines.on': 'On',
          'settings.scanlines.off': 'Off',
          'poetry.title': 'Poetry Library',
          'poetry.back': 'Back',
          'poetry.language': 'Language',
          'poetry.empty': 'No poems yet.',

          'menu.file.newWindow': 'New Window…',
          'menu.file.close': 'Close',
          'menu.file.logoff': 'Log off…',
          'menu.help.controls': 'Controls',
          'menu.help.about': 'About BLISS 98',

          'menu.music.openLink': 'Open Link…',
          'menu.music.copyLink': 'Copy Link',
          'menu.music.selectAll': 'Select All',
          'menu.music.clearSelection': 'Clear Selection',
          'menu.music.tileSize': 'Tile size',
          'menu.music.tileSize.small': 'Small',
          'menu.music.tileSize.large': 'Large',
          'menu.music.openNewTab': 'Open in new tab (default)',
          'menu.music.showIcons': 'Show platform icons',
          'menu.music.where': 'Where to listen',

          'menu.player.openTrack': 'Open Track…',
          'menu.player.reload': 'Reload Library',
          'menu.player.selectAll': 'Select All',
          'menu.player.copyName': 'Copy Track Name',
          'menu.player.clearSelection': 'Clear Selection',
          'menu.player.shuffle': 'Shuffle',
          'menu.player.repeat': 'Repeat',
          'menu.player.repeat.off': 'Off',
          'menu.player.repeat.one': 'One',
          'menu.player.repeat.all': 'All',
          'menu.player.showPlaylist': 'Show Playlist',
          'menu.player.compact': 'Compact mode',
          'menu.player.tips': 'Playback tips',

          'menu.clothes.openLookbook': 'Open Lookbook',
          'menu.clothes.shop': 'Shop…',
          'menu.clothes.copy': 'Copy',
          'menu.clothes.selectAll': 'Select All',
          'menu.clothes.viewGrid': 'Grid',
          'menu.clothes.sort': 'Sort by',
          'menu.clothes.sort.new': 'New',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Preview images',
          'menu.clothes.sizing': 'Sizing',

          'menu.diev.openPress': 'Open Press Kit',
          'menu.diev.copyBio': 'Copy Bio',
          'menu.diev.copy': 'Copy',
          'menu.diev.selectAll': 'Select All',
          'menu.diev.textSize': 'Text size',
          'menu.diev.textSize.small': 'Small',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Large',
          'menu.diev.highContrast': 'High contrast',
          'menu.diev.links': 'Links',

          'menu.contact.copyEmail': 'Copy Email',
          'menu.contact.openInstagram': 'Open Instagram',
          'menu.contact.copy': 'Copy',
          'menu.contact.selectAll': 'Select All',
          'menu.contact.showQr': 'Show QR',
          'menu.contact.compact': 'Compact',
          'menu.contact.support': 'Support',

          'menu.settings.apply': 'Apply',
          'menu.settings.reset': 'Reset to default',
          'menu.settings.undo': 'Undo',
          'menu.settings.redo': 'Redo',
          'menu.settings.fullscreen': 'Fullscreen',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Wallpaper…',
          'menu.settings.what': 'What is this?',

          'menu.art.openGallery': 'Open Gallery',
          'menu.art.saveImage': 'Save Image…',
          'menu.art.copy': 'Copy',
          'menu.art.selectAll': 'Select All',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Slideshow',
          'menu.art.credits': 'Credits',

          'menu.games.openFolder': 'Open Games Folder',
          'menu.games.download': 'Download…',
          'menu.games.copy': 'Copy',
          'menu.games.selectAll': 'Select All',
          'menu.games.grid': 'Grid',
          'menu.games.sort': 'Sort by',
          'menu.games.sort.new': 'New',
          'menu.games.sort.favorite': 'Favorite',
          'menu.games.requirements': 'Requirements',

          'menu.videos.openChannel': 'Open Channel',
          'menu.videos.copyLink': 'Copy Link',
          'menu.videos.copy': 'Copy',
          'menu.videos.selectAll': 'Select All',
          'menu.videos.thumbSize': 'Thumbnail size',
          'menu.videos.thumbSize.small': 'Small',
          'menu.videos.thumbSize.large': 'Large',
          'menu.videos.openNewTab': 'Open in new tab',
          'menu.videos.tips': 'Playback tips',

          'menu.about.copy': 'Copy',
          'menu.about.selectAll': 'Select All',
          'menu.about.version': 'Version info',
          'menu.about.credits': 'Credits',
          'menu.about.controls': 'Controls',

          'dialog.newWindow.title': 'New Window',
          'dialog.newWindow.desc': 'Choose an app to open.',
          'dialog.newWindow.open': 'Open',
          'dialog.openLink.title': 'Open Link',
          'dialog.openLink.desc': 'Choose a platform.',
          'dialog.openLink.open': 'Open',
          'dialog.openTrack.title': 'Open Track',
          'dialog.openTrack.desc': 'Choose a track from the playlist.',
          'dialog.openTrack.open': 'Open',
          'dialog.controls.title': 'Controls',
          'dialog.controls.body': 'Drag windows by the title bar. Resize from the corner. Right-click or long-press the desktop for options.',
          'dialog.where.title': 'Where to listen',
          'dialog.where.body': 'These are official BLISS links. Pick a platform to open or copy the link.',
          'dialog.playerTips.title': 'Playback tips',
          'dialog.playerTips.body': 'Autoplay may be blocked. If it does not start, press Play once.',
          'dialog.support.title': 'Support',
          'dialog.support.body': 'Report issues through the Contact window when available. We will keep the system updated.',
          'dialog.settingsWhat.title': 'Settings',
          'dialog.settingsWhat.body': 'Adjust language, wallpaper, and window animations for BLISS 98.',
          'dialog.version.title': 'Version info',
          'dialog.version.body': 'BLISS 98 — Build 98.0',
          'dialog.credits.title': 'Credits',
          'dialog.credits.body': 'Created by DIEV.',
          'dialog.notAvailable.title': 'Coming soon',
          'dialog.notAvailable.body': 'This feature is not available yet.',
          'dialog.selectItem.title': 'Select an item',
          'dialog.selectItem.body': 'Select an item first to continue.',
          'dialog.copied.title': 'Copied',
          'dialog.copied.body': 'Copied to clipboard.',
          'dialog.settingsApplied.title': 'Settings',
          'dialog.settingsApplied.body': 'Settings applied.',
          'dialog.noUndo.title': 'Undo',
          'dialog.noUndo.body': 'Nothing to undo.',
          'dialog.noRedo.title': 'Redo',
          'dialog.noRedo.body': 'Nothing to redo.',
          'dialog.rename.title': 'Rename',
          'dialog.rename.desc': 'Enter a new name.',
          'dialog.rename.confirm': 'Rename',
          'dialog.trash.empty': 'Recycle Bin is empty.',
          'dialog.trash.restore': 'Restore',
          'dialog.trash.restoreAll': 'Restore All',
          'dialog.trash.emptyAction': 'Empty Recycle Bin',

          'wallpaper.classic': 'Classic Teal',
          'wallpaper.bliss': 'Sunrise',
          'wallpaper.clouds': 'Clouds',
          'wallpaper.diev': 'Grid',

          'music.title': 'BLISS — Music',
          'music.subtitle': 'Listen everywhere:',
          'music.tip': 'Music is a beautiful thing, innit?',

          'clothes.title': 'BLISS — Clothes',
          'clothes.subtitle': 'Latest from Instagram.',
          'clothes.loading': 'Loading…',
          'clothes.unavailable': 'Unable to load right now.',
          'clothes.thumbAlt': 'BLISS Instagram',

          'about.title': 'About',
          'about.p1': 'BLISS is a project that aims to bring together independent, weird, and unique artists,',
          'about.p2': 'supporting every form of art and self-expression.',
          'about.p3': 'Against the system and the dogmas created by humans,',
          'about.p4': 'we are our own GODS.',
          'about.p5': 'There are no rules.',
          'about.p6': 'We create our own world from the inside out.',
          'about.footer': 'BLISS 98 Desing by DIEV',

          'contact.title': 'Contact',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Official page for DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Now playing:',
          'player.play': 'Play',
          'player.pause': 'Pause',
          'player.prev': 'Prev',
          'player.next': 'Next',
          'player.vol': 'Vol',
          'player.loading': 'Loading tracks…',
          'player.notfound': 'No songs yet.',
          'player.autoplay': 'Autoplay may be blocked by your browser. If it does not start, press Play.'
        },
        pt: {
          'login.sub': 'Digite seu nome para entrar',
          'login.labelName': 'Nome:',
          'login.placeholder': 'Digite seu nome',
          'login.hint': 'Dica: Ignorância é BLISS',
          'login.clear': 'Limpar',
          'login.enter': 'Entrar',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Em breve.',
          'common.ok': 'OK',
          'common.cancel': 'Cancelar',
          'common.open': 'Abrir',
          'common.copy': 'Copiar',

          'aria.language': 'Idioma',
          'aria.startMenu': 'Menu BLISS',
          'aria.contextMenu': 'Menu de contexto',
          'aria.close': 'Fechar',
          'start.menu': 'Menu',

          'menubar.file': 'Arquivo',
          'menubar.edit': 'Editar',
          'menubar.view': 'Exibir',
          'menubar.help': 'Ajuda',

          'status.ready': 'Pronto',

          'win.minimize': 'Minimizar',
          'win.close': 'Fechar',
          'win.resize': 'Redimensionar',
          'win.maximize': 'Maximizar',
          'win.restore': 'Restaurar',

          'app.clothes': 'Roupas',
          'app.music': 'Música',
          'app.art': 'Arte',
          'app.games': 'Jogos',
          'app.videos': 'Vídeos',
          'app.about': 'Sobre',
          'app.contact': 'Contato',
          'app.diev': 'DIEV',
          'app.settings': 'Configurações',
          'app.poetry': 'Poesias',
          'app.trash': 'Lixeira',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.back': 'Voltar',
          'snake.title': 'Snake',
          'snake.start': 'Iniciar',
          'snake.restart': 'Reiniciar',
          'snake.pause': 'Pausar',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Velocidade:',
          'snake.speed.slow': 'Lento',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Rápido',
          'snake.instructions': 'Use as setas ou WASD. No celular, deslize.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Jogar novamente',

          'menu.logoff': 'Sair…',

          'ctx.open': 'Abrir',
          'ctx.rename': 'Renomear',
          'ctx.crop': 'Recortar',
          'ctx.copy': 'Copiar',
          'ctx.moveTrash': 'Mover para a Lixeira',
          'ctx.emptyTrash': 'Esvaziar Lixeira',
          'ctx.arrange': 'Organizar ícones',
          'ctx.grid': 'Grade (snap)',
          'ctx.wallpaper': 'Plano de Fundo',
          'ctx.settings': 'Configurações',
          'ctx.language': 'Idioma',
          'ctx.about': 'Sobre',
          'ctx.logoff': 'Sair…',

          'settings.title': 'Configurações',
          'settings.tab.general': 'Geral',
          'settings.tab.language': 'Idioma',
          'settings.tab.appearance': 'Aparência',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'Propriedades e ajustes do BLISS 98.',
          'settings.general.user': 'Usuário:',
          'settings.general.guest': 'Convidado',
          'settings.general.version': 'Versão:',
          'settings.general.registeredTo': 'Registrado para:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Idioma',
          'settings.languageDesc': 'Escolha o idioma do BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',
          'settings.appearanceTab': 'Aparência',
          'settings.appearanceDesc': 'Personalize o visual do BLISS 98.',
          'settings.animationsTab': 'Animações',
          'settings.animationsDesc': 'Ative ou desative as animações das janelas.',
          'settings.animations.on': 'Ligado',
          'settings.animations.off': 'Desligado',
          'settings.wallpaperTab': 'Papel de parede',
          'settings.wallpaperDesc': 'Escolha um papel de parede para o desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Adicione efeito de scanlines na tela.',
          'settings.scanlines.on': 'Ligado',
          'settings.scanlines.off': 'Desligado',
          'poetry.title': 'Biblioteca de Poesias',
          'poetry.back': 'Voltar',
          'poetry.language': 'Idioma',
          'poetry.empty': 'Sem poesias ainda.',

          'menu.file.newWindow': 'Nova janela…',
          'menu.file.close': 'Fechar',
          'menu.file.logoff': 'Sair…',
          'menu.help.controls': 'Controles',
          'menu.help.about': 'Sobre BLISS 98',

          'menu.music.openLink': 'Abrir link…',
          'menu.music.copyLink': 'Copiar link',
          'menu.music.selectAll': 'Selecionar tudo',
          'menu.music.clearSelection': 'Limpar seleção',
          'menu.music.tileSize': 'Tamanho dos cards',
          'menu.music.tileSize.small': 'Pequeno',
          'menu.music.tileSize.large': 'Grande',
          'menu.music.openNewTab': 'Abrir em nova aba (padrão)',
          'menu.music.showIcons': 'Mostrar ícones',
          'menu.music.where': 'Onde ouvir',

          'menu.player.openTrack': 'Abrir faixa…',
          'menu.player.reload': 'Recarregar biblioteca',
          'menu.player.selectAll': 'Selecionar tudo',
          'menu.player.copyName': 'Copiar nome da faixa',
          'menu.player.clearSelection': 'Limpar seleção',
          'menu.player.shuffle': 'Aleatório',
          'menu.player.repeat': 'Repetir',
          'menu.player.repeat.off': 'Desligado',
          'menu.player.repeat.one': 'Uma',
          'menu.player.repeat.all': 'Todas',
          'menu.player.showPlaylist': 'Mostrar playlist',
          'menu.player.compact': 'Modo compacto',
          'menu.player.tips': 'Dicas de reprodução',

          'menu.clothes.openLookbook': 'Abrir lookbook',
          'menu.clothes.shop': 'Loja…',
          'menu.clothes.copy': 'Copiar',
          'menu.clothes.selectAll': 'Selecionar tudo',
          'menu.clothes.viewGrid': 'Grade',
          'menu.clothes.sort': 'Ordenar por',
          'menu.clothes.sort.new': 'Novidades',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Pré-visualizar',
          'menu.clothes.sizing': 'Tamanhos',

          'menu.diev.openPress': 'Abrir press kit',
          'menu.diev.copyBio': 'Copiar bio',
          'menu.diev.copy': 'Copiar',
          'menu.diev.selectAll': 'Selecionar tudo',
          'menu.diev.textSize': 'Tamanho do texto',
          'menu.diev.textSize.small': 'Pequeno',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Grande',
          'menu.diev.highContrast': 'Alto contraste',
          'menu.diev.links': 'Links oficiais',

          'menu.contact.copyEmail': 'Copiar e-mail',
          'menu.contact.openInstagram': 'Abrir Instagram',
          'menu.contact.copy': 'Copiar',
          'menu.contact.selectAll': 'Selecionar tudo',
          'menu.contact.showQr': 'Mostrar QR',
          'menu.contact.compact': 'Compacto',
          'menu.contact.support': 'Suporte',

          'menu.settings.apply': 'Aplicar',
          'menu.settings.reset': 'Restaurar padrão',
          'menu.settings.undo': 'Desfazer',
          'menu.settings.redo': 'Refazer',
          'menu.settings.fullscreen': 'Tela cheia',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Papel de parede…',
          'menu.settings.what': 'O que é isso?',

          'menu.art.openGallery': 'Abrir galeria',
          'menu.art.saveImage': 'Salvar imagem…',
          'menu.art.copy': 'Copiar',
          'menu.art.selectAll': 'Selecionar tudo',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Apresentação',
          'menu.art.credits': 'Créditos',

          'menu.games.openFolder': 'Abrir pasta de jogos',
          'menu.games.download': 'Download…',
          'menu.games.copy': 'Copiar',
          'menu.games.selectAll': 'Selecionar tudo',
          'menu.games.grid': 'Grade',
          'menu.games.sort': 'Ordenar por',
          'menu.games.sort.new': 'Novidades',
          'menu.games.sort.favorite': 'Favorito',
          'menu.games.requirements': 'Requisitos',

          'menu.videos.openChannel': 'Abrir canal',
          'menu.videos.copyLink': 'Copiar link',
          'menu.videos.copy': 'Copiar',
          'menu.videos.selectAll': 'Selecionar tudo',
          'menu.videos.thumbSize': 'Tamanho das miniaturas',
          'menu.videos.thumbSize.small': 'Pequeno',
          'menu.videos.thumbSize.large': 'Grande',
          'menu.videos.openNewTab': 'Abrir em nova aba',
          'menu.videos.tips': 'Dicas',

          'menu.about.copy': 'Copiar',
          'menu.about.selectAll': 'Selecionar tudo',
          'menu.about.version': 'Informações da versão',
          'menu.about.credits': 'Créditos',
          'menu.about.controls': 'Controles',

          'dialog.newWindow.title': 'Nova janela',
          'dialog.newWindow.desc': 'Escolha um app para abrir.',
          'dialog.newWindow.open': 'Abrir',
          'dialog.openLink.title': 'Abrir link',
          'dialog.openLink.desc': 'Escolha uma plataforma.',
          'dialog.openLink.open': 'Abrir',
          'dialog.openTrack.title': 'Abrir faixa',
          'dialog.openTrack.desc': 'Escolha uma faixa da playlist.',
          'dialog.openTrack.open': 'Abrir',
          'dialog.controls.title': 'Controles',
          'dialog.controls.body': 'Arraste a janela pela barra de título. Redimensione pelo canto. Clique com o botão direito ou pressione e segure no desktop para opções.',
          'dialog.where.title': 'Onde ouvir',
          'dialog.where.body': 'Estes são links oficiais da BLISS. Escolha uma plataforma para abrir ou copiar.',
          'dialog.playerTips.title': 'Dicas de reprodução',
          'dialog.playerTips.body': 'O autoplay pode ser bloqueado. Se não tocar, aperte Play uma vez.',
          'dialog.support.title': 'Suporte',
          'dialog.support.body': 'Reporte problemas pela janela de Contato quando estiver disponível. Vamos manter o sistema atualizado.',
          'dialog.settingsWhat.title': 'Configurações',
          'dialog.settingsWhat.body': 'Ajuste idioma, papel de parede e animações das janelas do BLISS 98.',
          'dialog.version.title': 'Informações da versão',
          'dialog.version.body': 'BLISS 98 — Build 98.0',
          'dialog.credits.title': 'Créditos',
          'dialog.credits.body': 'Criado por DIEV.',
          'dialog.notAvailable.title': 'Em breve',
          'dialog.notAvailable.body': 'Este recurso ainda não está disponível.',
          'dialog.selectItem.title': 'Selecione um item',
          'dialog.selectItem.body': 'Selecione um item para continuar.',
          'dialog.copied.title': 'Copiado',
          'dialog.copied.body': 'Copiado para a área de transferência.',
          'dialog.settingsApplied.title': 'Configurações',
          'dialog.settingsApplied.body': 'Configurações aplicadas.',
          'dialog.noUndo.title': 'Desfazer',
          'dialog.noUndo.body': 'Nada para desfazer.',
          'dialog.noRedo.title': 'Refazer',
          'dialog.noRedo.body': 'Nada para refazer.',
          'dialog.rename.title': 'Renomear',
          'dialog.rename.desc': 'Digite um novo nome.',
          'dialog.rename.confirm': 'Renomear',
          'dialog.trash.empty': 'A lixeira está vazia.',
          'dialog.trash.restore': 'Restaurar',
          'dialog.trash.restoreAll': 'Restaurar tudo',
          'dialog.trash.emptyAction': 'Esvaziar Lixeira',

          'wallpaper.classic': 'Teal clássico',
          'wallpaper.bliss': 'Nascer do Sol',
          'wallpaper.clouds': 'Nuvens',
          'wallpaper.diev': 'Grid',

          'music.title': 'BLISS — Música',
          'music.subtitle': 'Ouça em todas as plataformas:',
          'music.tip': 'Música é uma coisa linda, não é?',

          'clothes.title': 'BLISS — Roupas',
          'clothes.subtitle': 'Últimos do Instagram.',
          'clothes.loading': 'Carregando…',
          'clothes.unavailable': 'Não foi possível carregar agora.',
          'clothes.thumbAlt': 'Instagram da BLISS',

          'about.title': 'Sobre',
          'about.p1': 'BLISS é um projeto que visa unir artistas independentes, estranhos e únicos,',
          'about.p2': 'apoiando toda forma de arte e autoexpressão.',
          'about.p3': 'Contra o sistema e os dogmas criados por humanos,',
          'about.p4': 'nós somos nossos próprios DEUSES.',
          'about.p5': 'Não existem regras.',
          'about.p6': 'Nós criamos o nosso próprio mundo de dentro para fora.',
          'about.footer': 'BLISS 98 Desing by DIEV',

          'contact.title': 'Contato',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Página oficial do DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Tocando:',
          'player.play': 'Play',
          'player.pause': 'Pausar',
          'player.prev': 'Anterior',
          'player.next': 'Próxima',
          'player.vol': 'Vol',
          'player.loading': 'Carregando músicas…',
          'player.notfound': 'Sem músicas ainda.',
          'player.autoplay': 'O autoplay pode ser bloqueado. Se não tocar, aperte Play.'
        }
      };

      function t(key){
        return (I18N[state.lang] && I18N[state.lang][key]) || (I18N.en && I18N.en[key]) || key;
      }

      function applyI18nTo(root){
        // text nodes
        $$('[data-i18n]', root).forEach(el => {
          const key = el.getAttribute('data-i18n');
          if(key) el.textContent = t(key);
        });
        // titles
        $$('[data-i18n-title]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-title');
          if(key) el.setAttribute('title', t(key));
        });
        // aria labels
        $$('[data-i18n-aria]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-aria');
          if(key) el.setAttribute('aria-label', t(key));
        });
        // placeholders
        $$('[data-i18n-placeholder]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-placeholder');
          if(key) el.setAttribute('placeholder', t(key));
        });
        updateWallpaperButtons(root);
        updateAnimationButtons(root);
      }

      function applyI18n(){
        applyI18nTo(document);

        // Update language button label
        const lb = $('#langBtn');
        if(lb) lb.textContent = state.lang.toUpperCase();

        // Re-render desktop UI labels
        renderIcons();
        renderStartMenu();
        updateOpenWindowTitles();
        renderTaskButtons();
        renderCtxMenu();
        updateSnakeUI();
      }

      function setLang(lang){
        state.lang = (lang === 'pt') ? 'pt' : 'en';
        localStorage.setItem('bliss98_lang', state.lang);
        applyI18n();
      }

      function toggleLang(){
        setLang(state.lang === 'en' ? 'pt' : 'en');
      }

      function getWindowId(winEl){
        if(!winEl || !winEl.id) return null;
        return winEl.id.replace('win_', '');
      }

      function renderMenuItems(items){
        return items.map(item => {
          if(item.type === 'sep') return '<div class="menu-sep"></div>';
          const label = t(item.labelKey);
          const checkMark = item.type === 'radio' ? '•' : '✓';
          const check = item.checked ? checkMark : '';
          const left = `<span class="menu-left"><span class="menu-check">${check}</span><span>${label}</span></span>`;
          if(item.type === 'submenu'){
            return `
              <div class="menu-item has-sub" tabindex="0">
                ${left}
                <span class="menu-right">▶</span>
                <div class="menu-sub">
                  ${renderMenuItems(item.items)}
                </div>
              </div>
            `;
          }
          const actionAttr = item.action ? `data-menu-action="${item.action}"` : '';
          const right = item.right ? `<span class="menu-right">${item.right}</span>` : '<span class="menu-right"></span>';
          return `
            <button class="menu-item" type="button" ${actionAttr}>
              ${left}
              ${right}
            </button>
          `;
        }).join('');
      }

      function getMenuItems(appId, menuKey){
        const items = [];
        const addSep = () => { if(items.length && items[items.length-1].type !== 'sep') items.push({ type:'sep' }); };

        if(menuKey === 'file'){
          items.push({ labelKey:'menu.file.newWindow', action:'global:newWindow' });
          addSep();
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.openLink', action:'music:openLink' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.openTrack', action:'player:openTrack' });
            items.push({ labelKey:'menu.player.reload', action:'player:reload' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.openLookbook', action:'clothes:openLookbook' });
            items.push({ labelKey:'menu.clothes.shop', action:'clothes:shop' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.openPress', action:'diev:openPress' });
            items.push({ labelKey:'menu.diev.copyBio', action:'diev:copyBio' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copyEmail', action:'contact:copyEmail' });
            items.push({ labelKey:'menu.contact.openInstagram', action:'contact:openInstagram' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.apply', action:'settings:apply' });
            items.push({ labelKey:'menu.settings.reset', action:'settings:reset' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.openGallery', action:'art:openGallery' });
            items.push({ labelKey:'menu.art.saveImage', action:'art:saveImage' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.openFolder', action:'games:openFolder' });
            items.push({ labelKey:'menu.games.download', action:'games:download' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.openChannel', action:'videos:openChannel' });
            items.push({ labelKey:'menu.videos.copyLink', action:'videos:copyLink' });
          }
          addSep();
          items.push({ labelKey:'menu.file.close', action:'global:close' });
          items.push({ labelKey:'menu.file.logoff', action:'global:logoff' });
        }

        if(menuKey === 'edit'){
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.selectAll', action:'music:selectAll' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
            items.push({ labelKey:'menu.music.clearSelection', action:'music:clearSelection' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.selectAll', action:'player:selectAll' });
            items.push({ labelKey:'menu.player.copyName', action:'player:copyName' });
            items.push({ labelKey:'menu.player.clearSelection', action:'player:clearSelection' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.copy', action:'clothes:copy' });
            items.push({ labelKey:'menu.clothes.selectAll', action:'clothes:selectAll' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.copy', action:'diev:copy' });
            items.push({ labelKey:'menu.diev.selectAll', action:'diev:selectAll' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copy', action:'contact:copy' });
            items.push({ labelKey:'menu.contact.selectAll', action:'contact:selectAll' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.undo', action:'settings:undo' });
            items.push({ labelKey:'menu.settings.redo', action:'settings:redo' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.copy', action:'art:copy' });
            items.push({ labelKey:'menu.art.selectAll', action:'art:selectAll' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.copy', action:'games:copy' });
            items.push({ labelKey:'menu.games.selectAll', action:'games:selectAll' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.copy', action:'videos:copy' });
            items.push({ labelKey:'menu.videos.selectAll', action:'videos:selectAll' });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.copy', action:'about:copy' });
            items.push({ labelKey:'menu.about.selectAll', action:'about:selectAll' });
          }
        }

        if(menuKey === 'view'){
          if(appId === 'music'){
            items.push({
              type:'submenu',
              labelKey:'menu.music.tileSize',
              items:[
                { labelKey:'menu.music.tileSize.small', action:'music:tileSmall', type:'radio', checked: state.music.tileSize === 'small' },
                { labelKey:'menu.music.tileSize.large', action:'music:tileLarge', type:'radio', checked: state.music.tileSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.music.openNewTab', action:'music:toggleNewTab', type:'checkbox', checked: state.music.openNewTab });
            items.push({ labelKey:'menu.music.showIcons', action:'music:toggleIcons', type:'checkbox', checked: state.music.showIcons });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.shuffle', action:'player:toggleShuffle', type:'checkbox', checked: state.mediaplayer.shuffle });
            items.push({
              type:'submenu',
              labelKey:'menu.player.repeat',
              items:[
                { labelKey:'menu.player.repeat.off', action:'player:repeatOff', type:'radio', checked: state.mediaplayer.repeat === 'off' },
                { labelKey:'menu.player.repeat.one', action:'player:repeatOne', type:'radio', checked: state.mediaplayer.repeat === 'one' },
                { labelKey:'menu.player.repeat.all', action:'player:repeatAll', type:'radio', checked: state.mediaplayer.repeat === 'all' }
              ]
            });
            items.push({ labelKey:'menu.player.showPlaylist', action:'player:togglePlaylist', type:'checkbox', checked: state.mediaplayer.showPlaylist });
            items.push({ labelKey:'menu.player.compact', action:'player:toggleCompact', type:'checkbox', checked: state.mediaplayer.compact });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.viewGrid', action:'clothes:viewGrid' });
            items.push({
              type:'submenu',
              labelKey:'menu.clothes.sort',
              items:[
                { labelKey:'menu.clothes.sort.new', action:'clothes:sortNew' },
                { labelKey:'menu.clothes.sort.popular', action:'clothes:sortPopular' }
              ]
            });
            items.push({ labelKey:'menu.clothes.preview', action:'clothes:togglePreview', type:'checkbox', checked: false });
          }
          if(appId === 'diev'){
            items.push({
              type:'submenu',
              labelKey:'menu.diev.textSize',
              items:[
                { labelKey:'menu.diev.textSize.small', action:'diev:textSmall', type:'radio', checked: state.diev.textSize === 'small' },
                { labelKey:'menu.diev.textSize.normal', action:'diev:textNormal', type:'radio', checked: state.diev.textSize === 'normal' },
                { labelKey:'menu.diev.textSize.large', action:'diev:textLarge', type:'radio', checked: state.diev.textSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.diev.highContrast', action:'diev:toggleContrast', type:'checkbox', checked: state.diev.highContrast });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.showQr', action:'contact:showQr' });
            items.push({ labelKey:'menu.contact.compact', action:'contact:compact' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.fullscreen', action:'settings:fullscreen', type:'checkbox', checked: !!document.fullscreenElement });
            items.push({ labelKey:'menu.settings.scanlines', action:'settings:scanlines', type:'checkbox', checked: state.settings.scanlines });
            items.push({ labelKey:'menu.settings.wallpaper', action:'settings:wallpaper' });
          }
          if(appId === 'art'){
            items.push({
              type:'submenu',
              labelKey:'menu.art.zoom',
              items:[
                { labelKey:'menu.art.zoom.50', action:'art:zoom50', type:'radio', checked: state.art.zoom === 50 },
                { labelKey:'menu.art.zoom.100', action:'art:zoom100', type:'radio', checked: state.art.zoom === 100 },
                { labelKey:'menu.art.zoom.200', action:'art:zoom200', type:'radio', checked: state.art.zoom === 200 }
              ]
            });
            items.push({ labelKey:'menu.art.slideshow', action:'art:slideshow' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.grid', action:'games:grid' });
            items.push({
              type:'submenu',
              labelKey:'menu.games.sort',
              items:[
                { labelKey:'menu.games.sort.new', action:'games:sortNew' },
                { labelKey:'menu.games.sort.favorite', action:'games:sortFavorite' }
              ]
            });
          }
          if(appId === 'videos'){
            items.push({
              type:'submenu',
              labelKey:'menu.videos.thumbSize',
              items:[
                { labelKey:'menu.videos.thumbSize.small', action:'videos:thumbSmall', type:'radio', checked: state.videos.thumbSize === 'small' },
                { labelKey:'menu.videos.thumbSize.large', action:'videos:thumbLarge', type:'radio', checked: state.videos.thumbSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.videos.openNewTab', action:'videos:toggleNewTab', type:'checkbox', checked: state.videos.openNewTab });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.version', action:'about:version' });
            items.push({ labelKey:'menu.about.credits', action:'about:credits' });
          }
        }

        if(menuKey === 'help'){
          if(appId === 'music') items.push({ labelKey:'menu.music.where', action:'music:where' });
          if(appId === 'mediaplayer') items.push({ labelKey:'menu.player.tips', action:'player:tips' });
          if(appId === 'clothes') items.push({ labelKey:'menu.clothes.sizing', action:'clothes:sizing' });
          if(appId === 'diev') items.push({ labelKey:'menu.diev.links', action:'diev:links' });
          if(appId === 'contact') items.push({ labelKey:'menu.contact.support', action:'contact:support' });
          if(appId === 'settings') items.push({ labelKey:'menu.settings.what', action:'settings:what' });
          if(appId === 'art') items.push({ labelKey:'menu.art.credits', action:'art:credits' });
          if(appId === 'games') items.push({ labelKey:'menu.games.requirements', action:'games:requirements' });
          if(appId === 'videos') items.push({ labelKey:'menu.videos.tips', action:'videos:tips' });
          if(appId === 'about') items.push({ labelKey:'menu.about.controls', action:'about:controls' });

          addSep();
          items.push({ labelKey:'menu.help.controls', action:'global:controls' });
          items.push({ labelKey:'menu.help.about', action:'global:about' });
        }

        return items;
      }

      function openWindowMenu(winEl, menuKey, anchorEl){
        if(!winEl) return;
        const drop = winEl.querySelector('.menu-drop');
        const appId = getWindowId(winEl);
        if(!drop || !appId) return;

        if(state.menuOpen && state.menuOpen.winId !== appId){
          closeWindowMenu();
        }
        const items = getMenuItems(appId, menuKey);
        if(items.length === 0){
          closeWindowMenu();
          return;
        }
        drop.innerHTML = renderMenuItems(items);
        drop.classList.remove('hidden');

        const winRect = winEl.getBoundingClientRect();
        const anchorRect = anchorEl.getBoundingClientRect();
        drop.style.top = (anchorRect.bottom - winRect.top) + 'px';
        drop.style.left = (anchorRect.left - winRect.left) + 'px';

        winEl.querySelectorAll('.menubar span').forEach(span => {
          span.classList.toggle('active', span.dataset.menu === menuKey);
        });

        state.menuOpen = { winId: appId, menuKey };
      }

      function closeWindowMenu(){
        if(!state.menuOpen) return;
        const winEl = document.getElementById(`win_${state.menuOpen.winId}`);
        if(winEl){
          const drop = winEl.querySelector('.menu-drop');
          if(drop) drop.classList.add('hidden');
          winEl.querySelectorAll('.menubar span').forEach(span => span.classList.remove('active'));
        }
        state.menuOpen = null;
      }

      const modalState = { onConfirm: null };

      function showModal({ title, body, actions }){
        const modal = $('#modal');
        if(!modal) return;
        $('#modalTitle').textContent = title || '';
        $('#modalBody').innerHTML = body || '';
        const actionsEl = $('#modalActions');
        actionsEl.innerHTML = (actions || []).map((a, idx) => `
          <button class="btn bevel" type="button" data-modal-action="${a.action}" style="${a.primary ? 'font-weight:700;' : ''}">${a.label}</button>
        `).join('');
        modal.classList.remove('hidden');
        const firstBtn = actionsEl.querySelector('button');
        if(firstBtn) firstBtn.focus();
      }

      function closeModal(){
        const modal = $('#modal');
        if(!modal) return;
        modal.classList.add('hidden');
        $('#modalBody').innerHTML = '';
        $('#modalActions').innerHTML = '';
        modalState.onConfirm = null;
      }

      function showMessage(titleKey, bodyKey){
        showModal({
          title: t(titleKey),
          body: `<p style="margin:0;">${t(bodyKey)}</p>`,
          actions: [{ label: t('common.ok'), action: 'close', primary: true }]
        });
      }

      function showSelectDialog({ titleKey, descKey, options, confirmKey, onConfirm, selected }){
        const opts = options.map(o => {
          const sel = (selected !== undefined && String(selected) === String(o.value)) ? ' selected' : '';
          return `<option value="${o.value}"${sel}>${o.label}</option>`;
        }).join('');
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <select id="modalSelect" class="bevel-in" style="width:100%; height:26px;">${opts}</select>
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      function showInputDialog({ titleKey, descKey, value, confirmKey, onConfirm }){
        const safeValue = value ? String(value).replace(/"/g, '&quot;') : '';
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <input id="modalInput" class="bevel-in" type="text" value="${safeValue}" style="width:100%; height:26px;" />
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      async function copyText(text){
        if(!text) return false;
        try{
          await navigator.clipboard.writeText(text);
          return true;
        } catch {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand('copy');
          ta.remove();
          return ok;
        }
      }

      function selectAllInWindow(winId){
        const winEl = document.getElementById(`win_${winId}`);
        if(!winEl) return;
        const content = winEl.querySelector('.content');
        if(!content) return;
        const range = document.createRange();
        range.selectNodeContents(content);
        const sel = window.getSelection();
        if(sel){
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }

      function getSelectedText(){
        const sel = window.getSelection();
        return sel ? String(sel.toString()) : '';
      }

      function copySelectedTextOrWarn(){
        const text = getSelectedText();
        if(!text){
          showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
          return;
        }
        copyText(text).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
      }

      function openLink(url, appId){
        if(!url) return;
        if(appId === 'music'){
          if(state.music.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        if(appId === 'videos'){
          if(state.videos.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        window.open(url, '_blank', 'noreferrer');
      }

      function handleMenuAction(action){
        const winId = state.menuOpen ? state.menuOpen.winId : null;
        if(!action) return;

        if(action === 'global:newWindow'){
          const options = APPS.filter(a => a.showInStart !== false).map(a => ({ value: a.id, label: t(a.titleKey) }));
          showSelectDialog({
            titleKey: 'dialog.newWindow.title',
            descKey: 'dialog.newWindow.desc',
            options,
            confirmKey: 'dialog.newWindow.open',
            onConfirm: (val)=>{ openApp(val); }
          });
          return;
        }
        if(action === 'global:close' && winId){
          closeApp(winId);
          return;
        }
        if(action === 'global:logoff'){
          doLogoff();
          return;
        }
        if(action === 'global:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'global:about'){
          openApp('about');
          return;
        }

        if(action === 'music:openLink'){
          const options = MUSIC_LINKS.map(l => ({ value: l.id, label: l.label }));
          const selectedId = Array.from(state.music.selected)[0];
          showSelectDialog({
            titleKey: 'dialog.openLink.title',
            descKey: 'dialog.openLink.desc',
            options,
            confirmKey: 'dialog.openLink.open',
            selected: selectedId,
            onConfirm: (val)=>{
              const link = MUSIC_LINKS.find(l => l.id === val);
              if(link) openLink(link.url, 'music');
            }
          });
          return;
        }
        if(action === 'music:copyLink'){
          const ids = Array.from(state.music.selected);
          const selected = ids.length ? ids : [];
          if(selected.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const urls = selected.map(id => (MUSIC_LINKS.find(l => l.id === id) || {}).url).filter(Boolean);
          copyText(urls.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'music:selectAll'){
          state.music.selected = new Set(MUSIC_LINKS.map(l => l.id));
          applyMusicState();
          return;
        }
        if(action === 'music:clearSelection'){
          state.music.selected = new Set();
          applyMusicState();
          return;
        }
        if(action === 'music:tileSmall'){
          state.music.tileSize = 'small';
          applyMusicState();
          return;
        }
        if(action === 'music:tileLarge'){
          state.music.tileSize = 'large';
          applyMusicState();
          return;
        }
        if(action === 'music:toggleNewTab'){
          state.music.openNewTab = !state.music.openNewTab;
          return;
        }
        if(action === 'music:toggleIcons'){
          state.music.showIcons = !state.music.showIcons;
          applyMusicState();
          return;
        }
        if(action === 'music:where'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'player:openTrack'){
          const options = mp.tracks.map((tr, i) => ({ value: String(i), label: tr.title }));
          if(options.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          showSelectDialog({
            titleKey: 'dialog.openTrack.title',
            descKey: 'dialog.openTrack.desc',
            options,
            confirmKey: 'dialog.openTrack.open',
            selected: mp.idx,
            onConfirm: (val)=>{
              const idx = Number(val);
              state.mediaplayer.selected = new Set([idx]);
              mpSetTrack(idx);
              mpPlay();
            }
          });
          return;
        }
        if(action === 'player:reload'){
          mpLoadTracks();
          return;
        }
        if(action === 'player:selectAll'){
          state.mediaplayer.selected = new Set(mp.tracks.map((_, i) => i));
          mpRender();
          return;
        }
        if(action === 'player:copyName'){
          const ids = Array.from(state.mediaplayer.selected);
          if(ids.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const names = ids.map(i => (mp.tracks[i] ? mp.tracks[i].title : '')).filter(Boolean);
          copyText(names.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'player:clearSelection'){
          state.mediaplayer.selected = new Set();
          mpRender();
          return;
        }
        if(action === 'player:toggleShuffle'){
          state.mediaplayer.shuffle = !state.mediaplayer.shuffle;
          return;
        }
        if(action === 'player:repeatOff'){
          state.mediaplayer.repeat = 'off';
          return;
        }
        if(action === 'player:repeatOne'){
          state.mediaplayer.repeat = 'one';
          return;
        }
        if(action === 'player:repeatAll'){
          state.mediaplayer.repeat = 'all';
          return;
        }
        if(action === 'player:togglePlaylist'){
          state.mediaplayer.showPlaylist = !state.mediaplayer.showPlaylist;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:toggleCompact'){
          state.mediaplayer.compact = !state.mediaplayer.compact;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }

        if(action === 'clothes:openLookbook' || action === 'clothes:shop' || action === 'clothes:sizing' || action === 'clothes:viewGrid' || action === 'clothes:sortNew' || action === 'clothes:sortPopular' || action === 'clothes:togglePreview'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'clothes:copy' || action === 'clothes:selectAll'){
          if(action === 'clothes:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'clothes:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'diev:openPress' || action === 'diev:copyBio'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'diev:copy' || action === 'diev:selectAll'){
          if(action === 'diev:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'diev:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'diev:textSmall'){
          state.diev.textSize = 'small';
          applyDievState();
          return;
        }
        if(action === 'diev:textNormal'){
          state.diev.textSize = 'normal';
          applyDievState();
          return;
        }
        if(action === 'diev:textLarge'){
          state.diev.textSize = 'large';
          applyDievState();
          return;
        }
        if(action === 'diev:toggleContrast'){
          state.diev.highContrast = !state.diev.highContrast;
          applyDievState();
          return;
        }
        if(action === 'diev:links'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'contact:support'){
          showMessage('dialog.support.title', 'dialog.support.body');
          return;
        }
        if(action === 'contact:copyEmail' || action === 'contact:openInstagram' || action === 'contact:showQr' || action === 'contact:compact'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'contact:copy' || action === 'contact:selectAll'){
          if(action === 'contact:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'contact:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'settings:apply'){
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:reset'){
          setLang('en');
          applyWallpaper('classic');
          setAnimations(true);
          state.settings.scanlines = false;
          applyScanlines();
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:undo'){
          showMessage('dialog.noUndo.title', 'dialog.noUndo.body');
          return;
        }
        if(action === 'settings:redo'){
          showMessage('dialog.noRedo.title', 'dialog.noRedo.body');
          return;
        }
        if(action === 'settings:fullscreen'){
          if(!document.fullscreenElement){
            document.documentElement.requestFullscreen().catch(()=>{});
          } else {
            document.exitFullscreen().catch(()=>{});
          }
          return;
        }
        if(action === 'settings:scanlines'){
          state.settings.scanlines = !state.settings.scanlines;
          applyScanlines();
          return;
        }
        if(action === 'settings:wallpaper'){
          openSettingsAndTab('appearance', 'settingsWallpaper');
          return;
        }
        if(action === 'settings:what'){
          showMessage('dialog.settingsWhat.title', 'dialog.settingsWhat.body');
          return;
        }

        if(action === 'art:openGallery' || action === 'art:saveImage' || action === 'art:slideshow' || action === 'art:credits'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'art:copy' || action === 'art:selectAll'){
          if(action === 'art:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'art:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'art:zoom50'){
          state.art.zoom = 50;
          applyArtState();
          return;
        }
        if(action === 'art:zoom100'){
          state.art.zoom = 100;
          applyArtState();
          return;
        }
        if(action === 'art:zoom200'){
          state.art.zoom = 200;
          applyArtState();
          return;
        }

        if(action === 'games:openFolder' || action === 'games:download' || action === 'games:grid' || action === 'games:sortNew' || action === 'games:sortFavorite' || action === 'games:requirements'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'games:copy' || action === 'games:selectAll'){
          if(action === 'games:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'games:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'videos:openChannel'){
          openLink(VIDEO_CHANNEL_URL, 'videos');
          return;
        }
        if(action === 'videos:copyLink'){
          copyText(VIDEO_CHANNEL_URL).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
          return;
        }
        if(action === 'videos:copy' || action === 'videos:selectAll'){
          if(action === 'videos:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'videos:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'videos:thumbSmall'){
          state.videos.thumbSize = 'small';
          return;
        }
        if(action === 'videos:thumbLarge'){
          state.videos.thumbSize = 'large';
          return;
        }
        if(action === 'videos:toggleNewTab'){
          state.videos.openNewTab = !state.videos.openNewTab;
          return;
        }
        if(action === 'videos:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }

        if(action === 'about:version'){
          showMessage('dialog.version.title', 'dialog.version.body');
          return;
        }
        if(action === 'about:credits'){
          showMessage('dialog.credits.title', 'dialog.credits.body');
          return;
        }
        if(action === 'about:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'about:copy' || action === 'about:selectAll'){
          if(action === 'about:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'about:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
      }

      function updateOpenWindowTitles(){
        // Update stored titles and the DOM titlebars
        state.windows.forEach((w, id) => {
          const app = APPS.find(a => a.id === id);
          const title = app ? t(app.titleKey) : (w.titleKey ? t(w.titleKey) : id);
          w.title = title;
          const winEl = document.getElementById(`win_${id}`);
          if(winEl){
            const titleEl = winEl.querySelector('.title-left strong');
            if(titleEl) titleEl.textContent = title;

            const c = winEl.querySelector('.content');
            if(c && CONTENT[id]) {
              c.innerHTML = CONTENT[id]();
            }
            applyI18nTo(winEl);
            applyWindowState(winEl, id);

            const minCtl = winEl.querySelector('[data-action="min"]');
            const closeCtl = winEl.querySelector('[data-action="close"]');
            const resizeCtl = winEl.querySelector('.resize');
            if(minCtl) minCtl.title = t('win.minimize');
            if(closeCtl) closeCtl.title = t('win.close');
            if(resizeCtl) resizeCtl.title = t('win.resize');
            const status = winEl.querySelector('.statusbar');
            if(status){
              let center = status.querySelector('.status-center');
              if(!center){
                center = document.createElement('span');
                center.className = 'status-center';
                center.setAttribute('data-i18n', 'about.footer');
                status.insertBefore(center, status.lastElementChild);
              }
              center.textContent = t('about.footer');
            }

          if(id === 'mediaplayer') {
            setTimeout(mpInitInWindow, 0);
          }
          if(id === 'trash'){
            updateTrashIconUI();
          }
          if(id === 'poetry'){
            renderPoetryWindow();
          }
          if(id === 'clothes'){
            initClothesWindow(winEl);
          }
          if(id === 'settings'){
            initSettingsTabs(winEl);
          }
        }
      });
      }

      function iconSVG(type){
        const common = `viewBox="0 0 16 16" class="pixel" aria-hidden="true"`;
        switch(type){
          case 'folder':
            return `<svg ${common}><rect width="16" height="16" fill="none"/><path d="M1 4h6l1 2h7v8H1z" fill="#ffcc66" stroke="#000" stroke-width="1"/><path d="M1 4h6l1 2H1z" fill="#ffd88a" stroke="#000" stroke-width="1"/></svg>`;
          case 'music':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><path d="M10 3v7.5a2 2 0 1 1-1-1.7V5h-3V3z" fill="#000080"/></svg>`;
          case 'art':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="3" y="3" width="10" height="10" fill="#c0c0c0" stroke="#000"/><path d="M4 11l2-2 2 2 2-3 3 3" stroke="#000080" stroke-width="1" fill="none"/></svg>`;
          case 'game':
            return `<svg ${common}><rect x="2" y="5" width="12" height="7" rx="2" fill="#c0c0c0" stroke="#000"/><rect x="5" y="7" width="1" height="3" fill="#000"/><rect x="4" y="8" width="3" height="1" fill="#000"/><circle cx="11" cy="8" r="1" fill="#ff3366"/><circle cx="12.8" cy="9.5" r="1" fill="#66ccff"/></svg>`;
          case 'video':
            return `<svg ${common}><rect x="1" y="3" width="12" height="10" fill="#fff" stroke="#000"/><path d="M13 6l2-1v6l-2-1z" fill="#000"/></svg>`;
          case 'info':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="5" r="1" fill="#000"/><rect x="7" y="7" width="2" height="6" fill="#000080"/></svg>`;
          case 'mail':
            return `<svg ${common}><rect x="1" y="3" width="14" height="10" fill="#fff" stroke="#000"/><path d="M1 4l7 5 7-5" fill="none" stroke="#000080" stroke-width="1"/></svg>`;
          case 'user':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="6" r="2" fill="#000080"/><path d="M4 13c1-2 7-2 8 0" stroke="#000080" fill="none"/></svg>`;
          case 'settings':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="8" r="3" fill="#c0c0c0" stroke="#000"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.5 3.5l1.4 1.4M11.1 11.1l1.4 1.4M12.5 3.5l-1.4 1.4M4.9 11.1l-1.4 1.4" stroke="#000080"/></svg>`;
          case 'trash':
            return `<svg ${common}><rect x="1" y="3" width="14" height="12" fill="#fff" stroke="#000"/><rect x="4" y="1" width="8" height="2" fill="#c0c0c0" stroke="#000"/><path d="M5 5v8M8 5v8M11 5v8" stroke="#000080"/></svg>`;
          default:
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="4" y="4" width="8" height="8" fill="#000080"/></svg>`;
        }
      }

      const APPS = [
        { id:'trash', titleKey:'app.trash', icon:'trash', iconFile:getTrashIconFile, showInStart:false },
        { id:'poetry', titleKey:'app.poetry', icon:'file', iconFile:'/assets/icons/poetry.png' },
        { id:'clothes', titleKey:'app.clothes', icon:'folder', iconFile:'/assets/icons/Clothes.png' },
        { id:'music', titleKey:'app.music', icon:'music', iconFile:'/assets/icons/Music.png' },
        { id:'mediaplayer', titleKey:'app.mediaplayer', icon:'music', iconFile:'/assets/icons/BLISS%20mediaplayer.png' },
        { id:'art', titleKey:'app.art', icon:'art', iconFile:'/assets/icons/Art.png' },
        { id:'games', titleKey:'app.games', icon:'game', iconFile:'/assets/icons/Games.png' },
        { id:'videos', titleKey:'app.videos', icon:'video', iconFile:'/assets/icons/Videos.png' },
        { id:'about', titleKey:'app.about', icon:'info', iconFile:'/assets/icons/About.png' },
        { id:'contact', titleKey:'app.contact', icon:'mail', iconFile:'/assets/icons/Contact.png' },
        { id:'diev', titleKey:'app.diev', icon:'user', iconFile:'/assets/icons/DIEV.png' },
        { id:'settings', titleKey:'app.settings', icon:'settings', iconFile:'/assets/icons/Settings.png' },
      ];

      const MUSIC_LINKS = [
        {
          id: 'spotify',
          label: 'Spotify',
          url: 'https://open.spotify.com/artist/6bjnHKF2yjUlKyYD15cNGq',
          icon: '/assets/icons/spotify.png'
        },
        {
          id: 'youtubemusic',
          label: 'YouTube Music',
          url: 'https://music.youtube.com/channel/UCSjAU7hceaYUQPZml7HUFgA',
          icon: '/assets/icons/youtubemusic.png'
        },
        {
          id: 'applemusic',
          label: 'Apple Music',
          url: 'https://music.apple.com/us/artist/diev/1586153318',
          icon: '/assets/icons/applemusic.png'
        },
        {
          id: 'amazonmusic',
          label: 'Amazon Music',
          url: 'https://music.amazon.com.br/artists/B00F5I7CC6/diev',
          icon: '/assets/icons/amazonmusic.png'
        },
        {
          id: 'soundcloud',
          label: 'SoundCloud',
          url: 'https://soundcloud.com/die_v/tracks',
          icon: '/assets/icons/soundcloud.png'
        },
        {
          id: 'deezer',
          label: 'Deezer',
          url: 'https://www.deezer.com/en/artist/5170963',
          icon: '/assets/icons/deezer.png'
        }
      ];

      // Update the fallback list with real Instagram thumbnails when needed.
      const CLOTHES_FALLBACK = [
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: '/assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' }
      ];

      const VIDEO_CHANNEL_URL = 'https://www.youtube.com/@diev';

      // Add new poems here. Always provide body_en and body_pt.
      const POEMS = [
        {
          id: 'evolve',
          title: 'Evolve',
          body_en: `To evolve is to change
More than it is to progress
The human race is in its teenager phase
We break everything
And apologize for nothing

And the ones closer to the truth
Are the ones who say, “I know nothing”

But it’s different when it comes from the temple
And when it comes from the streets
Because insanity is a common trait
Associated with unearned wisdom`,
          body_pt: `Evoluir é mudar
Mais do que é progredir
A raça humana vive sua fase adolescente
Quebramos tudo
E não pedimos desculpas por nada

E os que estão mais perto da verdade
São os que dizem: “Eu nada sei”

Mas é diferente quando vem do templo
E quando vem das ruas
Porque a insanidade é um traço comum
Associado à sabedoria não conquistada`
        },
        {
          id: 'tedio',
          title: 'Tedio',
          body_en: `Boredom

The walls bore me
The floor bores me
The blue sky with the bright sun bores me
Sometimes I think I understand
But the eternal boredom ends up taking me
I think about having a beer
Maybe that will cheer me up
The idea excites more than the act
After the first sip
I feel only boredom
They told me that growing old was good
Knowledge
Maturity
All of that brought me boredom
Now I sit doing nothing inside buildings
Waiting for the invitation that changes
The novelty that arrives
While I carry a cigarette
Around the boredom
In the idea I am happy
In the idea I am free and excited
In the act I find myself dull
In this eternal hell of boredom`,
          body_pt: `Tedio

As paredes me entediam
O chão me entedia
O céu azul com o sol brilhando me entedia
As vezes acho que entendo
Mas o tédio eterno acaba me tomando
Penso em tomar uma cerveja
Talvez isso me anime
A ideia anima mais que o ato
Depois do primeiro gole
Sinto apenas o tédio
Me disseram que envelhecer era bom
Conhecimento
Amadurecimento
Tudo isso me trouxe tédio
Agora fico sem fazer nada dentro de prédios
Esperando o convite que mude
A novidade que traga
Enquanto trago um cigarro
Em volta do tédio
Na ideia sou feliz
Na ideia sou livre e animado
No ato me encontro chato
Nesse inferno eterno tédio`
        },
        {
          id: 'la-vai-ela',
          title: 'La vai ela',
          body_en: `There she goes

There she goes to the phone
There I go to the music and a distant stare
There we go, arguing
There we go, hating and loving each other
She drinks from my sip
We share the same visions
We argue hard about the differences
We fight
We love
We look at ourselves
Who are we
Two lost children
Two angry children
In the end we love each other
As always, we love each other`,
          body_pt: `La vai ela

La vai ela pro celular
La vai eu pra musica e olhar distante
La vamos nos discutindo
La vamos nos se odiando e se amando
Ela bebe do meu gole
Dividimos mesmas visões
Discutimos forte as diferenças
Brigamos
Nos amamos
No olhamos
Quem somo nos
Duas crianças perdidas
Duas crianças bravas
No fim nos amamos
Como sempre nos amamos`
        },
        {
          id: 'falta-de-palavras',
          title: 'A falta de palavras',
          body_en: `The lack of words
Is the poet’s suicide
And she wanted me to try harder
To be with her
Cooking dinner
And I wanted to be far away`,
          body_pt: `A falta de palavras
É o suicido do poeta
E ela queria que eu me esforçasse mais
Pra estar com ela
Cozinhando a janta
E eu querendo estar longe`
        },
        {
          id: 'no-fim-foi-isso',
          title: 'No fim foi isso',
          body_en: `In the end, that was it
In the end, that was it
A balancing of egos
One had too much
Another had too little
But it is all right
The scale goes up and down
And in the end, maybe
It levels`,
          body_pt: `No fim foi isso
No fim foi isso
Um balanceamento de egos
Um tinha demais
Outro tinha de menos
Mas esta tudo bem
A balança sobe e desce
E no fim talvez
Nivele`
        },
        {
          id: 'sua-interpretacao',
          title: 'Sua interpretação',
          body_en: `Your interpretation

Why do I feel so much empathy
For the mad?

Me, who considers myself so sane

Did you read this in a sarcastic tone
Or not?`,
          body_pt: `Sua interpretação

Porque tenho tanta empatia
Pelos loucos?

Logo eu que me considero tão são

Você leu isso em tom de sarcasmo
Ou não?`
        },
        {
          id: 'um-sanduiche',
          title: 'Um sanduíche',
          body_en: `A sandwich

When I see lives at the edge of the limit
I realize my life
doesn’t have enough strength
to drive me insane
While I sit at the table
to make a sandwich
My father speaks arrogantly
that no one does anything in this house
except him
So I get up
I pour myself a glass of coke
I observe things
And as always
they remain the same
They seem to never change
But I
I did something
A sandwich`,
          body_pt: `Um sanduíche

Quando vejo vidas a beira do limite
Percebo que a minha vida
não tem forças o suficiente
Para me enlouquecer
Enquanto me sento a mesa
para fazer um sanduíche
Meu pai fala com arrogância
que ninguém faz nada nessa casa
a não ser ele
Ai então me levanto
Me sirvo um copo de coca
Observo as coisas
E como sempre
se mantém iguais
Parecem nunca mudar
Mas eu
Eu fiz algo
Um sanduíche`
        },
        {
          id: 'conversas',
          title: 'Conversas',
          body_en: `Conversations

Conversations are poems
That we throw against the wind
My life looks like yours
I did that to have this
I went through pains like yours
I smiled in some moments
I cried in others
I wish I had made more of these poems`,
          body_pt: `Conversas

Conversas são poesias
Que jogamos contra o vento
Minha vida parece com a sua
Eu fiz aquilo para ter isso
Eu passei por dores como a suas
Eu sorri em momentos
Eu chorei em outros
Queria ter feito mais dessas poesias`
        },
        {
          id: 'a-surpresa-em-sentir-se-livre',
          title: 'A surpresa em sentir-se livre',
          body_en: `The surprise of feeling free

That feeling that catches me by surprise
In a trivial activity
In the midst of total boredom
That feeling of freedom
That arrives between a deep sigh
Arrives unexpectedly
Like the visit
Of an old friend`,
          body_pt: `A surpresa em sentir-se livre

Essa sensação que me pega de surpresa
Em uma atividade banal
Em meio ao tédio total
Essa sensação de liberdade
Que chega entre o suspiro profundo
Chega de surpresa
Como a visita
De um velho amigo`
        },
        {
          id: 'morte-e-compromisso',
          title: 'Morte e compromisso',
          body_en: `Death and commitment

Sometimes I feel taken over
By an idea
An idea that I can die
At any moment
Maybe now...
And that creates a fear
At the same time it creates an excitement
Because it is all so mysterious
How will I die?
What is death like?
And what comes after?
Then time passes
And all of that goes away
And I go back to worrying about life
And about my living problems
And I forget
I forget that death
Death doesn’t care about my commitments`,
          body_pt: `Morte e compromisso

As vezes me sinto tomado
Por uma ideia
Uma ideia de que posso morrer
A qualquer momento
Talvez agora...
E isso gera um medo
ao mesmo tempo que gera uma excitação
Porque é tudo tão misterioso
Como será que vou morrer?
Como será que é a morte?
E oque vem depois?
Ai então o tempo passa
E tudo isso vai embora
E volto a me preocupar com a vida
E com meus problemas de vivo
E me esqueço
Me esqueço de que a morte
A morte não liga pro meus compromissos`
        },
        {
          id: 'quieto',
          title: 'Quieto',
          body_en: `Quiet

All my life I have always found myself
Quiet
In the middle of people always
Quiet
In the middle of family
Quiet
In the middle of friends
Quiet
In the middle of women
Quiet
All my life I have always been very quiet
What should I say?
What difference would it make?
I don’t know
Now I will be silent

2019`,
          body_pt: `Quieto

Minha vida inteira eu sempre me encontrei
Quieto
No meio das pessoas sempre
Quieto
No meio da família
Quieto
No meio dos amigos
Quieto
No meio das mulheres
Quieto
Minha vida inteira eu sempre fui muito quieto
Oque eu deveria dizer?
Que diferença faria?
Não sei
Agora vou me calar

2019`
        },
        {
          id: 'buffalo-branco-extinto',
          title: 'Buffalo branco extinto',
          body_en: `Extinct white buffalo

In the streets people look at me with strangeness
People who spend their whole lives seeing their own reflection
Wherever they go they always see the same
And when something like this appears, they find it strange
A figure so different
So rare
Strange
And interesting
Among the buffalo
I am the extinct white buffalo`,
          body_pt: `Buffalo branco extinto

Nas ruas pessoas me olham com estranheza
Pessoas que passam a vida toda vendo seu próprio reflexo
Aonde quer que vão veem sempre o mesmo
E quando algo assim aparece, estranham
Uma figura tão diferente
Tão rara
Estranha
E Interessante
Em meio aos buffalos
Eu sou o buffalo branco extinto`
        }
      ];

      const CONTENT = {
        about: () => `
          <h2>${t('about.title')}</h2>
          <p>${t('about.p1')}</p>
          <p>${t('about.p2')}</p>
          <p>${t('about.p3')}</p>
          <p>${t('about.p4')}</p>
          <p>${t('about.p5')}</p>
          <p>${t('about.p6')}</p>
        `,
        clothes: () => `
          <h2>${t('clothes.title')}</h2>
          <p class="tiny" data-i18n="clothes.subtitle">${t('clothes.subtitle')}</p>
          <div class="clothes-grid" id="clothesGrid"></div>
          <div class="tiny clothes-status" id="clothesStatus" data-i18n="clothes.loading">${t('clothes.loading')}</div>
        `,
        music: () => `
  <h2>${t('music.title')}</h2>
  <p style="margin:0 0 10px 0;">${t('music.subtitle')}</p>

  <div class="music-grid">
    ${MUSIC_LINKS.map(link => `
      <button class="music-item" type="button" data-music-id="${link.id}" data-music-link="${link.url}">
        <div class="music-icon pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">
          <img class="pixel" src="${link.icon}" width="32" height="32" alt="${link.label}" style="display:block;" />
        </div>
        <span class="music-label" style="font-weight:700;">${link.label}</span>
      </button>
    `).join('')}
  </div>

  <div class="hr98"></div>
  <div class="tiny">${t('music.tip')}</div>
`,

        mediaplayer: () => `
          <h2>${t('player.title')}</h2>
          <div class="card bevel" style="display:flex; flex-direction:column; gap:10px;">
            <div>
              <strong>${t('player.now')}</strong>
              <span id="mpNow" style="margin-left:6px;">—</span>
            </div>

            <audio id="mpAudio" preload="metadata"></audio>

            <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
              <button class="btn bevel" type="button" data-mp-action="prev">⏮ ${t('player.prev')}</button>
              <button class="btn bevel" type="button" data-mp-action="toggle">▶ ${t('player.play')}</button>
              <button class="btn bevel" type="button" data-mp-action="next">⏭ ${t('player.next')}</button>

              <span style="margin-left:auto; display:flex; align-items:center; gap:6px;">
                <span class="kbd">${t('player.vol')}</span>
                <input id="mpVol" type="range" min="0" max="1" step="0.01" value="0.8" />
              </span>
            </div>

            <div class="bevel-in" style="padding:8px;">
              <div id="mpList" style="display:grid; gap:6px;"></div>
              <div id="mpMsg" class="tiny" style="margin-top:8px;"></div>
            </div>

            <div class="tiny">${t('player.autoplay')}</div>
          </div>
        `,

        art: () => `<h2>BLISS — ${t('app.art')}</h2><p>${t('common.soon')}</p>`,
        games: () => {
          if(state.games.view === 'snake'){
            return `
              <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                <button class="btn bevel" type="button" data-games-action="back" data-i18n="games.back">Back</button>
              </div>
              <h2>BLISS — ${t('games.snake')}</h2>
              <div class="snake-layout">
                <div class="snake-board bevel-in" id="snakeBoard">
                  <canvas id="snakeCanvas" class="pixel" width="320" height="320"></canvas>
                  <div class="snake-overlay hidden" id="snakeOverlay">
                    <div class="snake-overlay-box bevel">
                      <strong data-i18n="snake.gameOver">Game Over</strong>
                      <div class="tiny"><span data-i18n="snake.score">Score:</span> <span data-snake-over-score>0</span></div>
                      <button class="btn bevel" type="button" data-snake-action="playAgain" data-i18n="snake.playAgain">Play again</button>
                    </div>
                  </div>
                </div>
                <div class="snake-side">
                  <div class="snake-controls">
                    <button class="btn bevel" type="button" data-snake-action="start" data-i18n="snake.start">Start</button>
                    <button class="btn bevel" type="button" data-snake-action="pause" data-i18n="snake.pause">Pause</button>
                    <div class="tiny"><span data-i18n="snake.score">Score:</span> <strong data-snake-score>0</strong></div>
                    <div class="tiny"><span data-i18n="snake.highScore">High Score:</span> <strong data-snake-high>0</strong></div>
                    <label class="snake-speed">
                      <span class="tiny" data-i18n="snake.speed">Speed:</span>
                      <select data-snake-speed>
                        <option value="slow" data-i18n="snake.speed.slow">Slow</option>
                        <option value="normal" data-i18n="snake.speed.normal">Normal</option>
                        <option value="fast" data-i18n="snake.speed.fast">Fast</option>
                      </select>
                    </label>
                  </div>
                  <div class="tiny snake-instructions" data-i18n="snake.instructions">Use arrow keys or WASD. On mobile, swipe.</div>
                </div>
              </div>
            `;
          }
          return `
            <h2>BLISS — ${t('app.games')}</h2>
            <div class="games-grid">
              <button class="games-item" type="button" data-game-id="snake">
                <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">
                  <img class="pixel" src="/assets/icons/snake.png" width="32" height="32" alt="${t('games.snake')}" style="display:block;" />
                </div>
                <span data-i18n="games.snake">Snake</span>
              </button>
            </div>
          `;
        },
        videos: () => `<h2>BLISS — ${t('app.videos')}</h2><p>${t('common.soon')}</p>`,
        poetry: () => {
          if(POEMS.length === 0){
            return `<h2>${t('app.poetry')}</h2><p>${t('poetry.empty')}</p>`;
          }
          if(state.poetry.view === 'read' && state.poetry.currentId){
            const poem = getPoemById(state.poetry.currentId);
            if(!poem){
              state.poetry.view = 'list';
            } else {
              return `
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                  <button class="btn bevel" type="button" data-poetry-action="back">${t('poetry.back')}</button>
                  <button class="btn bevel" type="button" data-poetry-action="toggleLang">${t('poetry.language')}</button>
                  <span class="kbd">${state.poetry.readLang.toUpperCase()}</span>
                </div>
                <h2>${poem.title}</h2>
                <div class="poem-body">${getPoemBody(poem, state.poetry.readLang)}</div>
              `;
            }
          }
          const grid = POEMS.map(poem => `
            <button class="poetry-item" type="button" data-poem-id="${poem.id}">
              <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">
                <img class="pixel" src="/assets/icons/poetry2.png" width="32" height="32" alt="${poem.title}" style="display:block;" />
              </div>
              <span>${poem.title}</span>
            </button>
          `).join('');
          return `
            <h2>${t('poetry.title')}</h2>
            <div class="poetry-grid">${grid}</div>
          `;
        },
        trash: () => {
          const items = Array.from(state.trash);
          if(items.length === 0){
            return `<div class="trash-empty-msg">${t('dialog.trash.empty')}</div>`;
          }
          const grid = items.map(id => {
            const app = APPS.find(a => a.id === id);
            const label = app ? getIconLabel(app) : id;
            const iconFile = app && app.iconFile
              ? (typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile)
              : null;
            const iconHtml = iconFile
              ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
              : iconSVG(app ? app.icon : 'file');
            return `
                  <button class="trash-item" type="button" data-trash-id="${id}">
                <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
                <span>${label}</span>
              </button>
            `;
          }).join('');
          return `<div class="trash-grid">${grid}</div>`;
        },
        contact: () => `
          <h2>${t('contact.title')}</h2>
          <div class="contact-list" style="display:flex; flex-direction:column; gap:8px;">
            <div><strong>${t('contact.label.instagramDIEV')}</strong> <a href="https://www.instagram.com/die.verson/" target="_blank" rel="noopener noreferrer">@die.verson</a></div>
            <div><strong>${t('contact.label.twitterDIEV')}</strong> <a href="https://x.com/DIE_VERSON" target="_blank" rel="noopener noreferrer">@die_verson</a></div>
            <div><strong>${t('contact.label.emailBusiness')}</strong> <a href="mailto:die.versonbusiness@gmail.com">die.versonbusiness@gmail.com</a></div>
            <div><strong>${t('contact.label.instagramBLISS')}</strong> <a href="https://www.instagram.com/blissworldweb/" target="_blank" rel="noopener noreferrer">@blissworldweb</a></div>
          </div>
        `,
        diev: () => `<h2>${t('diev.title')}</h2><p>${t('diev.p1')}</p>`,
        settings: () => `
          <h2 data-i18n="settings.title">Settings</h2>
          <div class="settings-shell">
            <div class="settings-tabs" role="tablist" aria-label="Settings">
              <button class="settings-tab" type="button" role="tab" data-tab="general" aria-controls="settingsPanel_general" data-i18n="settings.tab.general">General</button>
              <button class="settings-tab" type="button" role="tab" data-tab="language" aria-controls="settingsPanel_language" data-i18n="settings.tab.language">Language</button>
              <button class="settings-tab" type="button" role="tab" data-tab="appearance" aria-controls="settingsPanel_appearance" data-i18n="settings.tab.appearance">Appearance</button>
              <button class="settings-tab" type="button" role="tab" data-tab="performance" aria-controls="settingsPanel_performance" data-i18n="settings.tab.performance">Performance</button>
            </div>
            <div class="settings-panels">
              <div class="settings-panel" role="tabpanel" data-tab="general" id="settingsPanel_general">
                <div class="settings-general">
                  <div class="settings-logo">
                    <img class="pixel" src="/assets/icons/computer.png" width="48" height="48" alt="" />
                  </div>
                  <div class="settings-summary">
                    <strong data-i18n="settings.general.title">BLISS 98</strong>
                    <div class="tiny" data-i18n="settings.general.desc">System properties and preferences for BLISS 98.</div>
                    <div class="settings-block tiny">
                      <span data-i18n="settings.general.user">User:</span>
                      <strong>${state.user ? state.user : t('settings.general.guest')}</strong>
                    </div>
                    <div class="tiny">
                      <span data-i18n="settings.general.version">Version:</span>
                      <span>BLISS 98 — Build 98.0</span>
                    </div>
                    <div class="settings-block tiny">
                      <div data-i18n="settings.general.registeredTo">Registered to:</div>
                      <strong data-i18n="settings.general.registeredName">A Bad Motherfucker</strong>
                      <div data-i18n="settings.general.registeredCode">616-FTP-420-333</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="language" id="settingsPanel_language">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/language.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.languageTab">Language</strong>
                    <div class="tiny" data-i18n="settings.languageDesc">Choose your language for BLISS 98.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-lang="en"><span class="kbd" style="margin-right:6px;">EN</span><span data-i18n="settings.lang.en">English</span></button>
                  <button class="btn bevel" type="button" data-set-lang="pt"><span class="kbd" style="margin-right:6px;">PT</span><span data-i18n="settings.lang.pt">Português (BR)</span></button>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="appearance" id="settingsPanel_appearance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/appearance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.appearanceTab">Appearance</strong>
                    <div class="tiny" data-i18n="settings.appearanceDesc">Customize how BLISS 98 looks.</div>
                  </div>
                </div>
                <div class="settings-block" id="settingsWallpaper">
                  <strong data-i18n="settings.wallpaperTab">Wallpaper</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.wallpaperDesc">Choose a wallpaper for your desktop.</p>
                  <div class="grid2">
                    <button class="btn bevel" type="button" data-set-wallpaper="classic">
                      <span class="wallpaper-swatch" style="background:#008080;"></span>
                      <span data-i18n="wallpaper.classic">Classic Teal</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="bliss">
                      <span class="wallpaper-swatch" style="background:radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%);"></span>
                      <span data-i18n="wallpaper.bliss">Sunrise</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="clouds">
                      <span class="wallpaper-swatch" style="background:linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%);"></span>
                      <span data-i18n="wallpaper.clouds">Clouds</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="diev">
                      <span class="wallpaper-swatch" style="background:repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), linear-gradient(135deg, #0a2333, #114b6a);"></span>
                      <span data-i18n="wallpaper.diev">Grid</span>
                    </button>
                  </div>
                </div>
                <div class="settings-block">
                  <strong data-i18n="settings.scanlinesTab">Scanlines</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.scanlinesDesc">Add scanline effect to the display.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-scanlines="on"><span data-i18n="settings.scanlines.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-scanlines="off"><span data-i18n="settings.scanlines.off">Off</span></button>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="performance" id="settingsPanel_performance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="/assets/icons/performance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.animationsTab">Animations</strong>
                    <div class="tiny" data-i18n="settings.animationsDesc">Toggle window animations.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-animations="on"><span data-i18n="settings.animations.on">On</span></button>
                  <button class="btn bevel" type="button" data-set-animations="off"><span data-i18n="settings.animations.off">Off</span></button>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      function getDisplayTime(){
        const d = new Date();
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        return `${hh}:${mm}`;
      }
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }


      // --- BLISS Media Player ---
      // NOTE: Browsers cannot scan/list a folder on static hosting (GitHub Pages). We use a manifest file.
      // Create: /assets/audio/tracks.json  Example: ["WOW.mp3","People Change.mp3"]
      const MP_MANIFEST_URL = '/assets/audio/tracks.json';
      const MP_STATE_KEY = 'bliss98_mp_state';

      let mp = { tracks: [], idx: 0, playing: false, vol: 0.8, loaded: false };

      function mpSafeTitleFromFilename(name){
        try{
          const base = String(name).split('/').pop();
          const noExt = base.replace(/\.[^/.]+$/,'');
          return decodeURIComponent(noExt);
        } catch {
          return String(name).replace(/\.[^/.]+$/,'');
        }
      }

      function mpLoadState(){
        try{
          const raw = localStorage.getItem(MP_STATE_KEY);
          if(!raw) return;
          const s = JSON.parse(raw);
          if(typeof s.idx === 'number') mp.idx = s.idx;
          if(typeof s.vol === 'number') mp.vol = clamp(s.vol, 0, 1);
        } catch {}
      }

      function mpSaveState(){
        try{ localStorage.setItem(MP_STATE_KEY, JSON.stringify({ idx: mp.idx, vol: mp.vol })); } catch {}
      }

      function mpEls(){
        const win = document.getElementById('win_mediaplayer');
        if(!win) return null;
        return {
          win,
          audio: win.querySelector('#mpAudio'),
          now: win.querySelector('#mpNow'),
          list: win.querySelector('#mpList'),
          msg: win.querySelector('#mpMsg'),
          vol: win.querySelector('#mpVol'),
          toggleBtn: win.querySelector('[data-mp-action="toggle"]'),
        };
      }

      function mpRender(){
        const els = mpEls();
        if(!els) return;
        const { now, list, msg, vol, toggleBtn, audio } = els;

        vol.value = String(mp.vol);
        audio.volume = mp.vol;

        if(!mp.loaded){
          msg.textContent = t('player.loading');
        } else if(mp.tracks.length === 0){
          msg.textContent = t('player.notfound');
        } else {
          msg.textContent = '';
        }

        list.innerHTML = mp.tracks.map((tr, i)=>{
          const active = (i === mp.idx);
          const selected = state.mediaplayer.selected.has(i);
          return `
            <button class="btn bevel mp-item ${selected ? 'selected' : ''}" type="button" data-mp-pick="${i}" data-mp-item="${i}" style="justify-content:flex-start; width:100%; ${active ? 'font-weight:700;' : ''}">
              ${active ? '▶ ' : ''}${tr.title}
            </button>
          `;
        }).join('');

        const cur = mp.tracks[mp.idx];
        now.textContent = cur ? cur.title : '—';
        toggleBtn.innerHTML = mp.playing ? `⏸ ${t('player.pause')}` : `▶ ${t('player.play')}`;
      }

      function mpSetTrack(i){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        mp.idx = clamp(i, 0, mp.tracks.length - 1);
        const cur = mp.tracks[mp.idx];
        audio.src = cur.src;
        audio.volume = mp.vol;
        mpSaveState();
        mpRender();
      }

      async function mpPlay(){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        try{
          await audio.play();
          mp.playing = true;
        } catch {
          mp.playing = false;
        }
        mpRender();
      }

      function mpPause(){
        const els = mpEls();
        if(!els) return;
        els.audio.pause();
        mp.playing = false;
        mpRender();
      }

      function mpNext(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle){
          let next = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && next === mp.idx){
            next = (next + 1) % mp.tracks.length;
          }
          mpSetTrack(next);
          mpPlay();
          return;
        }
        if(!manual && state.mediaplayer.repeat === 'one'){
          mpSetTrack(mp.idx);
          mpPlay();
          return;
        }
        const atEnd = (mp.idx === mp.tracks.length - 1);
        if(atEnd && !manual && state.mediaplayer.repeat === 'off'){
          mpPause();
          return;
        }
        const nextIdx = atEnd ? 0 : mp.idx + 1;
        mpSetTrack(nextIdx);
        mpPlay();
      }

      function mpPrev(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle && !manual){
          let prev = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && prev === mp.idx){
            prev = (prev + 1) % mp.tracks.length;
          }
          mpSetTrack(prev);
          mpPlay();
          return;
        }
        const prevIdx = (mp.idx - 1 + mp.tracks.length) % mp.tracks.length;
        mpSetTrack(prevIdx);
        mpPlay();
      }

      async function mpLoadTracks(){
        mp.loaded = false;
        mp.tracks = [];
        mpRender();

        try{
          const res = await fetch(MP_MANIFEST_URL, { cache: 'no-store' });
          if(!res.ok) throw new Error('manifest not found');
          const data = await res.json();

          const files = Array.isArray(data) ? data : (Array.isArray(data.tracks) ? data.tracks : []);
          const normalized = files
            .map(x => (typeof x === 'string') ? x : (x && x.file) ? x.file : null)
            .filter(Boolean);

          mp.tracks = normalized
            .filter(f => String(f).toLowerCase().endsWith('.mp3'))
            .map(f => ({
              src: '/assets/audio/' + String(f).split('/').pop(),
              title: mpSafeTitleFromFilename(f)
            }));

        } catch {
          mp.tracks = [];
        }

        mp.loaded = true;
        mpLoadState();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        }
        mpRender();
      }

      function mpInitInWindow(){
        const els = mpEls();
        if(!els) return;
        const { audio, vol } = els;

        // Volume
        vol.value = String(mp.vol);
        audio.volume = mp.vol;
        vol.addEventListener('input', ()=>{
          mp.vol = Number(vol.value);
          audio.volume = mp.vol;
          mpSaveState();
        });

        // Ended -> next
        audio.addEventListener('ended', ()=> mpNext());

        // Load tracks each time window is (re)rendered
        mpLoadTracks();
      }

      // Delegate Media Player button clicks
      document.addEventListener('click', (e)=>{
        const actBtn = e.target.closest && e.target.closest('[data-mp-action]');
        if(actBtn){
          const action = actBtn.dataset.mpAction;
          if(action === 'toggle'){
            if(mp.playing) mpPause(); else mpPlay();
          }
          if(action === 'next') mpNext(true);
          if(action === 'prev') mpPrev(true);
        }

        const pickBtn = e.target.closest && e.target.closest('[data-mp-pick]');
        if(pickBtn){
          const idx = Number(pickBtn.dataset.mpPick);
          state.mediaplayer.selected = new Set([idx]);
          mpSetTrack(idx);
          mpPlay();
        }
      });

      document.addEventListener('dblclick', (e)=>{
        const card = e.target.closest && e.target.closest('[data-music-id]');
        if(card && card.dataset && card.dataset.musicLink){
          e.preventDefault();
          openLink(card.dataset.musicLink, 'music');
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem && poemItem.dataset && poemItem.dataset.poemId){
          e.preventDefault();
          state.poetry.view = 'read';
          state.poetry.currentId = poemItem.dataset.poemId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem && trashItem.dataset && trashItem.dataset.trashId){
          e.preventDefault();
          restoreFromTrash([trashItem.dataset.trashId]);
        }
      });

      let lastPoetryTap = { id: null, time: 0 };
      document.addEventListener('pointerdown', (e)=>{
        if(e.pointerType !== 'touch') return;
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard && musicCard.dataset && musicCard.dataset.musicLink){
          const id = musicCard.dataset.musicId;
          state.music.selected = new Set([id]);
          applyMusicState();
          musicCard.dataset.touchOpened = '1';
          openLink(musicCard.dataset.musicLink, 'music');
          return;
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(!poemItem || !poemItem.dataset) return;
        const id = poemItem.dataset.poemId;
        const now = Date.now();
        if(lastPoetryTap.id === id && (now - lastPoetryTap.time) < 320){
          state.poetry.view = 'read';
          state.poetry.currentId = id;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
          lastPoetryTap = { id: null, time: 0 };
        } else {
          lastPoetryTap = { id, time: now };
        }
      });

      document.addEventListener('mouseover', (e)=>{
        if(!state.menuOpen) return;
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          openWindowMenu(winEl, menuKey, menuToggle);
        }
      });

      // Prevent browser text selection on desktop drags (keep selection inside .content and inputs)
      document.addEventListener('selectstart', (e)=>{
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(tag === 'input' || tag === 'textarea') return;
        if(e.target && e.target.closest && e.target.closest('.content')) return;
        e.preventDefault();
      });

      function setUser(name){
        state.user = name;
        localStorage.setItem('bliss98_user', name);
        $('#who').textContent = name ? name : '';
      }

      function showDesktop(){
        $('#login').classList.add('hidden');
        $('#desktop').classList.remove('hidden');
        $('#username').blur();
        applyWallpaper(state.wallpaper);
        renderIcons();
        renderStartMenu();
        tickClock();
      }
      let logoffInProgress = false;

      function showLogin(playBoot = false){
        $('#desktop').classList.add('hidden');
        $('#login').classList.remove('hidden');
        $('#username').focus();
        if(playBoot && SFX.boot && !SFX.boot.played){
          playSfxOnce('boot', { allowPending: true }).then((ok)=>{
            if(!ok && !SFX.boot.played) armBootUnlock();
          });
        }
      }

      function doLogoff(){
        if(logoffInProgress) return;
        logoffInProgress = true;
        closeStartMenu();
        closeCtxMenu();
        closeWindowMenu();
        closeModal();
        playSfxAndWait('logoff').finally(()=>{
          showLogin(false);
          logoffInProgress = false;
        });
      }

      function renderIcons(){
        const grid = $('#iconGrid');
        grid.innerHTML = '';

        const saved = loadIconPositions();
        const metrics = getGridMetrics();
        const occupied = new Map();
        let needsSave = false;
        const defaultLayout = getDefaultIconLayout();

        APPS.filter(app => app.showOnDesktop !== false).forEach((app, idx) => {
          if(app.id !== 'trash' && state.trash.has(app.id)) return;
          const el = document.createElement('div');
          el.className = 'icon';
          el.dataset.appId = app.id;

          const def = defaultLayout[app.id] || legacyDefaultIconPos(idx);
          const pos = (saved && saved[app.id]) ? saved[app.id] : def;
          const placed = placeOnFreeCell(pos.x, pos.y, occupied, metrics);
          el.style.left = placed.x + 'px';
          el.style.top = placed.y + 'px';
          if(placed.changed || !saved[app.id]){
            saved[app.id] = { x: placed.x, y: placed.y };
            needsSave = true;
          }

          const label = getIconLabel(app);
          const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
          const iconHtml = iconFile
            ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
            : iconSVG(app.icon);

          el.innerHTML = `
            <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
            <span>${label}</span>
          `;
          if(state.trash.has(app.id)) el.classList.add('trashed');

          // Click select
          el.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(el.dataset.dragged === '1'){
              // prevent post-drag click from changing selection unexpectedly
              el.dataset.dragged = '0';
              return;
            }
            selectIcon(app.id);
          });

          // Double click open
          el.addEventListener('dblclick', (e)=>{
            e.stopPropagation();
            openApp(app.id);
          });

          makeIconDraggable(el);
          el.addEventListener('contextmenu', (ev)=>{
            ev.preventDefault();
            ev.stopPropagation();
            openCtxMenu(ev.clientX, ev.clientY, 'icon', app.id);
          });
          installLongPress(el, ()=>({ target:'icon', appId: app.id }));
          grid.appendChild(el);
        });
        if(needsSave) saveIconPositions(saved);
      }
      function selectIcon(id){
        state.selectedIconId = id;
        $$('.icon').forEach(i=>i.classList.toggle('selected', i.dataset.appId === id));
      }

      function makeIconDraggable(iconEl){
        let down = false;
        let dragging = false;
        let pointerId = null;

        let startX = 0, startY = 0;
        let group = [];
        let startPositions = []; // { el, id, x, y }

        // group bounds + allowed delta range
        let dxMin = 0, dxMax = 0, dyMin = 0, dyMax = 0;

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;

          e.stopPropagation();
          closeStartMenu();
          closeCtxMenu();

          // If multiple icons are selected and the one we grabbed is selected, drag the whole group.
          const selectedEls = $$('.icon.selected');
          const isSelected = iconEl.classList.contains('selected');
          if(selectedEls.length > 1 && isSelected){
            group = selectedEls;
          } else {
            // Otherwise, single-select the grabbed icon
            selectIcon(iconEl.dataset.appId);
            group = [iconEl];
          }

          down = true;
          dragging = false;
          pointerId = e.pointerId;
          startX = e.clientX;
          startY = e.clientY;

          // Snapshot starting positions
          startPositions = group.map(el => ({
            el,
            id: el.dataset.appId,
            x: parseInt(el.style.left || '0', 10),
            y: parseInt(el.style.top || '0', 10)
          }));

          // Compute bounds in desktop coordinates (relative to desktopArea)
          const area = $('#desktopArea').getBoundingClientRect();
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          startPositions.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x + ICON_SIZE.w);
            maxY = Math.max(maxY, p.y + ICON_SIZE.h);
          });

          // Right/bottom limits match `clampIconPos` behavior (icon right edge <= area.width - 6)
          dxMin = -minX;
          dxMax = (Math.floor(area.width - 6) - maxX);
          dyMin = -minY;
          dyMax = (Math.floor(area.height - 6) - maxY);

          // Prevent accidental post-drag clicks
          group.forEach(el => (el.dataset.dragged = '0'));

          document.body.classList.add('dragging');
          try{ iconEl.setPointerCapture(pointerId); } catch {}

          iconEl.addEventListener('pointermove', onPointerMove);
          iconEl.addEventListener('pointerup', onPointerUp);
          iconEl.addEventListener('pointercancel', onPointerUp);

          e.preventDefault();
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const dxRaw = e.clientX - startX;
          const dyRaw = e.clientY - startY;

          if(!dragging && (Math.abs(dxRaw) + Math.abs(dyRaw) > 4)){
            dragging = true;
          }
          if(!dragging) return;

          // Clamp movement so the whole group stays within the desktop
          const dx = clamp(dxRaw, dxMin, dxMax);
          const dy = clamp(dyRaw, dyMin, dyMax);

          // Move all icons in the group
          startPositions.forEach(p => {
            p.el.style.left = (p.x + dx) + 'px';
            p.el.style.top = (p.y + dy) + 'px';
          });

          e.preventDefault();
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ iconEl.releasePointerCapture(e.pointerId); } catch {}

          iconEl.removeEventListener('pointermove', onPointerMove);
          iconEl.removeEventListener('pointerup', onPointerUp);
          iconEl.removeEventListener('pointercancel', onPointerUp);

          document.body.classList.remove('dragging');

          if(dragging){
            // Save all moved positions in one write
            const saved = loadIconPositions();
            const metrics = getGridMetrics();
            const movedIds = new Set(startPositions.map(p => p.id));
            const occupied = new Map();

            APPS.forEach((app, idx) => {
              if(movedIds.has(app.id)) return;
              const base = saved[app.id] || defaultIconPos(idx);
              const placed = placeOnFreeCell(base.x, base.y, occupied, metrics);
              if(placed.changed || !saved[app.id]){
                saved[app.id] = { x: placed.x, y: placed.y };
              }
            });

            startPositions.forEach(p => {
              let x = parseInt(p.el.style.left || '0', 10);
              let y = parseInt(p.el.style.top || '0', 10);

              if(state.gridSnap){
                const snapped = snapToGrid(x, y);
                x = snapped.x;
                y = snapped.y;
              }

              const placed = placeOnFreeCell(x, y, occupied, metrics);
              p.el.style.left = placed.x + 'px';
              p.el.style.top = placed.y + 'px';
              saved[p.id] = { x: placed.x, y: placed.y };
              p.el.dataset.dragged = '1';
            });
            saveIconPositions(saved);
          }

        if(dragging && isOverTrash(e.clientX, e.clientY)){
          moveIconsToTrash(startPositions.map(p => p.id));
        }

          dragging = false;
          pointerId = null;
        };

        // Pointer events handle mouse + touch + pen
        iconEl.addEventListener('pointerdown', onPointerDown);
      }

      $('#desktopArea').addEventListener('click', ()=>{
        // If a selection drag just happened, do not treat it as a click
        if($('#desktopArea').dataset.selDragged === '1'){
          $('#desktopArea').dataset.selDragged = '0';
          return;
        }
        state.selectedIconId = null;
        $$('.icon').forEach(i=>i.classList.remove('selected'));
        closeStartMenu();
        closeCtxMenu();
      });

      // Right-click / two-finger click on desktop
      $('#desktopArea').addEventListener('contextmenu', (e)=>{
        if($('#desktop').classList.contains('hidden')) return;
        if(e.target && e.target.closest && e.target.closest('.icon')) return;
        e.preventDefault();
        openCtxMenu(e.clientX, e.clientY, 'desktop', null);
      });

      // Long-press on desktop (mobile/touch)
      installLongPress($('#desktopArea'), ()=>({ target:'desktop', appId:null }));

      // Rubber-band selection (Windows 98 style)
      (function installRubberbandSelection(){
        const areaEl = $('#desktopArea');
        const rb = $('#rubberband');
        if(!areaEl || !rb) return;

        let down = false;
        let active = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let lastRect = null;

        function rectFrom(aX, aY, bX, bY){
          const x1 = Math.min(aX, bX);
          const y1 = Math.min(aY, bY);
          const x2 = Math.max(aX, bX);
          const y2 = Math.max(aY, bY);
          return { x:x1, y:y1, w:(x2-x1), h:(y2-y1) };
        }

        function intersects(r, elRect){
          return !(elRect.right < r.x || elRect.left > (r.x + r.w) || elRect.bottom < r.y || elRect.top > (r.y + r.h));
        }

        function updateRubberband(r){
          rb.style.left = r.x + 'px';
          rb.style.top = r.y + 'px';
          rb.style.width = r.w + 'px';
          rb.style.height = r.h + 'px';
        }

        function clearRubberband(){
          rb.classList.add('hidden');
          rb.style.width = '0px';
          rb.style.height = '0px';
          lastRect = null;
          document.body.classList.remove('dragging');
        }

        function selectByRect(r){
          // Select icons whose bounding boxes intersect with the rubberband rect
          const icons = $$('.icon');
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const area = areaEl.getBoundingClientRect();
            const rel = {
              left: rect.left - area.left,
              right: rect.right - area.left,
              top: rect.top - area.top,
              bottom: rect.bottom - area.top,
            };
            const hit = intersects(r, rel);
            icon.classList.toggle('selected', hit);
          });
        }

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Don't start a box if user is interacting with icons/windows/menus
          if(e.target && e.target.closest && (e.target.closest('.icon') || e.target.closest('.window') || e.target.closest('#startMenu') || e.target.closest('#ctxMenu'))){
            return;
          }

          down = true;
          active = false;
          pointerId = e.pointerId;

          const area = areaEl.getBoundingClientRect();
          startX = e.clientX - area.left;
          startY = e.clientY - area.top;

          try{ areaEl.setPointerCapture(pointerId); } catch {}
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const area = areaEl.getBoundingClientRect();
          const curX = e.clientX - area.left;
          const curY = e.clientY - area.top;

          const dx = curX - startX;
          const dy = curY - startY;

          // Activate after small movement threshold
          if(!active && (Math.abs(dx) + Math.abs(dy) > 6)){
            active = true;
            rb.classList.remove('hidden');
            document.body.classList.add('dragging');
            // Close menus
            closeStartMenu();
            closeCtxMenu();
            // Clear single selection
            state.selectedIconId = null;
          }
          if(!active) return;

          e.preventDefault();

          const r = rectFrom(startX, startY, curX, curY);
          lastRect = r;
          updateRubberband(r);
          selectByRect(r);
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ areaEl.releasePointerCapture(e.pointerId); } catch {}

          if(active){
            // Prevent click clear right after box select
            areaEl.dataset.selDragged = '1';
            active = false;
            clearRubberband();
          }
          pointerId = null;
        };

        areaEl.addEventListener('pointerdown', onPointerDown);
        areaEl.addEventListener('pointermove', onPointerMove);
        areaEl.addEventListener('pointerup', onPointerUp);
        areaEl.addEventListener('pointercancel', onPointerUp);
      })();

      function renderStartMenu(){
        const list = $('#startList');
        list.innerHTML = '';
        APPS.filter(app => app.showInStart !== false).forEach(app => {
          const item = document.createElement('div');
          item.className = 'menu-item';
          const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
          item.innerHTML = `
            <div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;">${iconFile ? `<img class="pixel" src="${iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${app.id}" />` : iconSVG(app.icon)}</div>
            <div>${t(app.titleKey)}</div>
          `;
          item.addEventListener('click', ()=>{ openApp(app.id); closeStartMenu(); });
          list.appendChild(item);
        });

        const sep = document.createElement('div');
        sep.className = 'menu-sep';
        list.appendChild(sep);

        const logout = document.createElement('div');
        logout.className = 'menu-item';
        logout.innerHTML = `<div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;"><img class="pixel" src="/assets/icons/logout.png" width="16" height="16" alt="" style="display:block;" /></div><div>${t('menu.logoff')}</div>`;
        logout.addEventListener('click', ()=>{ closeStartMenu(); doLogoff(); });
        list.appendChild(logout);
      }

      function toggleStartMenu(){
        const menu = $('#startMenu');
        const btn = $('#startBtn');
        const isOpen = !menu.classList.contains('hidden');
        if(isOpen) closeStartMenu();
        else { menu.classList.remove('hidden'); btn.classList.add('pressed'); }
      }
      function closeStartMenu(){
        $('#startMenu').classList.add('hidden');
        $('#startBtn').classList.remove('pressed');
      }
      $('#startBtn').addEventListener('click', (e)=>{ e.stopPropagation(); toggleStartMenu(); });

      function defaultWindowRect(){
        const area = $('#desktopArea').getBoundingClientRect();
        const w = clamp(Math.round(area.width * 0.56), 320, 720);
        const h = clamp(Math.round(area.height * 0.58), 240, 640);
        const left = Math.round((area.width - w) * (0.18 + Math.random()*0.18));
        const top = Math.round((area.height - h) * (0.12 + Math.random()*0.18));
        return { left, top, width:w, height:h };
      }

      function openApp(appId){
        const app = APPS.find(a=>a.id===appId);
        if(!app) return;

        if(state.windows.has(appId)){
          const w = state.windows.get(appId);
          w.minimized = false;
          const el = document.getElementById(`win_${appId}`);
          if(el) el.classList.remove('hidden');
          focusWindow(appId);
          renderTaskButtons();
          return;
        }

        const rect = defaultWindowRect();
        const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
        const wstate = {
          id: appId,
          title: t(app.titleKey),
          titleKey: app.titleKey,
          icon: app.icon,
          iconFile: iconFile || null,
          minimized: false,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          z: ++state.zTop,
        };
        state.windows.set(appId, wstate);
        createWindowElement(wstate);
        focusWindow(appId);
        renderTaskButtons();
      }

      function closeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        if(appId === 'games'){
          snakeStop();
          state.games.view = 'list';
          state.games.selectedId = null;
        }
        state.windows.delete(appId);
        const el = document.getElementById(`win_${appId}`);
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
        if(el){
          if(state.animations){
            el.classList.add('anim-close');
            el.addEventListener('animationend', ()=>{ el.remove(); }, { once:true });
          } else {
            el.remove();
          }
        }
      }
      function minimizeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.minimized = true;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          if(state.animations){
            const winRect = el.getBoundingClientRect();
            const taskbar = document.getElementById('taskbar');
            const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
            const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
            const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
            const dx = targetX - winRect.left;
            const dy = targetY - winRect.top;
            el.style.setProperty('--min-x', `${dx}px`);
            el.style.setProperty('--min-y', `${dy}px`);
            el.classList.add('anim-minimize');
            el.addEventListener('animationend', ()=>{
              el.classList.remove('anim-minimize');
              el.classList.add('hidden');
              el.style.removeProperty('--min-x');
              el.style.removeProperty('--min-y');
            }, { once:true });
          } else {
            el.classList.add('hidden');
          }
        }
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
      }

      function focusWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.z = ++state.zTop;
        state.activeWindowId = appId;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          el.style.zIndex = String(w.z);
          $$('.window').forEach(winEl=>{
            winEl.dataset.active = (winEl.id === `win_${appId}`) ? '1' : '0';
            const tb = winEl.querySelector('.titlebar');
            if(tb) tb.style.filter = (winEl.dataset.active==='1') ? 'none' : 'grayscale(0.35) brightness(0.9)';
          });
        }
        renderTaskButtons();
      }

      function createWindowElement(wstate){
        const appId = wstate.id;
        const el = document.createElement('div');
        el.className = 'window';
        el.id = `win_${appId}`;
        el.style.left = wstate.left + 'px';
        el.style.top = wstate.top + 'px';
        el.style.width = wstate.width + 'px';
        el.style.height = wstate.height + 'px';
        el.style.zIndex = String(wstate.z);
        if(state.animations) el.classList.add('anim-open');

        const bodyHTML = (CONTENT[appId] ? CONTENT[appId]() : `<h2>${wstate.title}</h2><p>Sem conteúdo.</p>`);

        el.innerHTML = `
          <div class="frame bevel">
            <div class="titlebar" data-drag="1">
              <div class="title-left">
                <span style="width:16px;height:16px;display:inline-flex;">${wstate.iconFile ? `<img class="pixel" src="${wstate.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(wstate.icon)}</span>
                <strong>${wstate.title}</strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" title="${t('win.minimize')}" data-action="min">_</div>
                <div class="wctl bevel" title="${t('win.close')}" data-action="close">×</div>
              </div>
            </div>
            ${appId === 'trash'
              ? `<div class="trash-actions">
                  <button class="btn bevel" type="button" data-trash-action="restore">${t('dialog.trash.restore')}</button>
                  <button class="btn bevel" type="button" data-trash-action="restoreAll">${t('dialog.trash.restoreAll')}</button>
                  <button class="btn bevel" type="button" data-trash-action="empty">${t('dialog.trash.emptyAction')}</button>
                  <button class="btn bevel" type="button" data-trash-action="help">${t('menu.help.controls')}</button>
                </div>`
              : `<div class="menubar">
                  <span data-menu="file" data-i18n="menubar.file">${t('menubar.file')}</span>
                  <span data-menu="edit" data-i18n="menubar.edit">${t('menubar.edit')}</span>
                  <span data-menu="view" data-i18n="menubar.view">${t('menubar.view')}</span>
                  <span data-menu="help" data-i18n="menubar.help">${t('menubar.help')}</span>
                </div>
                <div class="menu-drop hidden"></div>`}
            <div class="content">${bodyHTML}</div>
            <div class="statusbar">
              <span data-i18n="status.ready">${t('status.ready')}</span>
              <span class="status-center" data-i18n="about.footer">${t('about.footer')}</span>
              <span>BLISS 98</span>
            </div>
          </div>
          <div class="resize" title="${t('win.resize')}"></div>
        `;

        el.addEventListener('mousedown', (e)=>{ e.stopPropagation(); focusWindow(appId); closeStartMenu(); });
        el.addEventListener('click', (e)=>{
          const act = e.target?.dataset?.action;
          if(!act) return;
          e.stopPropagation();
          if(act==='close') closeApp(appId);
          if(act==='min') minimizeApp(appId);
        });

        makeDraggable(el, appId);
        makeResizable(el, appId);

        if(appId === 'mediaplayer') { setTimeout(mpInitInWindow, 0); }
        if(appId === 'trash') { updateTrashIconUI(); }
        if(appId === 'clothes') { setTimeout(()=>initClothesWindow(el), 0); }
        if(appId === 'settings') { setTimeout(()=>initSettingsTabs(el), 0); }
        if(appId === 'games') { setTimeout(()=>initGamesWindow(el), 0); }

        $('#windows').appendChild(el);
        applyI18nTo(el);
        applyWindowState(el, appId);
        if(appId === 'trash') updateTrashIconUI();
        if(state.animations){
          el.addEventListener('animationend', ()=>{ el.classList.remove('anim-open'); }, { once:true });
        }
      }

      function makeDraggable(winEl, appId){
        const titlebar = winEl.querySelector('[data-drag="1"]');
        if(!titlebar) return;

        let dragging = false;
        let pointerId = null;
        let startX = 0, startY = 0, startL = 0, startT = 0;

        const onPointerDown = (e)=>{
          // Ignore non-primary mouse buttons
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Ignore clicks on window control buttons
          if(e.target && e.target.dataset && e.target.dataset.action) return;

          e.preventDefault();
          dragging = true;
          document.body.classList.add('dragging');
          pointerId = e.pointerId;

          // Focus window when starting drag
          try{ focusWindow(appId); } catch {}

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startL = rect.left;
          startT = rect.top;

          // Capture pointer so drag continues even if the finger leaves the titlebar
          try{ titlebar.setPointerCapture(pointerId); } catch {}

          titlebar.addEventListener('pointermove', onPointerMove);
          titlebar.addEventListener('pointerup', onPointerUp);
          titlebar.addEventListener('pointercancel', onPointerUp);
        };

        const onPointerMove = (e)=>{
          if(!dragging) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const newL = clamp(startL + dx - area.left, 0, area.width - 80);
          const newT = clamp(startT + dy - area.top, 0, area.height - 60);

          winEl.style.left = newL + 'px';
          winEl.style.top = newT + 'px';

          const w = state.windows.get(appId);
          if(w){ w.left = newL; w.top = newT; }
        };

        const onPointerUp = (e)=>{
          if(pointerId !== null && e.pointerId !== pointerId) return;

          dragging = false;
          pointerId = null;
          document.body.classList.remove('dragging');

          try{ titlebar.releasePointerCapture(e.pointerId); } catch {}

          titlebar.removeEventListener('pointermove', onPointerMove);
          titlebar.removeEventListener('pointerup', onPointerUp);
          titlebar.removeEventListener('pointercancel', onPointerUp);
        };

        // Pointer events handle mouse + touch + pen
        titlebar.addEventListener('pointerdown', onPointerDown);
      }

      function makeResizable(winEl, appId){
        const handle = winEl.querySelector('.resize');
        const EDGE = 6; // px

        let resizing = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let startW = 0, startH = 0;
        let startL = 0, startT = 0;
        let dir = '';

        function getDir(clientX, clientY){
          const r = winEl.getBoundingClientRect();
          const left = (clientX - r.left) <= EDGE;
          const right = (r.right - clientX) <= EDGE;
          const top = (clientY - r.top) <= EDGE;
          const bottom = (r.bottom - clientY) <= EDGE;

          let d = '';
          if(top) d += 'n';
          else if(bottom) d += 's';
          if(left) d += 'w';
          else if(right) d += 'e';
          return d;
        }

        function cursorFor(d){
          if(d === 'n' || d === 's') return 'ns-resize';
          if(d === 'e' || d === 'w') return 'ew-resize';
          if(d === 'ne' || d === 'sw') return 'nesw-resize';
          if(d === 'nw' || d === 'se') return 'nwse-resize';
          return '';
        }

        function beginResize(e, resizeDir){
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          e.preventDefault();

          resizing = true;
          pointerId = e.pointerId;
          dir = resizeDir;
          document.body.classList.add('dragging');

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startW = rect.width;
          startH = rect.height;
          startL = rect.left;
          startT = rect.top;

          try{ winEl.setPointerCapture(pointerId); } catch {}

          winEl.addEventListener('pointermove', onPointerMove);
          winEl.addEventListener('pointerup', onPointerUp);
          winEl.addEventListener('pointercancel', onPointerUp);
        }

        function onPointerMove(e){
          if(!resizing) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;
          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const MIN_W = 280;
          const MIN_H = 200;

          let newW = startW;
          let newH = startH;
          let newL = startL;
          let newT = startT;

          if(dir.includes('e')) newW = clamp(startW + dx, MIN_W, 920);
          if(dir.includes('s')) newH = clamp(startH + dy, MIN_H, 780);

          if(dir.includes('w')){
            newW = clamp(startW - dx, MIN_W, 920);
            newL = startL + (startW - newW);
          }
          if(dir.includes('n')){
            newH = clamp(startH - dy, MIN_H, 780);
            newT = startT + (startH - newH);
          }

          // Clamp to desktop bounds
          newL = clamp(newL - area.left, 0, area.width - 60) + area.left;
          newT = clamp(newT - area.top, 0, area.height - 40) + area.top;

          winEl.style.width = newW + 'px';
          winEl.style.height = newH + 'px';
          winEl.style.left = (newL - area.left) + 'px';
          winEl.style.top = (newT - area.top) + 'px';

          const w = state.windows.get(appId);
          if(w){
            w.width = newW;
            w.height = newH;
            w.left = (newL - area.left);
            w.top = (newT - area.top);
          }
        }

        function onPointerUp(e){
          if(pointerId !== null && e.pointerId !== pointerId) return;
          resizing = false;
          pointerId = null;
          dir = '';
          document.body.classList.remove('dragging');

          try{ winEl.releasePointerCapture(e.pointerId); } catch {}

          winEl.removeEventListener('pointermove', onPointerMove);
          winEl.removeEventListener('pointerup', onPointerUp);
          winEl.removeEventListener('pointercancel', onPointerUp);
        }

        // Mouse hover cursor change near edges
        winEl.addEventListener('mousemove', (e)=>{
          if(resizing) return;
          // don't override cursor on controls/titlebar
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          const c = cursorFor(d);
          winEl.style.cursor = c || '';
        });
        winEl.addEventListener('mouseleave', ()=>{
          if(!resizing) winEl.style.cursor = '';
        });

        // Edge/corner resize start
        winEl.addEventListener('pointerdown', (e)=>{
          if(resizing) return;
          // ignore titlebar drag and window control clicks
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          if(!d) return;
          beginResize(e, d);
        });

        // Keep the existing bottom-right handle resize too
        if(handle){
          handle.addEventListener('pointerdown', (e)=>{
            // If we already started edge resize, ignore
            if(resizing) return;
            beginResize(e, 'se');
          });
        }
      }

      function renderTaskButtons(){
        const host = $('#taskButtons');
        host.innerHTML = '';
        const wins = Array.from(state.windows.values()).sort((a,b)=>a.title.localeCompare(b.title));
        wins.forEach(w => {
          const b = document.createElement('div');
          b.className = 'btn bevel';
          const isActive = (state.activeWindowId === w.id && !w.minimized);
          if(isActive) b.classList.add('pressed');
          b.style.maxWidth = '240px';
          b.style.overflow = 'hidden';
          b.style.whiteSpace = 'nowrap';
          b.style.textOverflow = 'ellipsis';
          b.innerHTML = `
            <span style="width:16px;height:16px;display:inline-flex;">${w.iconFile ? `<img class="pixel" src="${w.iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${w.id}" />` : iconSVG(w.icon)}</span>
            <span>${w.title}</span>
          `;
          b.addEventListener('click', (e)=>{
            e.stopPropagation();
            closeStartMenu();
            if(w.minimized){
              w.minimized = false;
              const el = document.getElementById(`win_${w.id}`);
              if(el){
                el.classList.remove('hidden');
                if(state.animations){
                  const winRect = el.getBoundingClientRect();
                  const taskbar = document.getElementById('taskbar');
                  const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
                  const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
                  const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
                  const dx = targetX - winRect.left;
                  const dy = targetY - winRect.top;
                  el.style.setProperty('--min-x', `${dx}px`);
                  el.style.setProperty('--min-y', `${dy}px`);
                  el.classList.add('anim-restore');
                  el.addEventListener('animationend', ()=>{
                    el.classList.remove('anim-restore');
                    el.style.removeProperty('--min-x');
                    el.style.removeProperty('--min-y');
                  }, { once:true });
                }
              }
              focusWindow(w.id);
            } else if(state.activeWindowId === w.id){
              minimizeApp(w.id);
            } else {
              focusWindow(w.id);
            }
          });
          host.appendChild(b);
        });
      }

      function tickClock(){
        $('#clock').textContent = getDisplayTime();
        setTimeout(tickClock, 1000);
      }

      function enter(){
        const name = $('#username').value.trim();
        if(!name){ $('#username').focus(); return; }
        setUser(name);
        showDesktop();
        if(!state.windows.has('mediaplayer')) openApp('mediaplayer');
        if(!state.windows.has('music')) openApp('music');
        setTimeout(()=>{ mpPlay(); }, 0);
      }

      $('#enter').addEventListener('click', enter);
      $('#username').addEventListener('keydown', (e)=>{ if(e.key==='Enter') enter(); });
      $('#langBtn').addEventListener('click', (e)=>{ e.preventDefault(); toggleLang(); });

      $('#clearProfile').addEventListener('click', ()=>{
        localStorage.removeItem('bliss98_user');
        $('#username').value = '';
        $('#username').focus();
      });

      document.addEventListener('keydown', (e)=>{
        if(e.key==='Escape'){
          closeStartMenu();
          closeCtxMenu();
          closeWindowMenu();
          closeModal();
        }
        if(snakeHandleKey(e)) return;
        if(e.key === 'Enter' && state.activeWindowId === 'poetry' && state.poetry.view === 'list' && state.poetry.selectedId){
          state.poetry.view = 'read';
          state.poetry.currentId = state.poetry.selectedId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        if(e.key === 'Enter' && state.activeWindowId === 'games' && state.games.view === 'list' && state.games.selectedId){
          openGameFromHub(state.games.selectedId);
        }

        // Keyboard context menu (Shift+F10)
        if(e.shiftKey && e.key === 'F10'){
          if($('#desktop').classList.contains('hidden')) return;
          e.preventDefault();
          const area = $('#desktopArea').getBoundingClientRect();
          openCtxMenu(area.left + area.width/2, area.top + area.height/2, 'desktop', null);
        }

        // Basic keyboard navigation inside context menu
        const menu = $('#ctxMenu');
        if(menu && !menu.classList.contains('hidden')){
          const items = Array.from(menu.querySelectorAll('.ctx-item'));
          const idx = items.indexOf(document.activeElement);
          if(e.key === 'ArrowDown'){
            e.preventDefault();
            const next = items[Math.min(items.length-1, Math.max(0, idx+1))] || items[0];
            if(next) next.focus();
          }
          if(e.key === 'ArrowUp'){
            e.preventDefault();
            const prev = items[Math.max(0, idx-1)] || items[items.length-1];
            if(prev) prev.focus();
          }
        }
      });
      document.addEventListener('click', (e)=>{
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem){
          const id = poemItem.dataset.poemId;
          if(e.detail > 1) return;
          selectPoetryItem(id);
          return;
        }
        const poemAction = e.target.closest && e.target.closest('[data-poetry-action]');
        if(poemAction && poemAction.dataset && poemAction.dataset.poetryAction){
          if(poemAction.dataset.poetryAction === 'back'){
            state.poetry.view = 'list';
            state.poetry.currentId = null;
            renderPoetryWindow();
          }
          if(poemAction.dataset.poetryAction === 'toggleLang'){
            state.poetry.readLang = (state.poetry.readLang === 'en') ? 'pt' : 'en';
            renderPoetryWindow();
          }
          return;
        }

        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem){
          const id = trashItem.dataset.trashId;
          if(e.ctrlKey || e.metaKey){
            if(state.trashSelection.has(id)) state.trashSelection.delete(id);
            else state.trashSelection.add(id);
          } else {
            state.trashSelection = new Set([id]);
          }
          renderTrashWindow();
          return;
        }

        const trashBtn = e.target.closest && e.target.closest('[data-trash-action]');
        if(trashBtn && trashBtn.dataset){
          const action = trashBtn.dataset.trashAction;
          if(action === 'help'){
            showMessage('dialog.controls.title', 'dialog.controls.body');
            return;
          }
          if(action === 'restore'){
            const ids = state.trashSelection.size ? Array.from(state.trashSelection) : [];
            if(ids.length){
              restoreFromTrash(ids);
              state.trashSelection = new Set();
            }
          }
          if(action === 'restoreAll'){
            restoreFromTrash(Array.from(state.trash));
            state.trashSelection = new Set();
          }
          if(action === 'empty'){
            emptyTrash();
            state.trashSelection = new Set();
          }
          return;
        }

        const modalAction = e.target.closest && e.target.closest('[data-modal-action]');
        if(modalAction && modalAction.dataset && modalAction.dataset.modalAction){
          const act = modalAction.dataset.modalAction;
          if(act === 'confirm' && typeof modalState.onConfirm === 'function'){
            const select = $('#modalSelect');
            const input = $('#modalInput');
            const value = input ? input.value : (select ? select.value : null);
            modalState.onConfirm(value);
          }
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modal'){
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modalClose'){
          closeModal();
          return;
        }

        const menuItem = e.target.closest && e.target.closest('[data-menu-action]');
        if(menuItem && menuItem.dataset && menuItem.dataset.menuAction){
          e.preventDefault();
          e.stopPropagation();
          handleMenuAction(menuItem.dataset.menuAction);
          closeWindowMenu();
          return;
        }
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          e.preventDefault();
          e.stopPropagation();
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          if(state.menuOpen && state.menuOpen.winId === getWindowId(winEl) && state.menuOpen.menuKey === menuKey){
            closeWindowMenu();
          } else {
            openWindowMenu(winEl, menuKey, menuToggle);
          }
          return;
        }

        const btn = e.target.closest && e.target.closest('[data-set-lang]');
        if(btn && btn.dataset && btn.dataset.setLang){
          setLang(btn.dataset.setLang);
        }
        const wpBtn = e.target.closest && e.target.closest('[data-set-wallpaper]');
        if(wpBtn && wpBtn.dataset && wpBtn.dataset.setWallpaper){
          applyWallpaper(wpBtn.dataset.setWallpaper);
        }
        const animBtn = e.target.closest && e.target.closest('[data-set-animations]');
        if(animBtn && animBtn.dataset && animBtn.dataset.setAnimations){
          setAnimations(animBtn.dataset.setAnimations === 'on');
        }
        const scanBtn = e.target.closest && e.target.closest('[data-set-scanlines]');
        if(scanBtn && scanBtn.dataset && scanBtn.dataset.setScanlines){
          setScanlines(scanBtn.dataset.setScanlines === 'on');
        }
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard){
          if(musicCard.dataset && musicCard.dataset.touchOpened === '1'){
            delete musicCard.dataset.touchOpened;
            return;
          }
          const id = musicCard.dataset.musicId;
          if(e.ctrlKey || e.metaKey){
            if(state.music.selected.has(id)) state.music.selected.delete(id);
            else state.music.selected.add(id);
          } else {
            state.music.selected = new Set([id]);
          }
          applyMusicState();
          return;
        }

        const ctxBtn = e.target.closest && e.target.closest('[data-ctx-action]');
        if(ctxBtn && ctxBtn.dataset && ctxBtn.dataset.ctxAction){
          e.preventDefault();
          e.stopPropagation();
          handleCtxAction(ctxBtn.dataset.ctxAction);
          closeCtxMenu();
        }
        if(!e.target.closest || (!e.target.closest('.menu-drop') && !e.target.closest('.menubar'))){
          closeWindowMenu();
        }
      });

      (function init(){
        const savedLang = localStorage.getItem('bliss98_lang') || 'en';
        state.lang = (savedLang === 'pt') ? 'pt' : 'en';

        const saved = localStorage.getItem('bliss98_user');
        if(saved){ setUser(saved); $('#username').value = saved; }

        state.gridSnap = loadGridSnap();
        state.wallpaper = loadWallpaper();
        state.animations = loadAnimations();
        state.settings.scanlines = loadScanlines();
        state.snake.highScore = loadSnakeHighScore();
        state.trash = new Set(loadTrash());
        state.iconLabels = loadIconLabels();
        state.trashSelection = new Set();

        // Apply translations immediately (default is English)
        applyI18n();
        applyScanlines();
        updateTrashIconUI();

        initSfx();
        showLogin(true);
        document.addEventListener('click', ()=>{ closeStartMenu(); closeCtxMenu(); });
        const cm = $('#ctxMenu');
        if(cm){
          cm.addEventListener('click', (ev)=>{
            const btn = ev.target.closest && ev.target.closest('[data-ctx-action]');
            if(btn && btn.dataset && btn.dataset.ctxAction){
              ev.preventDefault();
              ev.stopPropagation();
              handleCtxAction(btn.dataset.ctxAction);
              closeCtxMenu();
              return;
            }
            // Prevent clicks inside the menu from bubbling to the document closer
            ev.stopPropagation();
          });
        }
      })();
    </script>
  </body>
</html>
