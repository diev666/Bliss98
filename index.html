<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BLISS 98</title>
    <link rel="icon" href="./assets/favicon/favicon.ico" sizes="any" />
    <link rel="icon" type="image/png" href="./assets/favicon/favicon-32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="./assets/favicon/favicon-16.png" sizes="16x16" />
    <link rel="apple-touch-icon" href="./assets/favicon/apple-touch-icon.png" />
    <link rel="manifest" href="./assets/favicon/site.webmanifest" />
    <style>
      :root{
        --bg:#008080;
        --shadow-dark:#0a0a0a;
        --shadow-mid:#808080;
        --shadow-light:#dfdfdf;
        --shadow-white:#ffffff;
        --title:#000080;
        --title2:#1084d0;
        --titlebar-text:#ffffff;
        --task:#c0c0c0;
        --text:#000;
        --menu:#c0c0c0;
        --select:#000080;
        --select-text:#ffffff;
        --content-bg:#ffffff;
        --content-text:#000000;
        --panel-bg:#e9e9e9;
        --panel-in:#ffffff;
        --panel-border:#808080;
        --input-bg:#ffffff;
        --input-text:#000000;
        --menu-text:#000000;
        --link:#0000ee;
        --sep:#9a9a9a;
        --sep-light:#ffffff;
        --selection-bg:#d6e6ff;
        --selection-border:#000080;
        --kbd-bg:#ffffff;
        --kbd-border:#999999;
        --btn-text:#000000;
        --muted-text:#4b4b4b;
      }
      body.theme-xp98{
        --shadow-dark:#2b3a52;
        --shadow-mid:#6f86a6;
        --shadow-light:#edf2fb;
        --shadow-white:#ffffff;
        --task:#d4d9e3;
        --text:#000000;
        --menu:#dfe4ec;
        --select:#316ac5;
        --select-text:#ffffff;
        --content-bg:#ffffff;
        --content-text:#000000;
        --panel-bg:#dfe4ec;
        --panel-in:#ffffff;
        --panel-border:#7f93ad;
        --input-bg:#ffffff;
        --input-text:#000000;
        --menu-text:#000000;
        --link:#1b4f9c;
        --sep:#9aa9c2;
        --sep-light:#ffffff;
        --selection-bg:#c8d8f2;
        --selection-border:#316ac5;
        --kbd-bg:#f7f7f7;
        --kbd-border:#7f93ad;
        --btn-text:#000000;
        --muted-text:#4b4b4b;
      }
      body.theme-xp98 .taskbar.bevel{
        background:linear-gradient(90deg, #1d3e8a, #2a5db3);
      }
      body.theme-xp98 #startBtn.btn.bevel{
        background:linear-gradient(180deg, #38c85a, #1f9b3f);
        color:#ffffff;
        border-top-color:#c7f3cf;
        border-left-color:#c7f3cf;
        border-right-color:#0b6d2a;
        border-bottom-color:#0b6d2a;
        box-shadow: 1px 1px 0 0 rgba(255,255,255,0.25) inset, -1px -1px 0 0 rgba(0,0,0,0.2) inset;
      }
      body.theme-xp98 .tray.bevel{
        background:linear-gradient(180deg, #5a8fe2, #3f6fc8);
      }
      body.dark{
        --shadow-dark:#000000;
        --shadow-mid:#1c1c1c;
        --shadow-light:#3a3a3a;
        --shadow-white:#5a5a5a;
        --title:#1b3f7a;
        --title2:#0a2e5c;
        --titlebar-text:#f1f1f1;
        --task:#2a2a2a;
        --text:#e6e6e6;
        --menu:#2a2a2a;
        --select:#1b3f7a;
        --select-text:#f1f1f1;
        --content-bg:#1f1f1f;
        --content-text:#e6e6e6;
        --panel-bg:#303030;
        --panel-in:#1b1b1b;
        --panel-border:#5a5a5a;
        --input-bg:#1b1b1b;
        --input-text:#e6e6e6;
        --menu-text:#f1f1f1;
        --link:#8bb6ff;
        --sep:#4a4a4a;
        --sep-light:#2a2a2a;
        --selection-bg:#1c3f66;
        --selection-border:#9ec5ff;
        --kbd-bg:#1b1b1b;
        --kbd-border:#5a5a5a;
        --btn-text:#e0e0e0;
        --muted-text:#b9b9b9;
      }
      body.titlebar-blank .titlebar{
        background:transparent !important;
        background-image:none !important;
        box-shadow:none !important;
        color:var(--titlebar-text);
        text-shadow:1px 1px 0 rgba(0,0,0,0.55);
        border-top:1px solid var(--shadow-white);
        border-left:1px solid var(--shadow-white);
        border-right:1px solid var(--shadow-dark);
        border-bottom:1px solid var(--shadow-dark);
      }
      body.titlebar-blank .modal-titlebar{
        background:transparent !important;
        background-image:none !important;
        box-shadow:none !important;
        color:var(--titlebar-text);
        text-shadow:1px 1px 0 rgba(0,0,0,0.55);
        border-top:1px solid var(--shadow-white);
        border-left:1px solid var(--shadow-white);
        border-right:1px solid var(--shadow-dark);
        border-bottom:1px solid var(--shadow-dark);
      }
      body.titlebar-blank .start-side{
        background:var(--task);
        color:var(--text);
      }
      body.retro-glow .window .frame{
        box-shadow: 0 0 10px rgba(255,255,255,0.12);
      }
      body.retro-glow .icon span{
        text-shadow: 0 0 6px rgba(255,255,255,0.35);
      }

      html,body{height:100%;margin:0;}
      body{
        background:var(--bg);
        color:var(--text);
        font-family:"MS Sans Serif", Tahoma, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        font-size:13px;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        -webkit-touch-callout:none;
        -webkit-tap-highlight-color: transparent;
      }
      .hidden{display:none !important;}
      .pixel{image-rendering:pixelated; image-rendering:crisp-edges;}

      .bevel{
        background:var(--task);
        border-top:2px solid var(--shadow-white);
        border-left:2px solid var(--shadow-white);
        border-right:2px solid var(--shadow-dark);
        border-bottom:2px solid var(--shadow-dark);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .bevel-in{
        background:var(--panel-in);
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .btn{
        height:24px;
        padding:0 10px;
        display:inline-flex;
        align-items:center;
        gap:6px;
        cursor:pointer;
        color:var(--btn-text);
      }
      .btn:active{ filter:brightness(0.97); }
      .btn.pressed{
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }

      #app{height:100%;}

      #login{
        position:absolute; inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:radial-gradient(circle at 40% 35%, rgba(255,255,255,.15), rgba(255,255,255,0) 45%), var(--bg);
      }
      .login-panel{
        width:min(520px, calc(100% - 32px));
        padding:14px;
      }
      .login-title{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        margin-bottom:10px;
      }
      .login-left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .lang-btn{
        min-width:70px;
        justify-content:center;
        font-weight:700;
      }
      .logo{ width:34px; height:34px; }
      .login-title h1{
        font-size:18px;
        margin:0;
        letter-spacing:0.2px;
      }
      .login-sub{opacity:.9;margin:2px 0 0 0;}
      .field-row{display:flex; gap:8px; align-items:center; margin-top:12px;}
      label{white-space:nowrap;}
      input[type="text"]{
        flex:1;
        height:26px;
        padding:0 8px;
        outline:none;
        background:var(--input-bg);
        color:var(--input-text);
        border:1px solid var(--panel-border);
      }
      .login-footer{display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:10px;}
      .tiny{font-size:12px; opacity:.85; user-select:text;}
      .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:var(--kbd-bg); padding:1px 5px; border:1px solid var(--kbd-border);}

      #desktop{ position:absolute; inset:0; background:var(--bg); }
      #desktop.wallpaper-matrix{
        background-color:#020202;
        background-image:
          repeating-linear-gradient(90deg, rgba(0,255,90,0.18) 0 1px, transparent 1px 4px),
          repeating-linear-gradient(180deg, rgba(0,255,90,0.12) 0 2px, transparent 2px 10px),
          linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.9));
        background-size: 4px 100%, 100% 120px, 100% 100%;
        background-repeat: repeat;
        animation: matrixFlow 6s linear infinite;
      }
      @keyframes matrixFlow{
        from{ background-position: 0 0, 0 0, 0 0; }
        to{ background-position: 0 0, 0 240px, 0 0; }
      }
      .desktop-area{
        position:absolute; inset:0 0 30px 0;
        padding:10px;
      }
      .drag-layer{
        position:absolute;
        inset:0;
        z-index:9999;
        pointer-events:none;
      }
      .drag-layer.active{
        pointer-events:auto;
      }
      .games-drag-ghost{
        position:absolute;
        width:92px;
        opacity:0.85;
        pointer-events:none;
      }
      .games-drag-ghost.big{
        width:140px;
      }

      .icons{
        position:relative;
        width:100%;
        height:100%;
      }
      .icon{
        position:absolute;
        width:92px;
        height:88px;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        gap:6px;
        padding:6px 4px;
        border:1px solid transparent;
        cursor:default;
      }
      .icon[data-app-id="settings"] img{
        width:36px;
        height:36px;
      }
      .icon.selected{
        border:1px dotted rgba(255,255,255,0.9);
        background:rgba(0,0,0,0.12);
      }
      .icon span{
        color:#fff;
        text-align:center;
        line-height:1.1;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.65);
        padding:1px 2px;
        max-width:86px;
        word-break:break-word;
      }
      .icon.selected span{
        background:var(--select);
        outline:1px dotted var(--select-text);
      }
      .icon.trashed{
        opacity:0.65;
      }
      .wallpaper-swatch{
        width:18px;
        height:18px;
        border:1px solid #000;
        box-shadow: inset 1px 1px 0 rgba(255,255,255,0.35);
      }

      .taskbar{
        position:absolute;
        left:0; right:0; bottom:0;
        height:30px;
        display:flex;
        align-items:center;
        gap:6px;
        padding:2px 6px;
        color:var(--text);
      }
      .task-left{display:flex; align-items:center; gap:6px;}
      .task-buttons{
        display:flex;
        align-items:center;
        gap:4px;
        flex:1;
        overflow:auto hidden;
        padding:0 6px;
      }
      .task-buttons::-webkit-scrollbar{height:8px;}
      .task-buttons::-webkit-scrollbar-thumb{background:var(--sep);}
      .task-right{ display:flex; align-items:center; gap:8px; }
      .tray{
        height:24px;
        display:flex;
        align-items:center;
        padding:0 8px;
        color:var(--text);
      }
      .clock{min-width:72px; text-align:right; font-variant-numeric:tabular-nums;}

      .start-menu{
        position:absolute;
        left:6px;
        bottom:32px;
        width:260px;
        display:flex;
        padding:0;
        color:var(--menu-text);
      }
      .start-side{
        width:30px;
        background:linear-gradient(var(--title), var(--shadow-dark));
        color:#fff;
        display:flex;
        align-items:flex-end;
        justify-content:center;
        padding:8px 0;
      }
      .start-side span{
        writing-mode:vertical-rl;
        transform:rotate(180deg);
        letter-spacing:1px;
        font-weight:700;
      }
      .start-list{ flex:1; padding:2px; }
      .start-list .menu-item{
        width:100%;
        box-sizing:border-box;
        overflow:hidden;
      }
      .start-list .menu-item > div:last-child{
        flex:1;
        min-width:0;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }
      #startMenu .menu-item img[data-app-id="settings"]{
        width:18px;
        height:18px;
      }
      .menu-item{
        display:flex;
        align-items:center;
        gap:10px;
        padding:6px 8px;
        cursor:pointer;
      }
      .menu-drop .menu-item{
        color:var(--menu-text);
        background:transparent;
      }
      .menu-drop .menu-item:disabled,
      .menu-drop .menu-item.disabled{
        color:var(--muted-text);
        cursor:default;
      }
      .menu-item:hover{
        background:var(--select);
        color:var(--select-text);
      }
      .menu-sep{height:1px; background:var(--sep); margin:2px 0;}
      /* Desktop context menu (Win98 style) */
      .ctx-menu{
  position:absolute;
  min-width:220px;
  padding:2px;
  z-index:9999;
  color:var(--menu-text);
}
.ctx-item{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:6px 8px;
  background:transparent;
  border:0;
  font:inherit;
  color:inherit;
  cursor:pointer;
  text-align:left;
}
.ctx-item:hover,
.ctx-item:focus{
  background:var(--select);
  color:var(--select-text);
  outline:none;
}
.ctx-left{display:flex; align-items:center; gap:10px;}
.ctx-sep{height:1px; background:var(--sep); margin:2px 0;}
.ctx-check{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  opacity:.95;
}
.ctx-shortcut{opacity:.85; font-size:12px;}
.ctx-item:hover .ctx-shortcut,
.ctx-item:focus .ctx-shortcut{opacity:1;}

@media (max-width: 720px){
  .ctx-menu{min-width:200px;}
  .ctx-item{padding:10px 10px;}
}

      .window{ position:absolute; min-width:320px; min-height:220px; }
      .window.anim-open{
        animation:winOpen 160ms ease-out;
        transform-origin:top left;
      }
      .window.anim-close{
        animation:winClose 140ms ease-in forwards;
        transform-origin:top left;
        pointer-events:none;
      }
      .window.anim-minimize{
        animation:winMinimize 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window.anim-restore{
        animation:winRestore 220ms cubic-bezier(.2,.7,.2,1) forwards;
        transform-origin:top left;
      }
      .window .frame{height:100%; display:flex; flex-direction:column;}
      .titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 3px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:var(--titlebar-text);
        cursor:move;
        touch-action:none;
      }
      .title-left{display:flex; align-items:center; gap:6px;}
      .title-left strong{font-weight:700; font-size:12px;}
      .title-controls{display:flex; gap:4px;}
      .wctl{
        width:18px; height:18px;
        display:flex; align-items:center; justify-content:center;
        cursor:pointer;
        font-size:12px;
        line-height:1;
        color:var(--btn-text);
      }
      .titlebar .wctl,
      .modal-titlebar .wctl{
        color:var(--titlebar-text);
      }
      .menubar{
        height:22px;
        display:flex;
        align-items:center;
        gap:14px;
        padding:0 8px;
        background:var(--task);
        border-bottom:1px solid var(--sep);
        user-select:none;
        color:var(--text);
      }
      .menubar span{
        cursor:default;
        padding:0 6px;
      }
      .menubar span.active{
        background:var(--select);
        color:var(--select-text);
      }
      .menu-drop{
        position:absolute;
        min-width:190px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:5;
        color:var(--menu-text);
      }
      .menu-drop.hidden{display:none;}
      .menu-item{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:8px;
        width:100%;
        padding:4px 8px;
        background:transparent;
        border:0;
        text-align:left;
        font:inherit;
        cursor:default;
        position:relative;
      }
      .menu-item:hover,
      .menu-item:focus{
        background:var(--select);
        color:var(--select-text);
        outline:none;
      }
      .menu-left{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .menu-check{
        width:16px;
        display:inline-flex;
        justify-content:center;
      }
      .menu-right{
        min-width:16px;
        text-align:right;
      }
      .menu-sep{
        height:1px;
        background:var(--sep);
        margin:2px 0;
      }
      .menu-item.has-sub:hover > .menu-sub,
      .menu-item.has-sub:focus-within > .menu-sub{
        display:block;
      }
      .menu-sub{
        position:absolute;
        top:-4px;
        left:100%;
        margin-left:2px;
        display:none;
        min-width:180px;
        padding:2px;
        background:var(--menu);
        border:2px solid var(--shadow-dark);
        box-shadow: -2px -2px 0 0 var(--shadow-white) inset, 2px 2px 0 0 var(--shadow-mid) inset;
        z-index:6;
        color:var(--menu-text);
      }
      .content{
        flex:1;
        padding:10px;
        overflow:auto;
        background:var(--content-bg);
        color:var(--content-text);
        user-select:text;
        -webkit-user-select:text;
      }
      .content.trash-empty{
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
      }
      .trash-actions{
        display:flex;
        align-items:center;
        gap:8px;
        padding:2px 8px;
        height:auto;
        background:var(--task);
        border-bottom:1px solid var(--sep);
        flex-wrap:wrap;
      }
      .trash-actions .btn{
        height:20px;
        padding:0 8px;
        white-space:nowrap;
      }
      @media (max-width: 420px){
        .trash-actions .btn{
          height:auto;
          line-height:1.1;
          white-space:normal;
          padding:2px 6px;
          flex:1 1 45%;
          min-width:120px;
        }
      }
      .content h2{margin:0 0 8px 0; font-size:16px;}
      .content p{margin:0 0 10px 0; line-height:1.35;}
      .content .card{ padding:10px; margin:10px 0; }
      .content a{color:var(--link);}
      .statusbar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:0 8px;
        background:var(--task);
        border-top:1px solid var(--sep);
        font-size:12px;
        position:relative;
        color:var(--text);
      }
      .status-center{
        position:absolute;
        left:50%;
        transform:translateX(-50%);
        pointer-events:none;
      }
      #win_games .frame{
        background:
          linear-gradient(90deg, #7a4f26, #5a3518),
          repeating-linear-gradient(90deg, rgba(255,255,255,0.06) 0 2px, rgba(0,0,0,0.08) 2px 4px),
          linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.2));
        border:none;
        box-shadow: 0 10px 24px rgba(0,0,0,0.25);
        position:relative;
      }
      #win_games .frame.bevel{
        border:none;
        box-shadow:none;
      }
      #win_games .frame::before{
        content:"";
        position:absolute;
        inset:2px;
        border-radius:8px;
        box-shadow: inset 0 0 0 2px rgba(255,255,255,0.12), inset 0 0 12px rgba(0,0,0,0.25);
        pointer-events:none;
      }
      #win_games .titlebar{
        background:
          linear-gradient(90deg, #8a5a2d, #6b3f1c),
          repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 2px, rgba(0,0,0,0.08) 2px 4px),
          linear-gradient(180deg, rgba(255,255,255,0.12), rgba(0,0,0,0.25));
        color:#f7efe4;
        text-shadow:0 1px 0 rgba(0,0,0,0.4);
      }
      #win_games .titlebar .wctl{
        background:rgba(0,0,0,0.25);
        border:1px solid rgba(255,255,255,0.18);
        color:#f7efe4;
        box-shadow:none;
      }
      #win_games .menubar{
        background:
          linear-gradient(90deg, #7f4d26, #5a3418),
          repeating-linear-gradient(90deg, rgba(255,255,255,0.06) 0 2px, rgba(0,0,0,0.08) 2px 4px);
        color:#f7efe4;
        border-bottom:1px solid rgba(255,255,255,0.1);
      }
      #win_games .menubar span.active{
        background:rgba(255,255,255,0.15);
        color:#f7efe4;
      }
      #win_games .content{
        background:
          radial-gradient(circle at 20% 20%, rgba(255,255,255,0.08) 0 2px, transparent 2px 6px),
          radial-gradient(circle at 80% 40%, rgba(0,0,0,0.12) 0 2px, transparent 2px 6px),
          radial-gradient(circle at 50% 50%, rgba(0,0,0,0.12), rgba(0,0,0,0.32)),
          repeating-radial-gradient(circle, rgba(255,255,255,0.05) 0 1px, transparent 1px 6px),
          linear-gradient(180deg, #2a7a4b, #1e5d3a);
        border:none;
        border-radius:8px;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
        padding:10px 12px 12px;
      }
      #win_games .statusbar{
        background:
          linear-gradient(90deg, #8a5a2d, #6b3f1c),
          repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 2px, rgba(0,0,0,0.08) 2px 4px);
        color:#f7efe4;
        border-top:1px solid rgba(255,255,255,0.12);
      }
      #win_games .menu-drop{
        background:
          radial-gradient(circle at 20% 20%, rgba(255,255,255,0.08) 0 2px, transparent 2px 6px),
          linear-gradient(180deg, #1f5a3a, #17422b);
        border:2px solid rgba(212,168,92,0.7);
        box-shadow: 0 10px 18px rgba(0,0,0,0.35);
        color:#f7efe4;
      }
      #win_games .menu-item{
        color:#f7efe4;
      }
      #win_games .menu-item:hover,
      #win_games .menu-item:focus{
        background:linear-gradient(180deg, #f3d59b, #c28a3b);
        color:#2b1a0a;
      }
      #win_games .menu-sep{
        background:rgba(255,255,255,0.12);
      }

      .resize{
        position:absolute;
        width:14px; height:14px;
        right:2px; bottom:2px;
        cursor:nwse-resize;
        background:conic-gradient(from 225deg, #0000 0 25%, #666 0 35%, #0000 0 50%, #666 0 60%, #0000 0 75%, #666 0 85%, #0000 0 100%);
        opacity:.55;
        touch-action:none;
      }

      /* Desktop selection box (Win98-like) */
      .rubberband{
        position:absolute;
        pointer-events:none;
        border:1px dotted var(--select-text);
        background:rgba(0,0,128,0.18);
        box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset;
      }

      /* While dragging/resizing/selecting, hard-disable selection everywhere */
      body.dragging, body.dragging *{
        user-select:none !important;
        -webkit-user-select:none !important;
      }

      /* Keep normal selection inside content and inputs */
      .content, .content *{
        user-select:text;
        -webkit-user-select:text;
      }
      input, textarea{
        user-select:text;
        -webkit-user-select:text;
      }
      input[type="text"], select, textarea{
        background:var(--input-bg);
        color:var(--input-text);
        border:1px solid var(--panel-border);
      }

      .hr98{height:1px; background:var(--sep); border-bottom:1px solid var(--sep-light); margin:10px 0;}
      .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
      .list98{padding-left:18px; margin:0;}
      .tag{
        display:inline-block;
        padding:1px 6px;
        border:1px solid var(--panel-border);
        background:var(--panel-bg);
        margin-right:6px;
        font-size:12px;
      }
      .videos-shell{
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .videos-header{
        display:flex;
        flex-wrap:wrap;
        gap:8px 12px;
        align-items:center;
      }
      .videos-header a{
        color:var(--link);
        text-decoration:underline;
      }
      .videos-player{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .videos-player-head{
        display:flex;
        flex-wrap:wrap;
        align-items:center;
        gap:8px 12px;
        justify-content:space-between;
      }
      .videos-player-actions{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
      }
      .videos-embed{
        padding:4px;
      }
      .videos-embed-inner{
        position:relative;
        width:100%;
        padding-top:56.25%;
        background:#000;
      }
      .videos-embed-inner iframe{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        border:0;
      }
      .videos-list{
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(180px, 1fr));
        gap:10px;
      }
      .videos-item{
        display:flex;
        gap:8px;
        align-items:flex-start;
        padding:6px;
        border:1px solid transparent;
        background:var(--content-bg);
        color:var(--content-text);
        text-align:left;
        cursor:default;
      }
      .videos-item.selected{
        border:1px dotted var(--select-text);
        background:var(--selection-bg);
      }
      .videos-thumb{
        width:96px;
        height:54px;
        flex:0 0 auto;
        border:1px solid var(--panel-border);
        background:#000;
        object-fit:cover;
      }
      .videos-meta{
        display:flex;
        flex-direction:column;
        gap:4px;
        min-width:0;
      }
      .videos-title{
        font-weight:700;
        font-size:12px;
        line-height:1.2;
      }
      .videos-sub{
        font-size:11px;
        opacity:.85;
      }
      @media (max-width: 520px){
        .videos-item{
          flex-direction:column;
          align-items:flex-start;
        }
        .videos-thumb{
          width:100%;
          height:auto;
          aspect-ratio:16/9;
        }
      }
      .music-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 120px);
        gap:14px;
        align-items:start;
      }
      .music-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:8px;
        width:120px;
        max-width:120px;
        padding:8px 6px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
        color:var(--content-text);
      }
      .music-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .music-item span{
        text-align:center;
        line-height:1.1;
        max-width:112px;
        word-break:break-word;
      }
      .music-icon{
        width:56px;
        height:56px;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .music-icon img{
        width:48px;
        height:48px;
      }
      .music-small .music-item{padding:6px; gap:6px;}
      .music-small .music-icon{width:40px; height:40px;}
      .music-small .music-icon img{width:32px; height:32px;}
      .music-small .music-label{font-size:12px;}
      .music-hide-icons .music-icon{display:none;}
      .games-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap:14px;
        align-items:start;
        justify-items:center;
        justify-content:center;
      }
      .games-shell{
        display:flex;
        flex-direction:column;
        gap:12px;
        padding:6px;
      }
      .games-skin{
        position:relative;
        padding:0;
        border-radius:12px;
        background:transparent;
        box-shadow:none;
        border:none;
      }
      .games-surface{
        position:relative;
        padding:6px 2px 12px;
        border-radius:10px;
        background:transparent;
        box-shadow:none;
        color:#f4f0e6;
      }
      .games-tabs{
        display:flex;
        gap:8px;
        margin-bottom:12px;
        flex-wrap:wrap;
      }
      .games-tab{
        border:none;
        padding:6px 12px;
        border-radius:999px;
        background:linear-gradient(180deg, #f2d397, #c7903c);
        color:#2d1a09;
        font-weight:600;
        cursor:pointer;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.45), 0 4px 8px rgba(0,0,0,0.2);
      }
      .games-tab.active{
        background:linear-gradient(180deg, #ffe6b5, #cf8f36);
        color:#2b1a0a;
      }
      .games-card{
        background:rgba(0,0,0,0.22);
        border-radius:14px;
        padding:12px 10px;
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.16), 0 6px 12px rgba(0,0,0,0.2);
      }
      .games-card:hover{
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.24), 0 8px 16px rgba(0,0,0,0.2);
      }
      .games-leaderboard{
        display:flex;
        flex-direction:column;
        gap:10px;
        padding:8px;
        border-radius:12px;
        background:rgba(0,0,0,0.25);
        box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
        color:#f4f0e6;
      }
      .games-leaderboard-row{
        display:flex;
        justify-content:space-between;
        gap:10px;
        padding:6px 8px;
        background:rgba(255,255,255,0.06);
        border-radius:8px;
      }
      .games-grid.games-big{
        grid-template-columns: repeat(auto-fill, 140px);
        gap:16px;
      }
      .games-list{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .games-item{
        background:transparent;
        border:1px solid transparent;
        width:140px;
        max-width:140px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:pointer;
      }
      .games-list .games-item{
        width:100%;
        max-width:100%;
        flex-direction:row;
        justify-content:flex-start;
        gap:10px;
      }
      .games-grid.games-big .games-item{
        width:140px;
        max-width:140px;
        gap:8px;
        padding:8px 6px;
      }
      .games-icon{
        width:64px;
        height:64px;
        display:flex;
        align-items:center;
        justify-content:center;
      }
      .games-icon img{
        width:64px;
        height:64px;
        object-fit:contain;
      }
      .games-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .games-item span{
        text-align:center;
        line-height:1.1;
        max-width:120px;
        word-break:break-word;
      }
      .games-skin .games-item{
        color:#f4f0e6;
      }
      .snake-layout{
        display:flex;
        gap:12px;
        flex-wrap:wrap;
        align-items:stretch;
      }
      .snake-topbar{
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
        margin-bottom:10px;
      }
      .snake-topbar-stats{
        display:flex;
        align-items:center;
        gap:10px;
        flex-wrap:wrap;
      }
      .snake-board{
        flex:0 0 auto;
        width:336px;
        height:336px;
        min-width:336px;
        min-height:336px;
        max-width:100%;
        max-height:100%;
        display:flex;
        align-items:center;
        justify-content:center;
        position:relative;
        padding:8px;
        background:var(--panel-in);
        touch-action:none;
        overflow:hidden;
      }
      .snake-board canvas{
        touch-action:none;
        position:absolute;
        left:50%;
        top:50%;
        transform:translate(-50%, -50%);
      }
      .snake-side{
        width:200px;
        min-width:180px;
        display:flex;
        flex-direction:column;
        gap:10px;
      }
      .snake-controls{
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .snake-controls .btn{
        justify-content:center;
      }
      .snake-speed{
        display:flex;
        flex-direction:column;
        gap:4px;
      }
      .snake-speed select{
        height:24px;
      }
      .snake-overlay{
        position:absolute;
        inset:8px;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(233,233,233,0.85);
      }
      body.dark .snake-overlay{
        background:rgba(20,20,20,0.85);
      }
      .snake-overlay-box{
        display:flex;
        flex-direction:column;
        gap:8px;
        padding:10px 12px;
        min-width:160px;
        text-align:center;
      }
      .snake-instructions{
        line-height:1.3;
      }
      .skate-shell{
        display:flex;
        flex-direction:column;
        gap:8px;
        font-family:"Segoe UI", "Helvetica Neue", Arial, sans-serif;
        color:#f5f7fb;
        --skate-bg:#0f141a;
        --skate-panel:#151c24;
        --skate-panel-2:#1b2430;
        --skate-accent:#46c2ff;
        --skate-accent-2:#6effb2;
        --skate-text:#f5f7fb;
        --skate-muted:#a9b6c7;
        --skate-border:#2a3544;
        --skate-shadow:0 12px 28px rgba(0,0,0,0.25);
      }
      .skate-topbar{
        display:flex;
        align-items:center;
        gap:12px;
        justify-content:space-between;
        padding:6px 10px;
        background:linear-gradient(90deg, #101722, #141f2c);
        border:1px solid var(--skate-border);
        border-radius:10px;
      }
      .skate-title{
        margin:0;
        font-size:16px;
        font-weight:700;
        letter-spacing:0.4px;
      }
      .skate-topbar-actions{
        display:flex;
        gap:8px;
      }
      .skate-body{
        display:flex;
        gap:10px;
        flex-wrap:wrap;
        align-items:stretch;
      }
      .skate-screen{
        position:relative;
        flex:1 1 520px;
        min-width:260px;
        padding:6px;
        background:var(--skate-panel);
        border-radius:14px;
        border:1px solid var(--skate-border);
        box-shadow:var(--skate-shadow);
        touch-action:none;
        overflow:hidden;
      }
      .ps1-dock{
        display:none;
        position:absolute;
        left:0;
        right:0;
        bottom:0;
        padding:16px 18px calc(18px + env(safe-area-inset-bottom));
        background:linear-gradient(180deg, #d7d2c8 0%, #bfb8ab 100%);
        border-top:1px solid rgba(0,0,0,0.12);
        box-shadow:0 -8px 24px rgba(0,0,0,0.2);
        z-index:6;
        pointer-events:auto;
        touch-action:none;
      }
      #win_games.mobile-game .ps1-dock{
        display:block;
      }
      .ps1-dock-body{
        position:relative;
        margin:0 auto;
        width:min(92vw, 520px);
        height:190px;
        border-radius:120px 120px 90px 90px;
        background:linear-gradient(180deg, #e8e3d8 0%, #c9c2b4 100%);
        box-shadow:inset 0 6px 12px rgba(255,255,255,0.6), inset 0 -8px 12px rgba(0,0,0,0.18);
        border:1px solid rgba(0,0,0,0.08);
      }
      .ps1-brand{
        position:absolute;
        top:16px;
        left:50%;
        transform:translateX(-50%);
        font-size:14px;
        letter-spacing:2px;
        color:#6a6258;
        font-weight:700;
      }
      .ps1-dpad{
        position:absolute;
        left:28px;
        bottom:22px;
        width:112px;
        height:112px;
        display:flex;
        align-items:center;
        justify-content:center;
        touch-action:none;
      }
      .ps1-dpad-corner{
        position:absolute;
        font-size:14px;
        color:rgba(0,0,0,0.22);
        text-shadow:0 1px 0 rgba(255,255,255,0.2);
        pointer-events:auto;
        user-select:none;
        border:0;
        background:transparent;
        padding:0;
        width:24px;
        height:24px;
        display:flex;
        align-items:center;
        justify-content:center;
        touch-action:none;
        -webkit-tap-highlight-color:transparent;
      }
      .ps1-dpad-corner.ne{ top:14px; right:14px; }
      .ps1-dpad-corner.se{ bottom:14px; right:14px; }
      .ps1-dpad-corner.sw{ bottom:14px; left:14px; }
      .ps1-dpad-corner.nw{ top:14px; left:14px; }
      .ps1-dpad-btn{
        position:absolute;
        width:34px;
        height:34px;
        border-radius:8px;
        border:2px solid rgba(0,0,0,0.2);
        background:linear-gradient(180deg, #dfd8cb 0%, #bdb4a6 100%);
        color:#4b4339;
        font-size:16px;
        font-weight:700;
        display:flex;
        align-items:center;
        justify-content:center;
        box-shadow:inset 0 2px 6px rgba(255,255,255,0.4);
        touch-action:none;
      }
      .ps1-dpad-btn.up{ top:0; }
      .ps1-dpad-btn.down{ bottom:0; }
      .ps1-dpad-btn.left{ left:0; }
      .ps1-dpad-btn.right{ right:0; }
      .ps1-stick{
        position:absolute;
        left:26px;
        bottom:20px;
        width:110px;
        height:110px;
        border-radius:50%;
        background:radial-gradient(circle at 30% 30%, #d0c8ba, #9a9185);
        border:2px solid rgba(0,0,0,0.15);
        box-shadow:inset 0 6px 8px rgba(255,255,255,0.35);
        touch-action:none;
      }
      .ps1-stick-knob{
        position:absolute;
        left:50%;
        top:50%;
        width:52px;
        height:52px;
        border-radius:50%;
        background:radial-gradient(circle at 30% 30%, #bab1a3, #7d7367);
        border:2px solid rgba(0,0,0,0.2);
        transform:translate(-50%, -50%);
      }
      .ps1-face{
        position:absolute;
        right:26px;
        bottom:18px;
        width:150px;
        height:150px;
      }
      .ps1-face-btn{
        position:absolute;
        width:54px;
        height:54px;
        border-radius:50%;
        border:2px solid rgba(0,0,0,0.2);
        background:rgba(245,245,245,0.85);
        font-size:22px;
        font-weight:700;
        display:flex;
        align-items:center;
        justify-content:center;
        box-shadow:0 6px 12px rgba(0,0,0,0.2);
        touch-action:none;
      }
      .ps1-face-btn.triangle{ color:#2bb14f; left:48px; top:0; }
      .ps1-face-btn.circle{ color:#d63b5a; right:0; top:48px; }
      .ps1-face-btn.cross{ color:#2b78ff; left:48px; bottom:0; }
      .ps1-face-btn.square{ color:#7c49d1; left:0; top:48px; }
      .ps1-center{
        position:absolute;
        inset:0;
        pointer-events:none;
      }
      .ps1-analog{
        position:absolute;
        left:50%;
        bottom:22px;
        transform:translateX(-50%);
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:4px;
      }
      .ps1-analog-btn{
        min-width:72px;
        height:28px;
        border-radius:999px;
        border:1px solid rgba(0,0,0,0.25);
        background:linear-gradient(180deg, #f2ede4 0%, #cfc7b9 100%);
        font-size:11px;
        letter-spacing:1px;
        color:#6a6258;
        text-transform:uppercase;
        box-shadow:inset 0 3px 6px rgba(255,255,255,0.6);
        touch-action:none;
      }
      .ps1-analog-led-rect{
        width:18px;
        height:6px;
        border-radius:3px;
        background:#7a1b1b;
        box-shadow:0 0 8px rgba(255,50,50,0.6);
        opacity:0;
      }
      .ps1-dock[data-mode="analog"] .ps1-analog-led-rect{
        opacity:1;
      }
      .ps1-dock[data-mode="analog"] .ps1-dpad{
        display:none;
      }
      .ps1-dock[data-mode="dpad"] .ps1-stick{
        display:none;
      }
      .ps1-center-btn{
        min-width:64px;
        height:28px;
        border-radius:999px;
        border:1px solid rgba(0,0,0,0.2);
        background:linear-gradient(180deg, #f2ede4 0%, #cfc7b9 100%);
        font-size:11px;
        letter-spacing:1px;
        color:#6a6258;
        text-transform:uppercase;
        box-shadow:inset 0 3px 6px rgba(255,255,255,0.6);
        touch-action:none;
        pointer-events:auto;
      }
      .ps1-center-btn.select{
        position:absolute;
        left:2px;
        top:2px;
      }
      .ps1-center-btn.start{
        position:absolute;
        right:2px;
        top:2px;
      }
      .skate-canvas-wrap{
        display:flex;
        align-items:center;
        justify-content:center;
        width:100%;
        height:100%;
        min-height:360px;
        position:relative;
        overflow:hidden;
      }
      #skateCanvas{
        display:block;
        width:640px;
        height:360px;
        background:#0f141a;
        border-radius:12px;
        border:1px solid #1f2a36;
        touch-action:none;
        position:absolute;
        left:50%;
        top:50%;
        transform:translate(-50%, -50%);
      }
      #win_games.mobile-game .content{
        padding:0;
        height:100%;
        overflow:hidden;
        flex:1 1 auto;
        min-height:0;
        display:flex;
        flex-direction:column;
        padding-bottom:260px;
        position:relative;
      }
      #win_games.mobile-game{
        position:fixed;
        inset:0;
        width:100dvw;
        height:100dvh;
        min-height:100svh;
      }
      #win_games.mobile-game .frame{
        height:100%;
        display:flex;
        flex-direction:column;
      }
      #win_games.mobile-game .skate-shell{
        height:100%;
      }
      #win_games.mobile-game .skate-menu{
        max-height:calc(100dvh - 300px);
        overflow:auto;
      }
      #win_games.mobile-game .skate-menu-panels{
        max-height:calc(100dvh - 340px);
        overflow:auto;
      }
      #win_games.mobile-game .skate-panel{
        padding-bottom:16px;
      }
      #win_games.mobile-game .skate-body{
        flex-direction:column;
        flex:1;
      }
      #win_games.mobile-game .skate-screen{
        flex:1;
        padding:4px;
        height:100%;
        max-height:35vh;
        align-self:center;
        aspect-ratio:16/9;
      }
      #win_games.mobile-game .skate-canvas-wrap{
        min-height:auto;
        min-height:0;
      }
      #win_games.mobile-game #skateCanvas{
        width:100%;
        height:100%;
      }
      #win_games.mobile-game .skate-controls{
        display:none;
      }
      #win_games.mobile-game .snake-layout{
        flex-direction:column;
        align-items:stretch;
        height:100%;
      }
      #win_games.mobile-game .snake-side{
        width:100%;
        min-width:0;
        flex-direction:row;
        flex-wrap:wrap;
        gap:8px;
        justify-content:center;
        padding:6px 8px;
      }
      #win_games.mobile-game .snake-controls{
        display:none;
      }
      #win_games.mobile-game .snake-topbar{
        margin-bottom:6px;
      }
      #win_games.mobile-game .snake-topbar-stats{
        width:100%;
        justify-content:flex-start;
      }
      #win_games.mobile-game .snake-speed{
        margin-left:auto;
      }
      #win_games .snake-controls .btn,
      #win_games .snake-topbar .btn{
        background:linear-gradient(180deg, #8b6337 0%, #6f4b27 100%);
        color:#f4f0e6;
        border:1px solid rgba(0,0,0,0.35);
        box-shadow:inset 0 1px 0 rgba(255,255,255,0.2);
      }
      #win_games .snake-board,
      #win_games .snake-board.bevel-in{
        border:2px solid rgba(74,48,20,0.6);
        background:linear-gradient(180deg, #8f6433 0%, #6e4a25 100%);
        box-shadow:inset 0 2px 6px rgba(0,0,0,0.2);
      }
      #win_games.mobile-game .snake-board{
        width:min(84vw, 300px);
        height:auto;
        min-width:0;
        min-height:0;
        padding:6px;
        flex:0 0 auto;
        max-height:min(34vh, 300px);
        align-self:center;
        aspect-ratio:1/1;
      }
      #win_games.mobile-game .snake-board canvas{
        width:100%;
        height:100%;
      }
      .skate-hud{
        position:absolute;
        left:12px;
        top:12px;
        display:flex;
        gap:10px;
        flex-wrap:wrap;
        padding:6px 8px;
        background:rgba(12,16,22,0.78);
        border:1px solid rgba(70,194,255,0.25);
        border-radius:10px;
        font-size:12px;
        color:var(--skate-text);
        max-width:90%;
      }
      .skate-combo-list{
        display:flex;
        gap:6px;
        flex-wrap:wrap;
      }
      .skate-combo-item{
        padding:2px 6px;
        border-radius:999px;
        background:rgba(70,194,255,0.16);
        border:1px solid rgba(70,194,255,0.4);
      }
      .skate-combo-meter{
        width:90px;
        height:6px;
        border-radius:999px;
        background:rgba(255,255,255,0.1);
        overflow:hidden;
        border:1px solid rgba(255,255,255,0.12);
      }
      .skate-combo-meter span{
        display:block;
        height:100%;
        width:100%;
        background:linear-gradient(90deg, #46c2ff, #6effb2);
        transition:width 0.1s linear;
      }
      .skate-balance{
        position:absolute;
        right:12px;
        top:12px;
        padding:6px 8px;
        background:rgba(12,16,22,0.78);
        border:1px solid rgba(110,255,178,0.35);
        border-radius:10px;
        font-size:12px;
        display:flex;
        flex-direction:column;
        gap:4px;
        min-width:90px;
      }
      .skate-balance-bar{
        height:6px;
        background:#0e131a;
        border:1px solid rgba(110,255,178,0.35);
        position:relative;
        border-radius:999px;
      }
      .skate-balance-indicator{
        position:absolute;
        top:-2px;
        width:4px;
        height:10px;
        background:var(--skate-accent-2);
        border-radius:999px;
      }
      .skate-overlay{
        position:absolute;
        inset:6px;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(7,10,14,0.82);
        backdrop-filter:blur(8px);
      }
      .skate-menu{
        display:flex;
        flex-direction:column;
        gap:12px;
        width:min(860px, 96%);
        padding:18px;
        background:var(--skate-panel);
        border:1px solid var(--skate-border);
        border-radius:16px;
        box-shadow:var(--skate-shadow);
      }
      .skate-menu-header{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
      }
      .skate-menu-title{
        font-size:20px;
        font-weight:700;
        letter-spacing:0.4px;
      }
      .skate-menu-actions{
        display:flex;
        gap:8px;
      }
      .skate-tabs{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
      }
      .skate-tab{
        padding:8px 12px;
        border-radius:999px;
        border:1px solid transparent;
        background:var(--skate-panel-2);
        color:var(--skate-text);
        cursor:pointer;
        transition:all 0.2s ease;
      }
      .skate-tab.active{
        border-color:rgba(70,194,255,0.6);
        background:rgba(70,194,255,0.2);
        color:#eaf7ff;
      }
      .skate-menu-panels{
        flex:1;
      }
      .skate-panel{
        display:none;
        min-height:220px;
        opacity:0;
        transform:translateY(8px);
        transition:opacity 0.25s ease, transform 0.25s ease;
      }
      .skate-panel.active{
        display:block;
        opacity:1;
        transform:translateY(0);
      }
      .skate-panel-title{
        font-weight:700;
        margin-bottom:8px;
      }
      .skate-panel-text{
        margin:0 0 12px 0;
        line-height:1.4;
        color:var(--skate-muted);
      }
      .skate-panel-actions{
        display:flex;
        gap:10px;
        flex-wrap:wrap;
        margin-top:12px;
      }
      .skate-shop-grid{
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(140px, 1fr));
        gap:8px;
      }
      .skate-shop-header{
        display:flex;
        justify-content:space-between;
        align-items:center;
        gap:10px;
        margin-bottom:8px;
      }
      .skate-shop-tabs{
        margin-bottom:10px;
      }
      .skate-shop-layout{
        display:flex;
        gap:10px;
        flex-wrap:wrap;
      }
      .skate-shop-shelves{
        flex:2 1 240px;
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(150px, 1fr));
        gap:8px;
      }
      .skate-shop-preview{
        flex:1 1 160px;
        min-width:160px;
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .skate-bliss-letter{
        padding:2px 6px;
        border-radius:8px;
        border:1px solid rgba(255,255,255,0.2);
        color:var(--skate-muted);
      }
      .skate-bliss-letter.active{
        background:var(--skate-accent-2);
        color:#0d1511;
        border-color:transparent;
      }
      .skate-preview-stage{
        position:relative;
        height:180px;
        background:linear-gradient(180deg, #141b24 0%, #10151d 100%);
        border:1px solid var(--skate-border);
        border-radius:14px;
        display:flex;
        align-items:flex-end;
        justify-content:center;
        padding-bottom:12px;
      }
      .skate-preview-stage img{
        position:absolute;
        image-rendering:pixelated;
      }
      .skate-shop-item{
        padding:8px;
        border:1px solid var(--skate-border);
        background:var(--skate-panel-2);
        border-radius:12px;
        display:flex;
        flex-direction:column;
        gap:6px;
        min-height:70px;
        transition:transform 0.2s ease, border-color 0.2s ease;
      }
      .skate-shop-item button{
        align-self:flex-start;
      }
      .skate-shop-item.active{
        border:1px solid rgba(70,194,255,0.6);
        background:rgba(70,194,255,0.16);
        transform:translateY(-2px);
      }
      .skate-shop-item.preview{
        border-color:rgba(255,209,102,0.7);
        box-shadow:0 0 0 1px rgba(255,209,102,0.25);
      }
      .skate-preview-status{
        color:var(--skate-muted);
      }
      .skate-shop-item.flash{
        animation:skateFlash 0.6s ease;
      }
      .skate-shop-item.locked{
        border-color:rgba(255,120,120,0.6);
        animation:skateShake 0.3s ease;
      }
      @keyframes skateShake{
        0%{ transform:translateX(0); }
        25%{ transform:translateX(-4px); }
        50%{ transform:translateX(4px); }
        75%{ transform:translateX(-2px); }
        100%{ transform:translateX(0); }
      }
      @keyframes skateFlash{
        0%{ box-shadow:0 0 0 rgba(70,194,255,0.0); }
        30%{ box-shadow:0 0 18px rgba(70,194,255,0.45); }
        100%{ box-shadow:0 0 0 rgba(70,194,255,0.0); }
      }
      .skate-controls{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
        justify-content:center;
      }
      .skate-btn{
        appearance:none;
        border:none;
        border-radius:999px;
        padding:8px 14px;
        background:linear-gradient(180deg, #1b2a3a 0%, #111823 100%);
        color:var(--skate-text);
        cursor:pointer;
        font-weight:600;
        letter-spacing:0.2px;
        transition:transform 0.15s ease, box-shadow 0.2s ease, background 0.2s ease;
      }
      .skate-btn:hover{
        transform:translateY(-1px);
        box-shadow:0 8px 16px rgba(0,0,0,0.2);
      }
      .skate-btn.primary{
        background:linear-gradient(180deg, #42b3ff 0%, #1a6db6 100%);
      }
      .skate-btn.ghost{
        background:transparent;
        border:1px solid rgba(255,255,255,0.2);
      }
      .skate-btn.subtle{
        background:rgba(255,255,255,0.08);
      }
      .skate-select{
        width:100%;
        margin-top:4px;
        padding:6px 8px;
        border-radius:10px;
        border:1px solid var(--skate-border);
        background:var(--skate-panel);
        color:var(--skate-text);
      }
      .skate-control{
        min-width:90px;
        justify-content:center;
      }
      .skate-control[disabled]{
        opacity:0.6;
        filter:grayscale(0.2);
        cursor:default;
      }
      .skate-over-box{
        display:flex;
        flex-direction:column;
        gap:8px;
        min-width:200px;
        align-items:center;
        text-align:center;
        padding:10px 12px;
        background:var(--skate-panel);
        border:1px solid var(--skate-border);
        border-radius:14px;
      }
      #win_games .skate-over-box,
      #win_games .snake-overlay-box{
        background:rgba(12,32,18,0.92);
        border:1px solid rgba(199,144,60,0.9);
        box-shadow:0 12px 24px rgba(0,0,0,0.35), inset 0 0 0 1px rgba(255,255,255,0.08);
        color:#f4f0e6;
      }
      #win_games .snake-overlay-box .btn{
        background:linear-gradient(180deg, #8b6337 0%, #6f4b27 100%);
        color:#f4f0e6;
        border:1px solid rgba(0,0,0,0.35);
        box-shadow:inset 0 1px 0 rgba(255,255,255,0.2);
      }
      @media (max-width: 520px){
        .music-grid{
          grid-template-columns:1fr;
        }
        .music-item{
          width:100%;
          max-width:100%;
          flex-direction:row;
          justify-content:flex-start;
        }
        .music-item span{
          max-width:none;
          text-align:left;
        }
        .games-grid{
          grid-template-columns:repeat(2, minmax(0, 1fr));
        }
        .games-item{
          width:100%;
          max-width:100%;
        }
        .snake-side{
          width:100%;
          min-width:0;
        }
        .snake-board{
          width:336px;
          height:336px;
          min-width:336px;
          min-height:336px;
          margin:0 auto;
        }
        .skate-menu{
          flex-direction:column;
        }
        .skate-canvas-wrap{
          min-height:260px;
        }
        .skate-hud{
          position:static;
          margin:6px 0 0;
        }
        .skate-balance{
          position:static;
          margin:6px 0 0;
          width:100%;
        }
      }
      .settings-shell{
        display:flex;
        flex-direction:column;
        gap:0;
      }
      .settings-tabs{
        display:flex;
        gap:4px;
        padding:4px 6px 0;
        overflow-x:auto;
        -webkit-overflow-scrolling:touch;
      }
      .settings-tab{
        padding:4px 10px;
        background:var(--task);
        border:1px solid var(--panel-border);
        border-bottom:none;
        cursor:pointer;
        white-space:nowrap;
        color:var(--btn-text);
      }
      .settings-tab[aria-selected="true"]{
        background:var(--panel-bg);
        position:relative;
        top:1px;
        z-index:1;
        color:var(--content-text);
      }
      .settings-panels{
        padding:0 6px 6px;
      }
      .settings-panel{
        display:none;
        padding:12px;
        background:var(--panel-bg);
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        min-height:200px;
      }
      .settings-panel.active{display:block;}
      .settings-general{
        display:flex;
        gap:14px;
        flex-wrap:wrap;
        align-items:flex-start;
      }
      .settings-panel-header{
        display:flex;
        align-items:center;
        gap:10px;
        margin-bottom:10px;
      }
      .titlebar-swatch{
        width:16px;
        height:16px;
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        flex-shrink:0;
      }
      .settings-panel-icon{
        width:48px;
        height:48px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:1px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        background:var(--panel-bg);
        flex-shrink:0;
      }
      .settings-panel-icon img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .theme-grid{
        display:grid;
        grid-template-columns:repeat(auto-fill, minmax(140px, 1fr));
        gap:10px;
        margin-top:8px;
      }
      .theme-thumb{
        display:flex;
        flex-direction:column;
        gap:6px;
        padding:6px;
        text-align:left;
        background:var(--content-bg);
        color:var(--content-text);
        border:1px solid var(--panel-border);
        cursor:pointer;
      }
      .theme-thumb .theme-preview{
        height:60px;
        border:1px solid var(--panel-border);
        display:flex;
        flex-direction:column;
        background:var(--panel-bg);
      }
      .theme-preview-bar{
        height:14px;
      }
      .theme-preview-body{
        flex:1;
        background:var(--content-bg);
      }
      .theme-thumb.selected{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .theme-thumb.disabled{
        opacity:0.6;
        cursor:default;
      }
      .theme-preview-default .theme-preview-bar{
        background:linear-gradient(90deg, #000080, #1084d0);
      }
      .theme-preview-totvers .theme-preview-bar{
        background:linear-gradient(90deg, #f6a6cf, #e46aa9);
      }
      .theme-preview-matrix .theme-preview-bar{
        background:linear-gradient(90deg, #1b4a2a, #0e2e1a);
      }
      .theme-preview-xp98 .theme-preview-bar{
        background:linear-gradient(90deg, #0a2e8f, #4f86d8);
      }
      .theme-preview-blank .theme-preview-bar{
        background:transparent;
        border-bottom:1px solid var(--panel-border);
      }
      .theme-preview-custom .theme-preview-bar{
        background:linear-gradient(90deg, #666, #999);
      }
      .settings-logo{
        width:96px;
        height:72px;
        display:flex;
        align-items:center;
        justify-content:center;
        border:2px solid var(--panel-border);
        box-shadow:inset 1px 1px var(--shadow-white), inset -1px -1px var(--shadow-dark);
        background:var(--panel-bg);
      }
      .settings-logo img{
        width:48px;
        height:48px;
        object-fit:contain;
        display:block;
      }
      .settings-summary{
        display:flex;
        flex-direction:column;
        gap:6px;
      }
      .settings-block{
        margin-top:8px;
        padding-top:8px;
        border-top:1px solid var(--sep);
      }
      .settings-actions{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
      }
      @media (max-width: 520px){
        .settings-general{flex-direction:column;}
        .settings-logo{width:100%; height:72px;}
        .settings-panel-header{align-items:flex-start;}
      }
      .clothes-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
        gap:12px;
        align-items:start;
      }
      .clothes-item{
        display:flex;
        align-items:center;
        justify-content:center;
        padding:6px;
        border:1px solid transparent;
        background:transparent;
      }
      .clothes-item:focus,
      .clothes-item:focus-visible{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .clothes-thumb{
        width:100%;
        height:auto;
        aspect-ratio:1/1;
        object-fit:cover;
        border:1px solid var(--panel-border);
        background:var(--panel-in);
        display:block;
      }
      .clothes-status{
        margin-top:10px;
      }
      @media (max-width: 520px){
        .clothes-grid{
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .poetry-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        justify-items:start;
      }
      .poetry-item{
        background:transparent;
        border:1px solid transparent;
        width:92px;
        max-width:92px;
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        padding:6px 4px;
        cursor:default;
      }
      .poetry-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .poetry-item span{
        text-align:center;
        line-height:1.1;
        max-width:110px;
        word-break:break-word;
      }
      .poem-body{
        white-space:pre-line;
        line-height:1.4;
      }
      .trash-grid{
        display:grid;
        grid-template-columns: repeat(auto-fill, 92px);
        gap:12px;
        align-items:start;
      }
      .trash-item{
        display:flex;
        flex-direction:column;
        align-items:center;
        gap:6px;
        width:92px;
        max-width:92px;
        padding:6px 4px;
        border:1px solid transparent;
        background:transparent;
        appearance:none;
        cursor:default;
      }
      .trash-item.selected{
        border:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      .trash-item span{
        text-align:center;
        line-height:1.1;
        max-width:86px;
        word-break:break-word;
      }
      .trash-empty-msg{
        font-weight:700;
      }
      .mp-compact .content{padding:6px;}
      .mp-compact .card{padding:6px;}
      .mp-hide-list #mpList,
      .mp-hide-list #mpMsg{display:none;}
      .mp-item.selected{
        outline:1px dotted var(--selection-border);
        background:var(--selection-bg);
      }
      #win_mediaplayer .content{
        background:var(--task);
        padding:8px;
        display:flex;
        justify-content:center;
        align-items:flex-start;
      }
      .mp-mini{
        width:min(360px, 100%);
        padding:8px;
        display:flex;
        flex-direction:column;
        gap:8px;
      }
      .mp-now{
        display:flex;
        align-items:baseline;
        gap:6px;
      }
      .mp-title{
        font-weight:700;
        min-width:0;
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }
      .mp-controls{
        display:flex;
        flex-wrap:wrap;
        gap:6px;
        justify-content:center;
      }
      .mp-controls .btn{
        height:24px;
        padding:0 8px;
      }
      .mp-seek-row{
        display:flex;
        align-items:center;
        gap:8px;
      }
      .mp-seek{
        flex:1;
        min-width:140px;
      }
      .mp-time{
        font-variant-numeric:tabular-nums;
        white-space:nowrap;
      }
      .mp-bottom{
        display:flex;
        align-items:center;
        gap:8px;
        flex-wrap:wrap;
        justify-content:space-between;
      }
      .mp-actions{
        display:flex;
        gap:6px;
        flex-wrap:wrap;
      }
      .mp-actions .btn{
        height:22px;
        padding:0 8px;
      }
      .mp-vol{
        display:flex;
        align-items:center;
        gap:6px;
      }
      .mp-status{
        min-height:14px;
      }
      .mp-drop{
        border:1px dotted var(--selection-border);
        background:var(--panel-bg);
        text-align:center;
        padding:6px;
      }
      .mp-drop.active{
        background:var(--selection-bg);
      }
      .diev-small .content{font-size:12px;}
      .diev-large .content{font-size:15px;}
      .diev-contrast .content{
        background:#000;
        color:#fff;
      }
      .diev-contrast .content a{color:#9ad0ff;}
      .art-zoom-50 .content{font-size:12px;}
      .art-zoom-100 .content{font-size:13px;}
      .art-zoom-200 .content{font-size:16px;}
      body.scanlines::before{
        content:"";
        position:fixed;
        inset:0;
        background:repeating-linear-gradient(
          0deg,
          rgba(0,0,0,0.15) 0,
          rgba(0,0,0,0.15) 1px,
          rgba(255,255,255,0) 2px,
          rgba(255,255,255,0) 3px
        );
        pointer-events:none;
        z-index:9999;
      }
      .modal{
        position:fixed;
        inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:rgba(0,0,0,0.25);
        z-index:9998;
        padding:12px;
        box-sizing:border-box;
        overflow:auto;
      }
      .modal.hidden{display:none;}
      .modal-box{
        min-width:280px;
        max-width:520px;
        width:100%;
        max-height:calc(100% - 12px);
        display:flex;
        flex-direction:column;
      }
      .modal-titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 4px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:var(--titlebar-text);
      }
      .modal-body{
        padding:10px;
        background:var(--content-bg);
        color:var(--content-text);
        overflow:auto;
        max-height:calc(100% - 72px);
      }
      .modal-body input,
      .modal-body select{
        max-width:100%;
        box-sizing:border-box;
      }
      .modal-actions{
        display:flex;
        justify-content:flex-end;
        gap:8px;
        padding:10px;
        background:var(--task);
        border-top:1px solid var(--sep);
      }
      @keyframes winOpen{
        from{opacity:0; transform:scale(0.98);}
        to{opacity:1; transform:scale(1);}
      }
      @keyframes winClose{
        from{opacity:1; transform:scale(1);}
        to{opacity:0; transform:scale(0.96);}
      }
      @keyframes winMinimize{
        0%{opacity:1; transform:translate(0,0) scale(1);}
        100%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
      }
      @keyframes winRestore{
        0%{opacity:0.1; transform:translate(var(--min-x, 0px), var(--min-y, 0px)) scale(0.2, 0.15);}
        100%{opacity:1; transform:translate(0,0) scale(1);}
      }

      @media (max-width: 720px){
        .icons{grid-template-rows: repeat(5, 88px);}
        .window{min-width:280px;}
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="login">
        <div class="login-panel bevel">
          <div class="login-title">
            <div class="login-left">
              <img class="logo pixel" src="./assets/icons/bliss.png" width="34" height="34" alt="" style="display:block;" />
              <div>
                <h1>BLISS 98</h1>
                <p class="login-sub" data-i18n="login.sub">Enter your name to login</p>
              </div>
            </div>
            <button id="langBtn" class="btn bevel lang-btn" type="button" aria-label="Language" data-i18n-aria="aria.language">
              EN
            </button>
          </div>

          <div class="bevel-in" style="padding:12px;">
            <div class="field-row">
              <label for="username" data-i18n="login.labelName">Name:</label>
              <input id="username" class="bevel-in" type="text" autocomplete="name" placeholder="Enter your name" data-i18n-placeholder="login.placeholder" />
            </div>

            <div class="login-footer">
              <div class="tiny" data-i18n="login.hint">Hint: Ignorance is BLISS</div>
              <div style="display:flex; gap:6px;">
                <button id="clearProfile" class="btn bevel" type="button" data-i18n="login.clear">Clear</button>
                <button id="enter" class="btn bevel" type="button"><strong data-i18n="login.enter">Enter</strong></button>
              </div>
            </div>
          </div>

          <div class="tiny" style="margin-top:10px; opacity:.9;">
            <span data-i18n="login.copyright"> BLISS / DIEV  Bliss 98 OS</span>
          </div>
        </div>
      </div>

      <div id="desktop" class="hidden">
        <div class="desktop-area" id="desktopArea">
          <div class="icons" id="iconGrid"></div>
          <div class="drag-layer" id="dragLayer"></div>
          <div id="windows"></div>
          <div id="rubberband" class="rubberband hidden"></div>
        </div>

        <div class="taskbar bevel" id="taskbar">
          <div class="task-left">
            <div id="startBtn" class="btn bevel" title="Menu" data-i18n-title="start.menu">
              <img class="pixel" src="./assets/icons/bliss.png" width="16" height="16" alt="" style="display:block;" />
              <strong>Bliss</strong>
            </div>
          </div>

          <div class="task-buttons" id="taskButtons"></div>

          <div class="task-right">
            <div class="tray bevel">
              <span id="who" style="margin-right:10px;"></span>
              <span class="clock" id="clock"></span>
            </div>
          </div>
        </div>

        <div id="startMenu" class="start-menu bevel hidden" role="menu" aria-label="Menu Bliss" data-i18n-aria="aria.startMenu">
          <div class="start-side"><span>BLISS 98</span></div>
          <div class="start-list" id="startList"></div>
        </div>

        <!-- Desktop context menu -->
        <div id="ctxMenu" class="ctx-menu bevel hidden" role="menu" aria-label="Context menu" data-i18n-aria="aria.contextMenu">
          <!-- items injected by JS -->
        </div>

        <div id="modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
          <div class="modal-box bevel">
            <div class="modal-titlebar">
              <div class="title-left">
                <strong id="modalTitle"></strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" id="modalClose" aria-label="Close" data-i18n-aria="aria.close"></div>
              </div>
            </div>
            <div class="modal-body" id="modalBody"></div>
            <div class="modal-actions" id="modalActions"></div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      const state = {
        user: null,
        windows: new Map(),
        zTop: 10,
        activeWindowId: null,
        selectedIconId: null,
        lang: 'en',
        wallpaper: 'classic',
        animations: true,
        music: {
          selected: new Set(),
          tileSize: 'large',
          openNewTab: true,
          showIcons: true,
        },
        mediaplayer: {
          selected: new Set(),
          shuffle: false,
          repeat: 'off',
          showPlaylist: true,
          compact: false,
          needsReimport: false,
        },
        diev: {
          textSize: 'normal',
          highContrast: false,
        },
        videos: {
          openNewTab: true,
          thumbSize: 'large',
          items: [],
          selectedId: null,
        },
        art: {
          zoom: 100,
        },
        settings: {
          scanlines: false,
          tab: 'general',
          darkMode: false,
          retroGlow: false,
        },
        theme: {
          preset: 'default',
          titlebar: 'defaultBlue',
          palette: 'default',
        },
        games: {
          view: 'list',
          selectedId: null,
          layout: 'grid',
          bigIcons: false,
        },
        folders: {
          games: [],
        },
        snake: {
          speed: 'normal',
          highScore: 0,
        },
        dopeSkate: {
          highScore: 0,
          preview: {
            active: false,
            loadout: {},
            selectedCategory: null,
            selectedItemId: null,
          },
        },
        trash: new Set(),
        iconLabels: {},
        trashSelection: new Set(),
        poetry: {
          view: 'list',
          selectedId: null,
          currentId: null,
          readLang: 'en',
        },
        menuOpen: null,
        gridSnap: true,
        autoPlayTimer: null,
        didAutoPlayThisSession: false,
      };

      const ICON_POS_KEY = 'bliss98_icon_positions';
      const ICON_SIZE = { w: 92, h: 88 };
      const ICON_GAP = { x: 12, y: 8 };
      const WALLPAPER_KEY = 'bliss98_wallpaper';
      const ANIMATIONS_KEY = 'bliss98_animations';
      const SCANLINES_KEY = 'bliss98_scanlines';
      const DARKMODE_KEY = 'bliss98_darkmode';
      const TRASH_KEY = 'bliss98_trash';
      const ICON_LABELS_KEY = 'bliss98_icon_labels';
      const CLOTHES_CACHE_KEY = 'bliss98_clothes_cache';
      const CLOTHES_CACHE_TTL = 1000 * 60 * 60 * 3;
      const SNAKE_HIGH_KEY = 'bliss98_snake_highscore';
      const DOPE_SKATE_HIGH_KEY = 'bliss98_dope_skate_highscore';
      const TITLEBAR_KEY = 'bliss98_titlebar_theme';
      const THEME_PRESET_KEY = 'bliss98_theme_preset';
      const THEME_CUSTOM_KEY = 'bliss98_theme_custom';
      const FOLDER_KEY = 'bliss98_folders';
      const GAMES_VIEW_KEY = 'bliss98_games_view';
      const GAMES_BIG_KEY = 'bliss98_games_big';
const RETRO_KEY = 'bliss98_retro_glow';
const YOUTUBE_KEY = 'bliss98_youtube_api_key';
const MOBILE_CONTROLS_KEY = 'bliss98_mobile_controls_mode';
      function loadMobileControlsMode(){
        try{
          const raw = localStorage.getItem(MOBILE_CONTROLS_KEY);
          return (raw === 'analog' || raw === 'dpad') ? raw : 'dpad';
        } catch {
          return 'dpad';
        }
      }

      function saveMobileControlsMode(mode){
        try{ localStorage.setItem(MOBILE_CONTROLS_KEY, mode); } catch {}
      }

      state.mobileControlsMode = loadMobileControlsMode();

      const SFX = {
        boot: {
          src: './assets/audio/boot.mp3',
          audio: null,
          played: false,
          pending: false,
          unlockArmed: false,
          playing: false,
        },
        logoff: {
          src: './assets/audio/logoff.mp3',
          audio: null,
          playing: false,
        }
      };
      const WALLPAPERS = [
        {
          id: 'classic',
          labelKey: 'wallpaper.classic',
          background: '#008080',
          size: 'auto',
          repeat: 'repeat'
        },
        {
          id: 'bliss',
          labelKey: 'wallpaper.bliss',
          background: 'radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'clouds',
          labelKey: 'wallpaper.clouds',
          background: 'linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%)',
          size: 'cover',
          repeat: 'no-repeat'
        },
        {
          id: 'diev',
          labelKey: 'wallpaper.diev',
          background: 'repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 24px), linear-gradient(135deg, #0a2333, #114b6a)',
          size: 'auto',
          repeat: 'repeat'
        },
        {
          id: 'tot',
          labelKey: 'wallpaper.tot',
          background: 'radial-gradient(circle at 20% 20%, #ffd1e6 0%, #ff9fcb 45%, #ff7fb7 100%), repeating-radial-gradient(circle, rgba(255,255,255,0.35) 0 1px, transparent 1px 10px)',
          size: 'cover',
          repeat: 'repeat'
        },
        {
          id: 'matrix',
          labelKey: 'wallpaper.matrix',
          className: 'wallpaper-matrix'
        },
        {
          id: 'xp98bliss',
          labelKey: 'wallpaper.xp98bliss',
          background: 'url("./assets/wallpapers/bliss98.png")',
          size: 'cover',
          repeat: 'no-repeat',
          position: 'center'
        },
      ];

      const TITLEBAR_THEMES = {
        defaultBlue: { bar1:'#000080', bar2:'#1084d0', text:'#ffffff' },
        pinkLight: { bar1:'#f6a6cf', bar2:'#e46aa9', text:'#1a1a1a' },
        purpleDark: { bar1:'#3a1c5a', bar2:'#1b0f30', text:'#f1f1f1' },
        offWhite: { bar1:'#e6e6e6', bar2:'#cfcfcf', text:'#1a1a1a' },
        greenDark: { bar1:'#1b4a2a', bar2:'#0e2e1a', text:'#f1f1f1' },
        redDark: { bar1:'#5a1a1a', bar2:'#2f0b0b', text:'#f1f1f1' },
        blank: { bar1:'#b6b6b6', bar2:'#c9c9c9', text:'#f1f1f1' },
        xpBlue: { bar1:'#0a2e8f', bar2:'#4f86d8', text:'#ffffff' },
      };

      const THEME_PRESETS = [
        { id:'default', nameKey:'theme.default', titlebarColor:'defaultBlue', wallpaperId:'classic', darkMode:false },
        { id:'totvers', nameKey:'theme.totvers', titlebarColor:'pinkLight', wallpaperId:'tot', darkMode:false },
        { id:'matrix', nameKey:'theme.matrix', titlebarColor:'greenDark', wallpaperId:'matrix', darkMode:true },
        { id:'xp98', nameKey:'theme.xp98', titlebarColor:'xpBlue', wallpaperId:'xp98bliss', darkMode:false },
        { id:'blank', nameKey:'theme.blank', titlebarColor:'blank', wallpaperId:'classic', darkMode:false },
      ];

      const VIRTUAL_ICONS = [
        { id:'snake', titleKey:'games.snake', iconFile:'./assets/icons/snake.png' },
        { id:'dope-skate', titleKey:'games.dopeSkate', iconFile:'./assets/icons/dope-skate.png' }
      ];

      function initSfx(){
        Object.values(SFX).forEach(entry => {
          entry.audio = new Audio(entry.src);
          entry.audio.preload = 'auto';
          entry.audio.volume = 0.5;
        });
      }

      function playSfx(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        try{
          entry.audio.currentTime = 0;
          const p = entry.audio.play();
          if(p && typeof p.then === 'function'){
            return p.then(()=>{
              entry.playing = false;
              return true;
            }).catch(()=>{
              entry.playing = false;
              return false;
            });
          }
          entry.playing = false;
          return Promise.resolve(true);
        } catch {
          entry.playing = false;
          return Promise.resolve(false);
        }
      }

      function playSfxOnce(name, opts = {}){
        const entry = SFX[name];
        if(!entry || entry.played) return Promise.resolve(false);
        return playSfx(name).then((ok)=>{
          if(ok){
            entry.played = true;
            entry.pending = false;
          } else if(opts.allowPending){
            entry.pending = true;
          }
          return ok;
        });
      }

      function playSfxAndWait(name){
        const entry = SFX[name];
        if(!entry || !entry.audio) return Promise.resolve(false);
        if(entry.playing) return Promise.resolve(false);
        entry.playing = true;
        return new Promise(resolve => {
          const audio = entry.audio;
          const cleanup = ()=>{
            audio.removeEventListener('ended', onEnd);
            audio.removeEventListener('error', onError);
          };
          const onEnd = ()=>{
            cleanup();
            entry.playing = false;
            resolve(true);
          };
          const onError = ()=>{
            cleanup();
            entry.playing = false;
            resolve(false);
          };
          audio.addEventListener('ended', onEnd, { once: true });
          audio.addEventListener('error', onError, { once: true });
          try{
            audio.currentTime = 0;
            const p = audio.play();
            if(p && typeof p.then === 'function'){
              p.catch(()=>{ onError(); });
            }
          } catch {
            onError();
          }
        });
      }

      function armBootUnlock(){
        const entry = SFX.boot;
        if(!entry || entry.played || !entry.pending || entry.unlockArmed) return;
        entry.unlockArmed = true;
        const loginEl = $('#login');
        if(!loginEl){
          entry.unlockArmed = false;
          return;
        }
        const handler = ()=>{
          if($('#login').classList.contains('hidden')){
            entry.pending = false;
            entry.unlockArmed = false;
            return;
          }
          playSfxOnce('boot').finally(()=>{
            entry.pending = false;
            entry.unlockArmed = false;
          });
        };
        const wrapped = ()=>{
          loginEl.removeEventListener('pointerdown', wrapped, true);
          loginEl.removeEventListener('keydown', wrapped, true);
          handler();
        };
        loginEl.addEventListener('pointerdown', wrapped, true);
        loginEl.addEventListener('keydown', wrapped, true);
      }

      function loadIconPositions(){
        try{
          const raw = localStorage.getItem(ICON_POS_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch {
          return {};
        }
      }

      function saveIconPositions(pos){
        try{
          localStorage.setItem(ICON_POS_KEY, JSON.stringify(pos));
        } catch {}
      }

      function legacyDefaultIconPos(index){
        // Layout similar to the old grid: 6 rows then new column
        const rows = 6;
        const col = Math.floor(index / rows);
        const row = index % rows;
        return {
          x: col * (ICON_SIZE.w + ICON_GAP.x),
          y: row * (ICON_SIZE.h + ICON_GAP.y)
        };
      }

      function clampIconPos(x, y){
        const area = $('#desktopArea').getBoundingClientRect();
        const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
        const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));
        return {
          x: clamp(Math.floor(x), 0, maxX),
          y: clamp(Math.floor(y), 0, maxY)
        };
      }
      const GRID_SNAP_KEY = 'bliss98_grid_snap';

function loadGridSnap(){
  try{
    const raw = localStorage.getItem(GRID_SNAP_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveGridSnap(){
  try{
    localStorage.setItem(GRID_SNAP_KEY, state.gridSnap ? '1' : '0');
  } catch {}
}

function snapToGrid(x, y){
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const sx = Math.round(x / stepX) * stepX;
  const sy = Math.round(y / stepY) * stepY;
  return clampIconPos(sx, sy);
}

function getGridMetrics(){
  const area = $('#desktopArea').getBoundingClientRect();
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const cols = Math.max(1, Math.floor((area.width - 6) / stepX));
  const rows = Math.max(1, Math.floor((area.height - 6) / stepY));
  return { stepX, stepY, cols, rows };
}

function snapToGridClamped(x, y, metrics){
  const snapped = snapToGrid(x, y);
  const maxX = (metrics.cols - 1) * metrics.stepX;
  const maxY = (metrics.rows - 1) * metrics.stepY;
  return {
    x: clamp(snapped.x, 0, maxX),
    y: clamp(snapped.y, 0, maxY)
  };
}

function gridCellFromPos(x, y, metrics){
  return {
    col: clamp(Math.round(x / metrics.stepX), 0, metrics.cols - 1),
    row: clamp(Math.round(y / metrics.stepY), 0, metrics.rows - 1)
  };
}

function gridPosFromCell(cell, metrics){
  return { x: cell.col * metrics.stepX, y: cell.row * metrics.stepY };
}

function findFreeCell(startCell, occupied, metrics){
  const total = metrics.cols * metrics.rows;
  const startIdx = startCell.row * metrics.cols + startCell.col;
  for(let i = 0; i < total; i++){
    const idx = (startIdx + i) % total;
    const col = idx % metrics.cols;
    const row = Math.floor(idx / metrics.cols);
    const key = `${col},${row}`;
    if(!occupied.has(key)){
      return { col, row };
    }
  }
  return startCell;
}

function placeOnFreeCell(x, y, occupied, metrics){
  const snapped = snapToGridClamped(x, y, metrics);
  const cell = gridCellFromPos(snapped.x, snapped.y, metrics);
  const key = `${cell.col},${cell.row}`;
  const targetCell = occupied.has(key) ? findFreeCell(cell, occupied, metrics) : cell;
  const pos = gridPosFromCell(targetCell, metrics);
  occupied.set(`${targetCell.col},${targetCell.row}`, true);
  return {
    x: pos.x,
    y: pos.y,
    changed: targetCell.col !== cell.col || targetCell.row !== cell.row || pos.x !== snapped.x || pos.y !== snapped.y
  };
}

function getIconLabel(app){
  return state.iconLabels[app.id] || t(app.titleKey);
}

function getTrashIconFile(){
  return state.trash && state.trash.size > 0
    ? './assets/icons/trash2.png'
    : './assets/icons/trash1.png';
}

function updateTrashIconUI(){
  const trashFile = getTrashIconFile();

  const desktopIcon = document.querySelector('.icon[data-app-id="trash"] img');
  if(desktopIcon) desktopIcon.src = trashFile;

  const startIcon = document.querySelector('#startMenu .menu-item img[data-app-id="trash"]');
  if(startIcon) startIcon.src = trashFile;

  const win = document.getElementById('win_trash');
  if(win){
    const titleIcon = win.querySelector('.title-left img');
    if(titleIcon) titleIcon.src = trashFile;
  }

  const taskBtn = document.querySelector('#taskButtons img[data-app-id="trash"]');
  if(taskBtn) taskBtn.src = trashFile;
}

function buildOccupied(excludeIds, metrics){
  const occupied = new Map();
  const exclude = new Set(excludeIds || []);
  $$('.icon').forEach(el => {
    const id = el.dataset.appId;
    if(exclude.has(id)) return;
    const x = parseInt(el.style.left || '0', 10);
    const y = parseInt(el.style.top || '0', 10);
    const cell = gridCellFromPos(x, y, metrics);
    occupied.set(`${cell.col},${cell.row}`, true);
  });
  return occupied;
}

function getDefaultIconLayout(){
  const area = $('#desktopArea').getBoundingClientRect();
  const metrics = getGridMetrics();
  const isMobile = area.width <= 520;
  const order = ['settings','games','about','videos','mediaplayer','diev','art','contact','poetry','music','clothes'];
  const available = APPS.filter(app => app.showOnDesktop !== false && app.id !== 'trash' && !state.trash.has(app.id) && !isInFolder(app.id));
  const availableIds = new Set(available.map(app => app.id));
  const ordered = order.filter(id => availableIds.has(id)).concat(
    available.map(app => app.id).filter(id => !order.includes(id))
  );

  const layout = {};
  const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
  const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));

  if(isMobile){
    const cols = Math.max(1, Math.floor((area.width - 6) / metrics.stepX));
    const rows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    const trashCell = { col: cols - 1, row: rows - 1 };
    let i = 0;
    ordered.forEach(id => {
      let col = i % cols;
      let row = Math.floor(i / cols);
      if(col === trashCell.col && row === trashCell.row){
        i += 1;
        col = i % cols;
        row = Math.floor(i / cols);
      }
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      i += 1;
    });
  } else {
    let col = 0;
    let row = 0;
    const maxRows = Math.max(1, Math.floor((area.height - 6) / metrics.stepY));
    ordered.forEach(id => {
      const x = clamp(col * metrics.stepX, 0, maxX);
      const y = clamp(row * metrics.stepY, 0, maxY);
      layout[id] = snapToGridClamped(x, y, metrics);
      row += 1;
      if(row >= maxRows){
        row = 0;
        col += 1;
      }
    });
  }

  const trashX = snapToGridClamped(maxX, maxY, metrics).x;
  const trashY = snapToGridClamped(maxX, maxY, metrics).y;
  layout.trash = { x: trashX, y: trashY };

  return layout;
}

function isOverTrash(x, y){
  const trashEl = document.querySelector('.icon[data-app-id="trash"]');
  if(!trashEl) return false;
  const r = trashEl.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function moveIconsToTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.add(id));
  Object.keys(state.folders).forEach(folderId => {
    removeFromFolder(folderId, filtered);
  });
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function restoreFromTrash(ids){
  const filtered = ids.filter(id => id && id !== 'trash');
  if(filtered.length === 0) return;
  filtered.forEach(id => state.trash.delete(id));
  Object.keys(state.folders).forEach(folderId => {
    removeFromFolder(folderId, filtered);
  });
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function emptyTrash(){
  state.trash = new Set();
  state.trashSelection = new Set();
  saveTrash();
  renderIcons();
  renderTrashWindow();
  updateTrashIconUI();
}

function renderTrashWindow(){
  const win = document.getElementById('win_trash');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.trash();
  applyI18nTo(win);
  content.classList.toggle('trash-empty', state.trash.size === 0);
  const items = win.querySelectorAll('[data-trash-id]');
  items.forEach(item => {
    const id = item.dataset.trashId;
    item.classList.toggle('selected', state.trashSelection.has(id));
  });
  const restoreBtn = win.querySelector('[data-trash-action="restore"]');
  const restoreAllBtn = win.querySelector('[data-trash-action="restoreAll"]');
  if(restoreBtn) restoreBtn.disabled = state.trash.size === 0;
  if(restoreAllBtn) restoreAllBtn.disabled = state.trash.size === 0;
}

function renderPoetryWindow(){
  const win = document.getElementById('win_poetry');
  if(!win) return;
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.poetry();
  applyI18nTo(win);
  const items = win.querySelectorAll('[data-poem-id]');
  items.forEach(item => {
    const id = item.dataset.poemId;
    item.classList.toggle('selected', state.poetry.selectedId === id);
  });
}

function renderGamesWindow(){
  const win = document.getElementById('win_games');
  if(!win) return;
  if(!win.dataset.ctxGuard){
    win.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      e.stopPropagation();
    });
    win.dataset.ctxGuard = '1';
  }
  const content = win.querySelector('.content');
  if(!content) return;
  content.innerHTML = CONTENT.games();
  content.dataset.fitKey = `games:${state.games.view}`;
  applyI18nTo(win);
  const mobileGameView = isMobileGameMode() && (state.games.view === 'dope-skate' || state.games.view === 'snake');
  if(state.games.view === 'dope-skate' || state.games.view === 'snake'){
    enterMobileFullscreen(state.games.view, win);
  } else {
    win.classList.remove('mobile-game');
  }

  if(state.games.view === 'list'){
    const firstId = getFirstGameId();
    if(!state.games.selectedId) state.games.selectedId = firstId;
    const items = Array.from(win.querySelectorAll('[data-game-id]'));
    if(state.games.selectedId && !items.some(item => item.dataset.gameId === state.games.selectedId)){
      state.games.selectedId = firstId;
    }
    const listEl = win.querySelector('#gamesList');
    if(listEl){
      listEl.className = 'games-grid';
    }

    items.forEach(item => {
      const id = item.dataset.gameId;
      item.classList.toggle('selected', state.games.selectedId === id);
      item.addEventListener('click', (e)=>{
        if(e.detail > 1) return;
        state.games.selectedId = id;
        items.forEach(btn => btn.classList.toggle('selected', btn === item));
      });
      item.addEventListener('dblclick', (e)=>{
        e.stopPropagation();
        openGameFromHub(id);
      });
      item.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          openGameFromHub(id);
        }
      });
      makeGameItemDraggable(item, id);
    });
    if(!mobileGameView) autoFitWindow(win, 'games');
    return;
  }

  if(state.games.view === 'leaderboard'){
    if(!mobileGameView) autoFitWindow(win, 'games');
    return;
  }

  if(state.games.view === 'dope-skate'){
    DopeSkateGame.mount(win);
    mountMobileGameDock('dope-skate', win);
  }
  if(state.games.view === 'snake'){
    initSnakeInWindow(win);
    mountMobileGameDock('snake', win);
  }
  if(!mobileGameView) autoFitWindow(win, 'games');
}

function initGamesWindow(){
  renderGamesWindow();
}

function getFirstGameId(){
  const items = state.folders.games || [];
  return items[0] || null;
}

const MOBILE_GAME_DEBUG = new URLSearchParams(window.location.search).get('mobile') === '1';
const MOBILE_GAME_MQ = window.matchMedia('(max-width: 520px)');
const MOBILE_GAME_COARSE = window.matchMedia('(pointer: coarse)');

function isMobileGameMode(){
  return MOBILE_GAME_DEBUG || MOBILE_GAME_MQ.matches || MOBILE_GAME_COARSE.matches;
}

function enterMobileFullscreen(gameId, winEl){
  if(!winEl) return;
  const mobile = isMobileGameMode();
  winEl.classList.toggle('mobile-game', mobile);
  if(!mobile) return;

  const area = $('#desktopArea').getBoundingClientRect();
  const margin = 0;
  const newW = Math.max(240, Math.floor(area.width - margin * 2));
  const newH = Math.max(200, Math.floor(area.height - margin * 2));
  winEl.style.left = `${margin}px`;
  winEl.style.top = `${margin}px`;
  winEl.style.width = `${newW}px`;
  winEl.style.height = `${newH}px`;

  const w = state.windows.get('games');
  if(w){
    w.left = margin;
    w.top = margin;
    w.width = newW;
    w.height = newH;
  }
}

let mobileFullscreenArmed = false;
function armMobileFullscreen(targetEl){
  if(mobileFullscreenArmed || !targetEl) return;
  mobileFullscreenArmed = true;
  const handler = ()=>{
    if(document.fullscreenElement){
      mobileFullscreenArmed = false;
      return;
    }
    if(targetEl.requestFullscreen){
      targetEl.requestFullscreen().catch(()=>{});
    }
    mobileFullscreenArmed = false;
  };
  targetEl.addEventListener('pointerdown', handler, { once:true });
}

function mountMobileGameDock(gameId, winEl){
  if(!winEl) return;
  const mobile = isMobileGameMode();
  const container = winEl.querySelector('.content');
  if(!container) return;
  let dock = container.querySelector(`.ps1-dock[data-game="${gameId}"]`);
  if(!mobile){
    if(dock) dock.remove();
    return;
  }
  if(!dock){
    dock = document.createElement('div');
    dock.className = 'ps1-dock';
    dock.dataset.game = gameId;
    dock.dataset.mode = state.mobileControlsMode;
    dock.innerHTML = `
      <div class="ps1-dock-body">
        <div class="ps1-brand">BLISS</div>
        <div class="ps1-dpad" data-mobile-dpad>
          <button class="ps1-dpad-corner ne" type="button" data-mobile-action="ne" aria-label="Up-right"></button>
          <button class="ps1-dpad-corner se" type="button" data-mobile-action="se" aria-label="Down-right"></button>
          <button class="ps1-dpad-corner sw" type="button" data-mobile-action="sw" aria-label="Down-left"></button>
          <button class="ps1-dpad-corner nw" type="button" data-mobile-action="nw" aria-label="Up-left"></button>
          <button class="ps1-dpad-btn up" type="button" data-mobile-action="up"></button>
          <button class="ps1-dpad-btn down" type="button" data-mobile-action="down"></button>
          <button class="ps1-dpad-btn left" type="button" data-mobile-action="left"></button>
          <button class="ps1-dpad-btn right" type="button" data-mobile-action="right"></button>
        </div>
        <div class="ps1-stick" data-mobile-stick="left" aria-label="Joystick">
          <div class="ps1-stick-knob"></div>
        </div>
        <div class="ps1-face">
          <button class="ps1-face-btn triangle" type="button" data-mobile-action="trick2" aria-label="Trick 2"></button>
          <button class="ps1-face-btn circle" type="button" data-mobile-action="trick3" aria-label="Trick 3"></button>
          <button class="ps1-face-btn cross" type="button" data-mobile-action="jump" aria-label="Jump"></button>
          <button class="ps1-face-btn square" type="button" data-mobile-action="trick1" aria-label="Trick 1"></button>
        </div>
        <div class="ps1-analog">
          <button class="ps1-analog-btn" type="button" data-mobile-action="analog">ANALOG</button>
          <span class="ps1-analog-led-rect"></span>
        </div>
        <div class="ps1-center">
          <button class="ps1-center-btn select" type="button" data-mobile-action="select">Select</button>
          <button class="ps1-center-btn start" type="button" data-mobile-action="start">Start</button>
        </div>
      </div>
    `;
    container.appendChild(dock);
  }
  armMobileFullscreen(container);
  if(dock.dataset.bound !== '1'){
    bindMobileOverlay(gameId, dock);
    dock.dataset.bound = '1';
  }
}

function bindMobileOverlay(gameId, overlay){
  function setMobileControlsMode(mode){
    const next = (mode === 'analog') ? 'analog' : 'dpad';
    state.mobileControlsMode = next;
    saveMobileControlsMode(next);
    $$('.ps1-dock').forEach(dock => { dock.dataset.mode = next; });
  }

  overlay.dataset.mode = state.mobileControlsMode;
  const stick = overlay.querySelector('[data-mobile-stick="left"]');
  if(stick){
    const knob = stick.querySelector('.ps1-stick-knob');
    const radius = 36;
    let pointerId = null;
    let center = { x: 0, y: 0 };
    let lastDir = '';

    const updateStick = (dx, dy)=>{
      if(state.mobileControlsMode !== 'analog') return;
      const dist = Math.min(radius, Math.hypot(dx, dy));
      const angle = Math.atan2(dy, dx);
      const cx = Math.cos(angle) * dist;
      const cy = Math.sin(angle) * dist;
      if(knob) knob.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
      const normX = cx / radius;
      const normY = cy / radius;
      if(gameId === 'dope-skate' && isDopeSkateActive()){
        dopeSkate.inputs.left = normX < -0.35;
        dopeSkate.inputs.right = normX > 0.35;
      }
      if(gameId === 'snake' && isSnakeActive()){
        if(Math.abs(normX) > Math.abs(normY)){
          if(normX > 0.45 && lastDir !== 'r'){ snakeHandleDirection(1, 0); lastDir = 'r'; }
          if(normX < -0.45 && lastDir !== 'l'){ snakeHandleDirection(-1, 0); lastDir = 'l'; }
        } else {
          if(normY > 0.45 && lastDir !== 'd'){ snakeHandleDirection(0, 1); lastDir = 'd'; }
          if(normY < -0.45 && lastDir !== 'u'){ snakeHandleDirection(0, -1); lastDir = 'u'; }
        }
      }
    };

    const resetStick = ()=>{
      if(knob) knob.style.transform = 'translate(-50%, -50%)';
      if(gameId === 'dope-skate'){
        dopeSkate.inputs.left = false;
        dopeSkate.inputs.right = false;
      }
    };

    stick.addEventListener('pointerdown', (e)=>{
      if(e.pointerType === 'mouse' && e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      pointerId = e.pointerId;
      const rect = stick.getBoundingClientRect();
      center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
      stick.setPointerCapture(pointerId);
      updateStick(e.clientX - center.x, e.clientY - center.y);
    });

    stick.addEventListener('pointermove', (e)=>{
      if(pointerId === null || e.pointerId !== pointerId) return;
      e.preventDefault();
      e.stopPropagation();
      updateStick(e.clientX - center.x, e.clientY - center.y);
    });

    const endPointer = (e)=>{
      if(pointerId === null || e.pointerId !== pointerId) return;
      pointerId = null;
      e.stopPropagation();
      resetStick();
      try{ stick.releasePointerCapture(e.pointerId); } catch {}
    };
    stick.addEventListener('pointerup', endPointer);
    stick.addEventListener('pointercancel', endPointer);
  }

  const dpad = overlay.querySelector('[data-mobile-dpad]');
  if(dpad){
    dpad.querySelectorAll('[data-mobile-action]').forEach(btn => {
      btn.addEventListener('pointerdown', (e)=>{
        if(state.mobileControlsMode !== 'dpad') return;
        e.preventDefault();
        e.stopPropagation();
        const action = btn.dataset.mobileAction;
        if(gameId === 'snake' && isSnakeActive()){
          if(action === 'up') snakeHandleDirection(0, -1);
          if(action === 'down') snakeHandleDirection(0, 1);
          if(action === 'left') snakeHandleDirection(-1, 0);
          if(action === 'right') snakeHandleDirection(1, 0);
        }
        if(gameId === 'dope-skate' && isDopeSkateActive()){
          if(action === 'left') dopeSkate.inputs.left = true;
          if(action === 'right') dopeSkate.inputs.right = true;
        }
      });
      btn.addEventListener('pointerup', (e)=>{
        if(gameId === 'dope-skate'){
          const action = btn.dataset.mobileAction;
          if(action === 'left') dopeSkate.inputs.left = false;
          if(action === 'right') dopeSkate.inputs.right = false;
        }
      });
      btn.addEventListener('pointercancel', (e)=>{
        if(gameId === 'dope-skate'){
          const action = btn.dataset.mobileAction;
          if(action === 'left') dopeSkate.inputs.left = false;
          if(action === 'right') dopeSkate.inputs.right = false;
        }
      });
    });
  }

  overlay.querySelectorAll('[data-mobile-action]').forEach(btn => {
    btn.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      if(btn.dataset.mobileAction === 'analog'){
        setMobileControlsMode(state.mobileControlsMode === 'analog' ? 'dpad' : 'analog');
        return;
      }
      if(gameId === 'dope-skate' && isDopeSkateActive()){
        const action = btn.dataset.mobileAction;
        if(action === 'jump') dopeSkateRegisterJump();
        if(action === 'trick1') dopeSkateRegisterTrick('trick1');
        if(action === 'trick2') dopeSkateRegisterTrick('trick2');
        if(action === 'trick3') dopeSkateRegisterTrick('trick3');
        if(action === 'start'){
          const menuHidden = dopeSkate.els && dopeSkate.els.menuOverlay && dopeSkate.els.menuOverlay.classList.contains('hidden');
          if(menuHidden) dopeSkateShowMenu('play');
          else dopeSkateHideMenu();
        }
        if(action === 'select') dopeSkateShowMenu('play');
      }
      if(gameId === 'snake' && isSnakeActive()){
        const action = btn.dataset.mobileAction;
        if(action === 'ne' || action === 'nw' || action === 'se' || action === 'sw'){
          const dir = snake.dir || { x: 1, y: 0 };
          if(action === 'ne'){
            if(dir.x !== 0) snakeHandleDirection(0, -1);
            else snakeHandleDirection(1, 0);
          }
          if(action === 'nw'){
            if(dir.x !== 0) snakeHandleDirection(0, -1);
            else snakeHandleDirection(-1, 0);
          }
          if(action === 'se'){
            if(dir.x !== 0) snakeHandleDirection(0, 1);
            else snakeHandleDirection(1, 0);
          }
          if(action === 'sw'){
            if(dir.x !== 0) snakeHandleDirection(0, 1);
            else snakeHandleDirection(-1, 0);
          }
          return;
        }
        if(action === 'start'){
          if(!snake.started || snake.gameOver) snakeStartGame();
          else snakeTogglePause();
        }
        if(action === 'select') snakeStartGame();
        if(action === 'jump'){
          if(!snake.started || snake.gameOver) snakeStartGame();
        }
      }
    });
  });
}

function openGameFromHub(id){
  if(id === 'snake'){
    state.games.view = 'snake';
    state.games.selectedId = 'snake';
    renderGamesWindow();
    return;
  }
  if(id === 'dope-skate'){
    state.games.view = 'dope-skate';
    state.games.selectedId = 'dope-skate';
    renderGamesWindow();
    return;
  }
  if(getAppById(id)){
    openApp(id);
  }
}

function backToGamesHub(){
  state.games.view = 'list';
  state.games.selectedId = getFirstGameId();
  snakeStop();
  DopeSkateGame.unmount();
  renderGamesWindow();
}

const SNAKE_SPEEDS = {
  slow: 180,
  normal: 130,
  fast: 90,
};

const GAMES_LEADER_KEY = 'bliss98_games_leaderboard';

let snake = {
  grid: 20,
  body: [],
  dir: { x: 1, y: 0 },
  nextDir: { x: 1, y: 0 },
  food: { x: 0, y: 0 },
  eatPulses: [],
  running: false,
  paused: false,
  score: 0,
  gameOver: false,
  started: false,
  speed: 'normal',
  timer: null,
  cell: 16,
  baseSize: 320,
  renderScaleX: 1,
  renderScaleY: 1,
  renderDpr: 1,
  renderTargetW: 0,
  renderTargetH: 0,
  resizeObserver: null,
  resizeRaf: null,
  resizeHandler: null,
  ctx: null,
  els: null,
  swipeStart: null,
};

function loadSnakeHighScore(){
  try{
    const raw = localStorage.getItem(SNAKE_HIGH_KEY);
    const parsed = parseInt(raw || '0', 10);
    return Number.isFinite(parsed) ? parsed : 0;
  } catch {
    return 0;
  }
}

function saveSnakeHighScore(score){
  try{ localStorage.setItem(SNAKE_HIGH_KEY, String(score)); } catch {}
}

function loadGamesLeaderboardData(){
  try{
    const raw = localStorage.getItem(GAMES_LEADER_KEY);
    if(raw) return JSON.parse(raw);
  } catch {}
  return { snake: { best: 0, lastPlayed: null }, dopeSkate: { best: 0, lastPlayed: null } };
}

function saveGamesLeaderboardData(data){
  try{ localStorage.setItem(GAMES_LEADER_KEY, JSON.stringify(data)); } catch {}
}

function recordGameScore(gameId, best, lastPlayed = null){
  const data = loadGamesLeaderboardData();
  const entry = data[gameId] || { best: 0, lastPlayed: null };
  if(best > entry.best){
    entry.best = best;
  }
  if(lastPlayed) entry.lastPlayed = lastPlayed;
  data[gameId] = entry;
  saveGamesLeaderboardData(data);
}

function getGamesLeaderboard(){
  const data = loadGamesLeaderboardData();
  // TODO: plug in backend leaderboard source.
  const items = [
    { id:'dopeSkate', label: t('games.dopeSkate'), best: data.dopeSkate ? data.dopeSkate.best : 0 },
    { id:'snake', label: t('games.snake'), best: data.snake ? data.snake.best : 0 },
  ];
  const total = items.reduce((sum, item)=>sum + (item.best || 0), 0);
  return { items, total };
}

function isSnakeActive(){
  return state.activeWindowId === 'games' && state.games.view === 'snake';
}

function snakeResizeCanvas(){
  if(!snake.els || !snake.els.canvas || !snake.ctx) return;
  const board = snake.els.board;
  if(!board) return;
  const rect = board.getBoundingClientRect();
  const targetW = Math.max(1, Math.floor(rect.width));
  const targetH = Math.max(1, Math.floor(rect.height));
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  if(targetW === snake.renderTargetW && targetH === snake.renderTargetH && snake.renderDpr === dpr) return;
  snake.renderScaleX = targetW / snake.baseSize;
  snake.renderScaleY = targetH / snake.baseSize;
  snake.renderDpr = dpr;
  snake.renderTargetW = targetW;
  snake.renderTargetH = targetH;
  if(snake.els.canvas.style.width !== `${targetW}px`) snake.els.canvas.style.width = `${targetW}px`;
  if(snake.els.canvas.style.height !== `${targetH}px`) snake.els.canvas.style.height = `${targetH}px`;
  snake.els.canvas.width = Math.max(1, Math.floor(targetW * dpr));
  snake.els.canvas.height = Math.max(1, Math.floor(targetH * dpr));
  snake.ctx.imageSmoothingEnabled = false;
}

function initSnakeInWindow(winEl){
  const board = winEl.querySelector('#snakeBoard');
  const canvas = winEl.querySelector('#snakeCanvas');
  if(!board || !canvas) return;

  snake.els = {
    board,
    canvas,
    startBtn: winEl.querySelector('[data-snake-action="start"]'),
    pauseBtn: winEl.querySelector('[data-snake-action="pause"]'),
    playAgainBtn: winEl.querySelector('[data-snake-action="playAgain"]'),
    speedSelect: winEl.querySelector('[data-snake-speed]'),
    score: winEl.querySelector('[data-snake-score]'),
    high: winEl.querySelector('[data-snake-high]'),
    overlay: winEl.querySelector('#snakeOverlay'),
    overScore: winEl.querySelector('[data-snake-over-score]'),
    backBtn: winEl.querySelector('[data-games-action="back"]'),
  };

  snake.ctx = canvas.getContext('2d');
  snake.ctx.imageSmoothingEnabled = false;
  snake.renderTargetW = 0;
  snake.renderTargetH = 0;
  snake.renderScaleX = 1;
  snake.renderScaleY = 1;

  if(typeof state.snake.highScore !== 'number' || Number.isNaN(state.snake.highScore)){
    state.snake.highScore = loadSnakeHighScore();
  }
  snake.speed = state.snake.speed || 'normal';
  if(snake.els.speedSelect) snake.els.speedSelect.value = snake.speed;

  const fixedSize = 320;
  snake.baseSize = fixedSize;
  canvas.width = fixedSize;
  canvas.height = fixedSize;
  canvas.style.width = fixedSize + 'px';
  canvas.style.height = fixedSize + 'px';
  snake.cell = Math.max(8, Math.floor(fixedSize / snake.grid));
  snakeDraw();

  if(snake.els.backBtn){
    snake.els.backBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      backToGamesHub();
    });
  }
  if(snake.els.startBtn){
    snake.els.startBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeTogglePause();
    });
  }
  if(snake.els.playAgainBtn){
    snake.els.playAgainBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      snakeStartGame();
    });
  }
  if(snake.els.speedSelect){
    snake.els.speedSelect.addEventListener('change', (e)=>{
      const val = e.target.value;
      state.snake.speed = val;
      snake.speed = val;
      if(snake.running) snakeStartLoop();
    });
  }

  if(snake.resizeObserver){
    snake.resizeObserver.disconnect();
    snake.resizeObserver = null;
  }
  if(window.ResizeObserver){
    snake.resizeObserver = new ResizeObserver(()=>{
      if(snake.resizeRaf) return;
      snake.resizeRaf = requestAnimationFrame(()=>{
        snake.resizeRaf = null;
        snakeResizeCanvas();
      });
    });
    snake.resizeObserver.observe(board);
  }
  snakeResizeCanvas();
  if(!snake.resizeHandler){
    snake.resizeHandler = ()=>{
      if(snake.resizeRaf) return;
      snake.resizeRaf = requestAnimationFrame(()=>{
        snake.resizeRaf = null;
        snakeResizeCanvas();
      });
    };
    window.addEventListener('resize', snake.resizeHandler);
    window.addEventListener('orientationchange', snake.resizeHandler);
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', snake.resizeHandler);
    }
  }

  board.addEventListener('touchstart', snakeHandleTouchStart, { passive: false });
  board.addEventListener('touchmove', snakeHandleTouchMove, { passive: false });
  board.addEventListener('touchend', snakeHandleTouchEnd, { passive: false });
  board.addEventListener('pointerdown', (e)=>{
    if(e.pointerType === 'mouse' || e.pointerType === 'pen'){
      snakeHandleTap(e.clientX, e.clientY);
    }
  });

  snakePrepareBoard();
  updateSnakeUI();
}

function snakePrepareBoard(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  snake.score = 0;
  snake.eatPulses = [];
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snakePlaceFood();
  snakeDraw();
  updateSnakeUI();
}

function snakeStartGame(){
  const mid = Math.floor(snake.grid / 2);
  snake.body = [
    { x: mid, y: mid },
    { x: mid - 1, y: mid },
    { x: mid - 2, y: mid },
  ];
  snake.dir = { x: 1, y: 0 };
  snake.nextDir = { x: 1, y: 0 };
  snake.score = 0;
  snake.eatPulses = [];
  snake.running = true;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = true;
  recordGameScore('snake', state.snake.highScore || 0, new Date().toISOString());
  snakePlaceFood();
  snakeStartLoop();
  updateSnakeUI();
  snakeDraw();
}

function snakeStartLoop(){
  snakeStopLoop();
  const step = SNAKE_SPEEDS[snake.speed] || SNAKE_SPEEDS.normal;
  snake.timer = setInterval(snakeTick, step);
}

function snakeStopLoop(){
  if(snake.timer){
    clearInterval(snake.timer);
    snake.timer = null;
  }
}

function snakeTogglePause(){
  if(!snake.running) return;
  snake.paused = !snake.paused;
  updateSnakeUI();
}

function snakeStop(){
  snakeStopLoop();
  snake.running = false;
  snake.paused = false;
  snake.gameOver = false;
  snake.started = false;
  if(snake.resizeObserver){
    snake.resizeObserver.disconnect();
    snake.resizeObserver = null;
  }
  if(snake.resizeHandler){
    window.removeEventListener('resize', snake.resizeHandler);
    window.removeEventListener('orientationchange', snake.resizeHandler);
    if(window.visualViewport){
      window.visualViewport.removeEventListener('resize', snake.resizeHandler);
    }
    snake.resizeHandler = null;
  }
  snake.els = null;
  snake.ctx = null;
}

function snakeTick(){
  if(!snake.running || snake.paused || snake.gameOver) return;
  snake.dir = { ...snake.nextDir };
  const head = snake.body[0];
  const next = {
    x: (head.x + snake.dir.x + snake.grid) % snake.grid,
    y: (head.y + snake.dir.y + snake.grid) % snake.grid,
  };
  if(snake.body.some(seg => seg.x === next.x && seg.y === next.y)){
    snakeGameOver();
    return;
  }

  snake.body.unshift(next);
  if(next.x === snake.food.x && next.y === snake.food.y){
    snake.score += 10;
    snakePlaceFood();
    snake.eatPulses.push({ t: 0 });
  } else {
    snake.body.pop();
  }
  if(snake.eatPulses.length){
    snake.eatPulses.forEach(p => { p.t += 1; });
    snake.eatPulses = snake.eatPulses.filter(p => p.t < snake.body.length - 1);
  }
  snakeDraw();
  updateSnakeUI();
}

function snakePlaceFood(){
  let x = 0;
  let y = 0;
  let guard = 0;
  do{
    x = Math.floor(Math.random() * snake.grid);
    y = Math.floor(Math.random() * snake.grid);
    guard += 1;
  } while(snake.body.some(seg => seg.x === x && seg.y === y) && guard < 200);
  snake.food = { x, y };
}

function snakeGameOver(){
  snake.running = false;
  snake.paused = false;
  snake.gameOver = true;
  snakeStopLoop();
  if(snake.score > state.snake.highScore){
    state.snake.highScore = snake.score;
    saveSnakeHighScore(state.snake.highScore);
  }
  recordGameScore('snake', state.snake.highScore, new Date().toISOString());
  updateSnakeUI();
}

function snakeDraw(){
  if(!snake.ctx || !snake.els) return;
  const ctx = snake.ctx;
  const cell = snake.cell;
  const base = snake.baseSize || 320;
  const dpr = snake.renderDpr || 1;
  const scaleX = snake.renderScaleX || 1;
  const scaleY = snake.renderScaleY || 1;

  ctx.setTransform(dpr * scaleX, 0, 0, dpr * scaleY, 0, 0);
  ctx.clearRect(0, 0, base, base);
  const tileLight = '#8ea77a';
  const tileDark = '#7a9168';
  ctx.fillStyle = tileLight;
  ctx.fillRect(0, 0, base, base);
  for(let y = 0; y < snake.grid; y += 1){
    for(let x = 0; x < snake.grid; x += 1){
      if((x + y) % 2 === 0){
        ctx.fillStyle = tileDark;
        ctx.fillRect(x * cell, y * cell, cell, cell);
      }
    }
  }

  const pad = 0;
  snake.body.forEach((seg, idx)=>{
    const x = seg.x * cell + pad;
    const y = seg.y * cell + pad;
    const w = cell - pad * 2;
    const h = cell - pad * 2;
    const radius = Math.max(2, Math.floor(w * 0.2));
    ctx.fillStyle = idx === 0 ? '#2f6f2f' : '#3f8a3f';
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = '#245a24';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  const head = snake.body[0];
  if(head){
    const hx = head.x * cell + cell / 2;
    const hy = head.y * cell + cell / 2;
    const dir = snake.dir;
    const noseLen = Math.max(4, cell * 0.28);
    ctx.fillStyle = '#2a5f2a';
    ctx.beginPath();
    ctx.moveTo(hx + dir.x * noseLen, hy + dir.y * noseLen);
    ctx.lineTo(hx + dir.y * (noseLen * 0.6), hy - dir.x * (noseLen * 0.6));
    ctx.lineTo(hx - dir.y * (noseLen * 0.6), hy + dir.x * (noseLen * 0.6));
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#0e2910';
    const eyeOffset = Math.max(2, cell * 0.15);
    ctx.beginPath();
    ctx.arc(hx + dir.y * eyeOffset, hy - dir.x * eyeOffset, 1.5, 0, Math.PI * 2);
    ctx.arc(hx - dir.y * eyeOffset, hy + dir.x * eyeOffset, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#d14b4b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(hx + dir.x * (noseLen + 2), hy + dir.y * (noseLen + 2));
    ctx.lineTo(hx + dir.x * (noseLen + 8), hy + dir.y * (noseLen + 8));
    ctx.stroke();
  }

  if(snake.eatPulses.length){
    snake.eatPulses.forEach(pulse => {
      const idx = Math.floor(pulse.t);
      const nextIdx = Math.min(idx + 1, snake.body.length - 1);
      const segA = snake.body[idx];
      const segB = snake.body[nextIdx];
      if(!segA || !segB) return;
      const frac = pulse.t - idx;
      const px = (segA.x + (segB.x - segA.x) * frac) * cell + cell / 2;
      const py = (segA.y + (segB.y - segA.y) * frac) * cell + cell / 2;
      ctx.fillStyle = '#2a5f2a';
      ctx.beginPath();
      ctx.arc(px, py, Math.max(2, cell * 0.16), 0, Math.PI * 2);
      ctx.fill();
    });
  }

  const appleX = snake.food.x * cell + cell / 2;
  const appleY = snake.food.y * cell + cell / 2;
  const appleR = Math.max(4, cell * 0.28);
  ctx.fillStyle = '#c51f2f';
  ctx.beginPath();
  ctx.arc(appleX, appleY, appleR, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#6b3a1a';
  ctx.fillRect(appleX - 1, appleY - appleR - 4, 2, 6);
  ctx.fillStyle = '#2f7d2f';
  ctx.beginPath();
  ctx.ellipse(appleX + 4, appleY - appleR - 2, 4, 2, -0.6, 0, Math.PI * 2);
  ctx.fill();
}


function snakeHandleDirection(dx, dy){
  if(!isSnakeActive()) return;
  if(dx === -snake.dir.x && dy === -snake.dir.y) return;
  snake.nextDir = { x: dx, y: dy };
}

function snakeHandleKey(e){
  if(!isSnakeActive()) return false;
  const tag = e.target && e.target.tagName;
  if(tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return false;

  const key = e.key.toLowerCase();
  let handled = true;
  if(key === 'arrowup' || key === 'w') snakeHandleDirection(0, -1);
  else if(key === 'arrowdown' || key === 's') snakeHandleDirection(0, 1);
  else if(key === 'arrowleft' || key === 'a') snakeHandleDirection(-1, 0);
  else if(key === 'arrowright' || key === 'd') snakeHandleDirection(1, 0);
  else if(key === ' ' || key === 'spacebar') snakeTogglePause();
  else handled = false;

  if(handled){
    e.preventDefault();
  }
  return handled;
}

function snakeHandleTouchStart(e){
  if(state.windows.has('games') && state.activeWindowId !== 'games'){
    focusWindow('games');
  }
  if(!isSnakeActive()) return;
  e.preventDefault();
  const touch = e.changedTouches[0];
  snake.swipeStart = { x: touch.clientX, y: touch.clientY, t: Date.now() };
}

function snakeHandleTouchMove(e){
  if(!isSnakeActive()) return;
  e.preventDefault();
}

function snakeHandleTouchEnd(e){
  if(!isSnakeActive() || !snake.swipeStart) return;
  const touch = e.changedTouches[0];
  const dx = touch.clientX - snake.swipeStart.x;
  const dy = touch.clientY - snake.swipeStart.y;
  const absX = Math.abs(dx);
  const absY = Math.abs(dy);
  if(Math.max(absX, absY) < 18){
    snakeHandleTap(touch.clientX, touch.clientY);
    snake.swipeStart = null;
    return;
  }
  if(absX > absY){
    snakeHandleDirection(dx > 0 ? 1 : -1, 0);
  } else {
    snakeHandleDirection(0, dy > 0 ? 1 : -1);
  }
  snake.swipeStart = null;
}

function snakeHandleTap(clientX, clientY){
  if(!isSnakeActive() || !snake.els || !snake.els.canvas) return;
  const rect = snake.els.canvas.getBoundingClientRect();
  const scaleX = rect.width / (snake.baseSize || rect.width);
  const scaleY = rect.height / (snake.baseSize || rect.height);
  const x = (clientX - rect.left) / scaleX;
  const y = (clientY - rect.top) / scaleY;
  const head = snake.body[0];
  if(!head) return;
  const headX = (head.x + 0.5) * snake.cell;
  const headY = (head.y + 0.5) * snake.cell;
  const dx = x - headX;
  const dy = y - headY;
  if(Math.abs(dx) > Math.abs(dy)){
    snakeHandleDirection(dx > 0 ? 1 : -1, 0);
  } else {
    snakeHandleDirection(0, dy > 0 ? 1 : -1);
  }
}

function updateSnakeUI(){
  if(!snake.els) return;
  if(snake.els.score) snake.els.score.textContent = String(snake.score);
  if(snake.els.high) snake.els.high.textContent = String(state.snake.highScore || 0);
  if(snake.els.overScore) snake.els.overScore.textContent = String(snake.score);
  if(snake.els.overlay) snake.els.overlay.classList.toggle('hidden', !snake.gameOver);
  if(snake.els.startBtn){
    snake.els.startBtn.textContent = snake.started ? t('snake.restart') : t('snake.start');
  }
  if(snake.els.pauseBtn){
    snake.els.pauseBtn.classList.toggle('pressed', snake.paused);
  }
}

const DOPE_SKATE_ASSETS = {
  sky: './assets/skate/sky/sky.svg',
  city: './assets/skate/background/city.svg',
  ground: './assets/skate/ground/ground.svg',
  body: './assets/skate/skater/body.svg',
  hat: './assets/skate/hat/hat.svg',
  board: './assets/skate/board/board.svg',
  wheels: './assets/skate/wheels/wheels.svg',
  vodka: './assets/skate/obstacles/vodka.svg',
  trash: './assets/skate/obstacles/trash.svg',
  cone: './assets/skate/obstacles/cone.svg',
  rail: './assets/skate/obstacles/rail.svg',
  cd: './assets/skate/collectibles/cd.svg',
  bliss: './assets/skate/collectibles/bliss-letter.svg',
};

const DOPE_SKATE_DATA_KEY = 'bliss98_dope_skate_data';

const DOPE_SKATE_TRICKS = [
  { id:'ollie', name:'Ollie', points: 120 },
  { id:'kickflip', name:'Kickflip', points: 220 },
  { id:'shuvit', name:'Shuv-it', points: 180 },
  { id:'hardflip', name:'Hardflip', points: 260 },
  { id:'heelflip', name:'Heelflip', points: 220 },
  { id:'varial', name:'Varial Kickflip', points: 280 },
];

const DOPE_SKATE_GRINDS = [
  { id:'50-50', name:'50-50', pointsPerSec: 140 },
  { id:'boardslide', name:'Boardslide', pointsPerSec: 160 },
  { id:'noseslide', name:'Noseslide', pointsPerSec: 160 },
];

// Difficulty knobs: speed affects base/max speed, spawn affects obstacle gaps, score affects base/combo points.
const DOPE_SKATE_DIFFICULTY = {
  easy: { speed: 0.85, spawn: 1.35, score: 0.7 },
  medium: { speed: 1.0, spawn: 1.0, score: 1.0 },
  hard: { speed: 1.2, spawn: 0.8, score: 1.35 },
};

const DOPE_SKATE_SHOP = {
  ground: [
    { id:'classic', name:'Classic Asphalt', cost: 0, asset:'ground' },
    { id:'night', name:'Night Asphalt', cost: 120, asset:'ground' },
  ],
  background: [
    { id:'city', name:'City Lights', cost: 0, asset:'city' },
    { id:'industrial', name:'Industrial Blocks', cost: 180, asset:'city' },
  ],
  sky: [
    { id:'sky', name:'Clean Sky', cost: 0, asset:'sky' },
    { id:'sunset', name:'Sunset Haze', cost: 140, asset:'sky' },
  ],
  skater: [
    { id:'core', name:'Core Skater', cost: 0, asset:'body' },
    { id:'street', name:'Street Fit', cost: 220, asset:'body' },
  ],
  hat: [
    { id:'red', name:'Red Cap', cost: 0, asset:'hat' },
    { id:'black', name:'Black Cap', cost: 90, asset:'hat' },
  ],
  board: [
    { id:'classic', name:'Classic Deck', cost: 0, asset:'board' },
    { id:'chrome', name:'Chrome Deck', cost: 200, asset:'board' },
  ],
  wheels: [
    { id:'black', name:'Black Wheels', cost: 0, asset:'wheels' },
    { id:'blue', name:'Blue Wheels', cost: 110, asset:'wheels' },
  ],
};

let dopeSkate = {
  canvas: null,
  ctx: null,
  els: null,
  width: 640,
  height: 360,
  groundHeight: 64,
  player: null,
  obstacles: [],
  rails: [],
  collectibles: [],
  particles: [],
  spawn: {
    nextObstacleDist: 260,
    nextRailDist: 720,
    nextCdDist: 220,
    nextLetterDist: 880,
  },
  lastObstacleDist: 0,
  lastRailDist: 0,
  lastObstacleLane: 0,
  speed: 240,
  maxSpeed: 420,
  accel: 8,
  gravity: 1500,
  jumpVel: -560,
  time: 0,
  distance: 0,
  scoreBase: 0,
  comboBank: 0,
  scoreTotal: 0,
  cds: 0,
  blissCounts: { B: 0, L: 0, I: 0, S: 0 },
  combo: {
    points: 0,
    tricks: [],
    unique: new Set(),
    multiplier: 1,
    active: false,
  },
  comboWindow: 1.8,
  running: false,
  paused: false,
  gameOver: false,
  started: false,
  raf: null,
  lastTime: 0,
  assets: null,
  assetsReady: false,
  assetsLoading: false,
  offsets: { sky: 0, city: 0, ground: 0 },
  inputs: { left: false, right: false },
  jumpBufferUntil: 0,
  lastGroundedAt: 0,
  lastTrickAt: 0,
  lastTrickId: null,
  cameraShake: 0,
  gamepad: {
    jump: false,
    trick1: false,
    trick2: false,
    trick3: false,
  },
  data: null,
  audio: {
    ctx: null,
    enabled: false,
    unlocked: false,
  },
  shopCategory: 'skater',
  equippedAssets: null,
  equippedDirty: true,
  preview: null,
  difficulty: 'medium',
  spawnMultiplier: 1,
  scoreMultiplier: 1,
  renderScaleX: 1,
  renderScaleY: 1,
  renderDpr: 1,
  renderTargetW: 0,
  renderTargetH: 0,
  resizeObserver: null,
  resizeRaf: null,
  resizeHandler: null,
  lastComboHtml: '',
  lastBlissKey: '',
  startQueued: false,
};

function loadDopeSkateHighScore(){
  try{
    const raw = localStorage.getItem(DOPE_SKATE_HIGH_KEY);
    const parsed = parseInt(raw || '0', 10);
    return Number.isFinite(parsed) ? parsed : 0;
  } catch {
    return 0;
  }
}

function saveDopeSkateHighScore(score){
  try{ localStorage.setItem(DOPE_SKATE_HIGH_KEY, String(score)); } catch {}
}

function getDopeSkateDefaultData(){
  return {
    wallet: 0,
    owned: {
      ground: ['classic'],
      background: ['city'],
      sky: ['sky'],
      skater: ['core'],
      hat: ['red'],
      board: ['classic'],
      wheels: ['black'],
    },
    equipped: {
      ground: 'classic',
      background: 'city',
      sky: 'sky',
      skater: 'core',
      hat: 'red',
      board: 'classic',
      wheels: 'black',
    },
    settings: {
      difficulty: 'medium',
      sfx: true,
    },
  };
}

function loadDopeSkateData(){
  try{
    const raw = localStorage.getItem(DOPE_SKATE_DATA_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && parsed.owned && parsed.equipped) return normalizeDopeSkateData(parsed);
    }
  } catch {}
  return getDopeSkateDefaultData();
}

function saveDopeSkateData(data){
  try{
    localStorage.setItem(DOPE_SKATE_DATA_KEY, JSON.stringify(data));
  } catch {}
}

function normalizeDopeSkateData(data){
  const defaults = getDopeSkateDefaultData();
  const out = data && typeof data === 'object' ? data : {};
  out.wallet = typeof out.wallet === 'number' && Number.isFinite(out.wallet) ? out.wallet : defaults.wallet;
  out.owned = out.owned && typeof out.owned === 'object' ? out.owned : {};
  out.equipped = out.equipped && typeof out.equipped === 'object' ? out.equipped : {};
  out.settings = out.settings && typeof out.settings === 'object' ? out.settings : {};
  out.settings.difficulty = ['easy', 'medium', 'hard'].includes(out.settings.difficulty) ? out.settings.difficulty : defaults.settings.difficulty;
  out.settings.sfx = typeof out.settings.sfx === 'boolean' ? out.settings.sfx : defaults.settings.sfx;

  Object.keys(defaults.owned).forEach(cat => {
    if(!Array.isArray(out.owned[cat]) || out.owned[cat].length === 0){
      out.owned[cat] = [...defaults.owned[cat]];
    }
    if(!out.equipped[cat]){
      out.equipped[cat] = defaults.equipped[cat];
    }
    if(!out.owned[cat].includes(out.equipped[cat])){
      out.owned[cat].push(out.equipped[cat]);
    }
  });
  return out;
}

function getDopeSkatePreviewState(){
  if(!state.dopeSkate.preview){
    state.dopeSkate.preview = { active: false, loadout: {}, selectedCategory: null, selectedItemId: null };
  }
  return state.dopeSkate.preview;
}

function dopeSkateClearPreview(){
  const preview = getDopeSkatePreviewState();
  preview.active = false;
  preview.loadout = {};
  preview.selectedCategory = null;
  preview.selectedItemId = null;
}

function dopeSkateSetPreview(category, itemId){
  const preview = getDopeSkatePreviewState();
  preview.active = true;
  preview.selectedCategory = category;
  preview.selectedItemId = itemId;
  preview.loadout = { ...preview.loadout, [category]: itemId };
}

function dopeSkateGetDifficultySettings(){
  const data = dopeSkate.data || getDopeSkateDefaultData();
  const difficulty = data.settings && data.settings.difficulty ? data.settings.difficulty : 'medium';
  return DOPE_SKATE_DIFFICULTY[difficulty] || DOPE_SKATE_DIFFICULTY.medium;
}

function dopeSkateApplySettings(){
  const settings = dopeSkateGetDifficultySettings();
  const difficulty = dopeSkate.data && dopeSkate.data.settings ? dopeSkate.data.settings.difficulty : 'medium';
  dopeSkate.difficulty = difficulty;
  dopeSkate.spawnMultiplier = settings.spawn;
  dopeSkate.scoreMultiplier = settings.score;
}

function dopeSkateIsSfxEnabled(){
  if(!dopeSkate.data || !dopeSkate.data.settings) return true;
  return !!dopeSkate.data.settings.sfx;
}

function isDopeSkateActive(){
  return state.activeWindowId === 'games' && state.games.view === 'dope-skate';
}

function loadDopeSkateAssets(){
  const entries = Object.entries(DOPE_SKATE_ASSETS);
  const promises = entries.map(([key, src]) => new Promise(resolve => {
    const img = new Image();
    img.onload = () => resolve([key, img]);
    img.onerror = () => resolve([key, null]);
    img.src = src;
  }));
  return Promise.all(promises).then(results => {
    const out = {};
    results.forEach(([key, img]) => { out[key] = img; });
    return out;
  });
}

function dopeSkateLoadAssets(){
  if(dopeSkate.assetsReady) return Promise.resolve(dopeSkate.assets);
  if(dopeSkate.assetsLoading) return dopeSkate.assetsLoading;
  dopeSkate.assetsLoading = loadDopeSkateAssets().then(assets => {
    dopeSkate.assets = assets;
    dopeSkate.assetsReady = true;
    dopeSkate.assetsLoading = null;
    dopeSkate.equippedDirty = true;
    dopeSkateDraw();
    dopeSkateRenderShop();
    if(dopeSkate.startQueued){
      dopeSkate.startQueued = false;
      dopeSkateStartRun();
    }
    return assets;
  });
  return dopeSkate.assetsLoading;
}

function fitSkateCanvas(){
  if(!dopeSkate.canvas || !dopeSkate.ctx || !dopeSkate.els) return;
  const wrap = dopeSkate.els.canvasWrap || dopeSkate.canvas.parentElement;
  if(!wrap) return;
  // Measure container only; never drive layout from canvas to avoid resize feedback loops.
  const rect = wrap.getBoundingClientRect();
  const targetW = Math.max(1, Math.floor(rect.width));
  const targetH = Math.max(1, Math.floor(rect.height));
  if(!Number.isFinite(targetW) || !Number.isFinite(targetH)) return;
  if(targetW === 0 || targetH === 0) return;

  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  if(targetW === dopeSkate.renderTargetW && targetH === dopeSkate.renderTargetH && dpr === dopeSkate.renderDpr) return;

  dopeSkate.renderTargetW = targetW;
  dopeSkate.renderTargetH = targetH;
  dopeSkate.renderDpr = dpr;
  dopeSkate.renderScaleX = targetW / dopeSkate.width;
  dopeSkate.renderScaleY = targetH / dopeSkate.height;

  if(dopeSkate.canvas.style.width !== `${targetW}px`) dopeSkate.canvas.style.width = `${targetW}px`;
  if(dopeSkate.canvas.style.height !== `${targetH}px`) dopeSkate.canvas.style.height = `${targetH}px`;

  const internalW = Math.max(1, Math.floor(targetW * dpr));
  const internalH = Math.max(1, Math.floor(targetH * dpr));
  if(dopeSkate.canvas.width !== internalW) dopeSkate.canvas.width = internalW;
  if(dopeSkate.canvas.height !== internalH) dopeSkate.canvas.height = internalH;
  dopeSkate.ctx.imageSmoothingEnabled = false;
}

function dopeSkateIsInteractiveTarget(target){
  if(!target || !target.closest) return false;
  return Boolean(target.closest('[data-skate-action], [data-skate-tab], [data-skate-shop-tab], [data-games-action="back"], .skate-btn, button, a, input, select, textarea'));
}

function initDopeSkateInWindow(winEl){
  const canvas = winEl.querySelector('#skateCanvas');
  const screen = winEl.querySelector('#skateScreen');
  if(!canvas || !screen) return;

  dopeSkate.canvas = canvas;
  dopeSkate.ctx = canvas.getContext('2d');
  dopeSkate.ctx.imageSmoothingEnabled = false;
  dopeSkate.renderTargetW = 0;
  dopeSkate.renderTargetH = 0;
  dopeSkate.renderScaleX = 1;
  dopeSkate.renderScaleY = 1;
  dopeSkate.width = 640;
  dopeSkate.height = 360;
  canvas.width = dopeSkate.width;
  canvas.height = dopeSkate.height;
  dopeSkate.groundHeight = 64;

  dopeSkate.els = {
    screen,
    menuOverlay: winEl.querySelector('#skateMenuOverlay'),
    overOverlay: winEl.querySelector('#skateOverOverlay'),
    canvasWrap: winEl.querySelector('.skate-canvas-wrap'),
    score: winEl.querySelector('[data-skate-score]'),
    best: winEl.querySelector('[data-skate-best]'),
    cds: winEl.querySelector('[data-skate-cds]'),
    combo: winEl.querySelector('[data-skate-combo]'),
    comboList: winEl.querySelector('[data-skate-combo-list]'),
    comboMeter: winEl.querySelector('[data-skate-combo-meter]'),
    overScore: winEl.querySelector('[data-skate-over-score]'),
    overBase: winEl.querySelector('[data-skate-over-base]'),
    overCombo: winEl.querySelector('[data-skate-over-combo]'),
    overBliss: winEl.querySelector('[data-skate-over-bliss]'),
    overCds: winEl.querySelector('[data-skate-over-cds]'),
    overMoney: winEl.querySelector('[data-skate-over-money]'),
    overBest: winEl.querySelector('[data-skate-over-best]'),
    localBest: winEl.querySelector('[data-skate-local-best]'),
    globalBest: winEl.querySelector('[data-skate-global-best]'),
    wallet: winEl.querySelector('[data-skate-wallet]'),
    shopList: winEl.querySelector('[data-skate-shop-list]'),
    previewStage: winEl.querySelector('[data-skate-preview-stage]'),
    previewStatus: winEl.querySelector('[data-skate-preview-status]'),
    previewReset: winEl.querySelector('[data-skate-preview-reset]'),
    equippedList: winEl.querySelector('[data-skate-equipped-list]'),
    balance: winEl.querySelector('#skateBalance'),
    balanceIndicator: winEl.querySelector('[data-skate-balance-indicator]'),
    bliss: winEl.querySelector('[data-skate-bliss]'),
    difficultySelect: winEl.querySelector('[data-skate-setting="difficulty"]'),
    sfxToggle: winEl.querySelector('[data-skate-setting="sfx"]'),
    shopTabs: Array.from(winEl.querySelectorAll('[data-skate-shop-tab]')),
    backBtn: winEl.querySelector('[data-games-action="back"]'),
    tabs: Array.from(winEl.querySelectorAll('[data-skate-tab]')),
    actionButtons: Array.from(winEl.querySelectorAll('[data-skate-action]')),
    resumeButtons: Array.from(winEl.querySelectorAll('[data-skate-action="resume"]')),
  };

  if(typeof state.dopeSkate.highScore !== 'number' || Number.isNaN(state.dopeSkate.highScore)){
    state.dopeSkate.highScore = loadDopeSkateHighScore();
  }
  if(!dopeSkate.data){
    dopeSkate.data = loadDopeSkateData();
    saveDopeSkateData(dopeSkate.data);
  }
  dopeSkate.equippedDirty = true;
  dopeSkate.preview = getDopeSkatePreviewState();
  dopeSkateApplySettings();

  if(dopeSkate.els.backBtn){
    dopeSkate.els.backBtn.addEventListener('click', (e)=>{
      e.preventDefault();
      backToGamesHub();
    });
  }

  dopeSkate.els.tabs.forEach(btn => {
    btn.addEventListener('click', ()=>{
      dopeSkateSetPanel(btn.dataset.skateTab || 'play');
    });
  });
  dopeSkate.els.shopTabs.forEach(btn => {
    btn.addEventListener('click', ()=>{
      dopeSkateSetShopCategory(btn.dataset.skateShopTab || 'skater');
    });
  });

  dopeSkate.els.actionButtons.forEach(btn => {
    btn.addEventListener('click', (e)=>{
      const action = btn.dataset.skateAction;
      if(action === 'start'){
        dopeSkateStartRun();
      } else if(action === 'retry'){
        dopeSkateStartRun();
      } else if(action === 'menu'){
        dopeSkateShowMenu('play');
      } else if(action === 'resume'){
        dopeSkateHideMenu();
      } else if(action === 'revert-preview'){
        dopeSkateClearPreview();
        dopeSkateRenderShop();
      } else if(action === 'jump'){
        dopeSkateRegisterJump();
      } else if(action === 'trick1'){
        dopeSkateRegisterTrick('trick1');
      } else if(action === 'trick2'){
        dopeSkateRegisterTrick('trick2');
      } else if(action === 'trick3'){
        dopeSkateRegisterTrick('trick3');
      }
    });
  });

  if(dopeSkate.els.difficultySelect){
    dopeSkate.els.difficultySelect.addEventListener('change', ()=>{
      if(!dopeSkate.data) return;
      dopeSkate.data.settings = dopeSkate.data.settings || {};
      dopeSkate.data.settings.difficulty = dopeSkate.els.difficultySelect.value;
      saveDopeSkateData(dopeSkate.data);
      dopeSkateApplySettings();
    });
  }
  if(dopeSkate.els.sfxToggle){
    dopeSkate.els.sfxToggle.addEventListener('click', ()=>{
      if(!dopeSkate.data) return;
      dopeSkate.data.settings = dopeSkate.data.settings || {};
      dopeSkate.data.settings.sfx = !dopeSkate.data.settings.sfx;
      dopeSkate.els.sfxToggle.dataset.enabled = dopeSkate.data.settings.sfx ? '1' : '0';
      dopeSkate.els.sfxToggle.textContent = dopeSkate.data.settings.sfx ? t('skate.settings.sfxOn') : t('skate.settings.sfxOff');
      saveDopeSkateData(dopeSkate.data);
    });
  }

  screen.addEventListener('touchstart', (e)=>{ if(!dopeSkateIsInteractiveTarget(e.target)) e.preventDefault(); }, { passive:false });
  screen.addEventListener('touchmove', (e)=>{ if(!dopeSkateIsInteractiveTarget(e.target)) e.preventDefault(); }, { passive:false });
  canvas.addEventListener('touchstart', (e)=>{ if(!dopeSkateIsInteractiveTarget(e.target)) e.preventDefault(); }, { passive:false });
  canvas.addEventListener('touchmove', (e)=>{ if(!dopeSkateIsInteractiveTarget(e.target)) e.preventDefault(); }, { passive:false });
  screen.addEventListener('pointerdown', (e)=>{
    if(e.pointerType === 'mouse') return;
    if(dopeSkateIsInteractiveTarget(e.target)) return;
    if(!dopeSkate.running || dopeSkate.gameOver) return;
    dopeSkateRegisterJump();
    e.preventDefault();
  }, { passive:false });

  if(!dopeSkate.assets){
    dopeSkateLoadAssets();
  } else {
    dopeSkate.assetsReady = true;
  }

  if(dopeSkate.resizeObserver){
    dopeSkate.resizeObserver.disconnect();
    dopeSkate.resizeObserver = null;
  }
  if(window.ResizeObserver){
    dopeSkate.resizeObserver = new ResizeObserver(()=>{
      if(dopeSkate.resizeRaf) return;
      dopeSkate.resizeRaf = requestAnimationFrame(()=>{
        dopeSkate.resizeRaf = null;
        fitSkateCanvas();
      });
    });
    if(dopeSkate.els.canvasWrap) dopeSkate.resizeObserver.observe(dopeSkate.els.canvasWrap);
  }
  fitSkateCanvas();
  if(!dopeSkate.resizeHandler){
    dopeSkate.resizeHandler = ()=>{
      if(dopeSkate.resizeRaf) return;
      dopeSkate.resizeRaf = requestAnimationFrame(()=>{
        dopeSkate.resizeRaf = null;
        fitSkateCanvas();
      });
    };
    window.addEventListener('resize', dopeSkate.resizeHandler);
    window.addEventListener('orientationchange', dopeSkate.resizeHandler);
    if(window.visualViewport){
      window.visualViewport.addEventListener('resize', dopeSkate.resizeHandler);
    }
  }

  dopeSkateResetWorld();
  dopeSkateShowMenu('play');
  updateDopeSkateUI();
  dopeSkateSetShopCategory(dopeSkate.shopCategory);
  dopeSkateRenderShop();
  dopeSkateStartLoop();
}

function dopeSkateResetWorld(){
  const groundY = dopeSkate.height - dopeSkate.groundHeight;
  dopeSkateApplySettings();
  const diff = dopeSkateGetDifficultySettings();
  dopeSkate.player = {
    x: 130,
    y: groundY - 58,
    w: 40,
    h: 58,
    vy: 0,
    onGround: true,
    mode: 'ground',
    wheelAngle: 0,
    boardAngle: 0,
    boardSpin: 0,
    bodyLean: 0,
    bodyBob: 0,
    squash: 0,
    trickAnim: null,
  };
  dopeSkate.obstacles = [];
  dopeSkate.rails = [];
  dopeSkate.collectibles = [];
  dopeSkate.particles = [];
  dopeSkate.spawn = {
    nextObstacleDist: 260,
    nextRailDist: 720,
    nextCdDist: 220,
    nextLetterDist: 880,
  };
  dopeSkate.lastObstacleDist = 0;
  dopeSkate.lastRailDist = 0;
  dopeSkate.lastObstacleLane = 0;
  // Difficulty tuning: speed/spawn/score multipliers live in DOPE_SKATE_DIFFICULTY.
  dopeSkate.speed = 240 * diff.speed;
  dopeSkate.maxSpeed = 420 * diff.speed;
  dopeSkate.scoreBase = 0;
  dopeSkate.comboBank = 0;
  dopeSkate.scoreTotal = 0;
  dopeSkate.blissBonus = 0;
  dopeSkate.distance = 0;
  dopeSkate.cds = 0;
  dopeSkate.blissCounts = { B: 0, L: 0, I: 0, S: 0 };
  dopeSkate.combo = {
    points: 0,
    tricks: [],
    unique: new Set(),
    multiplier: 1,
    active: false,
  };
  dopeSkate.gameOver = false;
  dopeSkate.running = false;
  dopeSkate.paused = false;
  dopeSkate.started = false;
  dopeSkate.offsets = { sky: 0, city: 0, ground: 0 };
  dopeSkate.jumpBufferUntil = 0;
  dopeSkate.lastGroundedAt = 0;
  dopeSkate.lastTrickAt = 0;
  dopeSkate.lastTrickId = null;
  dopeSkate.cameraShake = 0;
  dopeSkate.lastComboHtml = '';
  dopeSkate.lastBlissKey = '';
  dopeSkate.time = 0;
}

function dopeSkateStartRun(){
  if(!dopeSkate.assetsReady){
    dopeSkate.startQueued = true;
    dopeSkateLoadAssets();
    return;
  }
  dopeSkateClearPreview();
  dopeSkateResetWorld();
  dopeSkate.running = true;
  dopeSkate.paused = false;
  dopeSkate.started = true;
  dopeSkateUnlockAudio();
  recordGameScore('dopeSkate', state.dopeSkate.highScore || 0, new Date().toISOString());
  if(dopeSkate.els && dopeSkate.els.menuOverlay){
    dopeSkate.els.menuOverlay.classList.add('hidden');
  }
  if(dopeSkate.els && dopeSkate.els.overOverlay){
    dopeSkate.els.overOverlay.classList.add('hidden');
  }
  updateDopeSkateUI();
}

function dopeSkateShowMenu(panel){
  dopeSkate.paused = dopeSkate.started && !dopeSkate.gameOver;
  dopeSkate.running = dopeSkate.started && !dopeSkate.gameOver;
  if(dopeSkate.els && dopeSkate.els.menuOverlay){
    dopeSkate.els.menuOverlay.classList.remove('hidden');
  }
  if(dopeSkate.els && dopeSkate.els.overOverlay){
    dopeSkate.els.overOverlay.classList.add('hidden');
  }
  dopeSkateSetPanel(panel);
}

function dopeSkateHideMenu(){
  if(!dopeSkate.started || dopeSkate.gameOver) return;
  dopeSkateClearPreview();
  dopeSkate.paused = false;
  dopeSkate.running = true;
  if(dopeSkate.els && dopeSkate.els.menuOverlay){
    dopeSkate.els.menuOverlay.classList.add('hidden');
  }
}

function dopeSkateSetPanel(panel){
  if(!dopeSkate.els) return;
  dopeSkate.els.tabs.forEach(btn => {
    const active = btn.dataset.skateTab === panel;
    btn.classList.toggle('active', active);
  });
  const panels = Array.from(dopeSkate.els.menuOverlay.querySelectorAll('[data-skate-panel]'));
  panels.forEach(p => p.classList.toggle('active', p.dataset.skatePanel === panel));
  if(panel === 'shop'){
    dopeSkateRenderShop();
  } else {
    dopeSkateClearPreview();
  }
}

function dopeSkateSetShopCategory(category){
  dopeSkate.shopCategory = category;
  if(dopeSkate.els && dopeSkate.els.shopTabs){
    dopeSkate.els.shopTabs.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.skateShopTab === category);
    });
  }
  dopeSkateRenderShop();
}

function dopeSkateRegisterJump(){
  if(!dopeSkate.running || dopeSkate.paused || dopeSkate.gameOver) return;
  dopeSkate.jumpBufferUntil = dopeSkate.time + 0.12;
  dopeSkateUnlockAudio();
  dopeSkatePlaySound('jump');
}

function dopeSkateTryJump(){
  const player = dopeSkate.player;
  const coyoteOk = (dopeSkate.time - dopeSkate.lastGroundedAt) <= 0.12;
  if(dopeSkate.jumpBufferUntil > dopeSkate.time && player.mode === 'grind'){
    dopeSkate.jumpBufferUntil = 0;
    player.mode = 'air';
    player.grind = null;
    player.vy = dopeSkate.jumpVel * 0.85;
    dopeSkateAddTrickById('ollie');
    return;
  }
  if(dopeSkate.jumpBufferUntil > dopeSkate.time && (player.onGround || coyoteOk)){
    dopeSkate.jumpBufferUntil = 0;
    player.vy = dopeSkate.jumpVel;
    player.onGround = false;
    player.mode = 'air';
    player.squash = 0.25;
    dopeSkateAddTrickById('ollie');
  }
}

function dopeSkateRegisterTrick(slot){
  if(!dopeSkate.running || dopeSkate.paused || dopeSkate.gameOver) return;
  dopeSkateUnlockAudio();
  dopeSkateHandleTrick(slot);
}

function dopeSkateStartLoop(){
  dopeSkateStopLoop();
  dopeSkate.lastTime = 0;
  dopeSkate.raf = requestAnimationFrame(dopeSkateLoop);
}

function dopeSkateStopLoop(){
  if(dopeSkate.raf){
    cancelAnimationFrame(dopeSkate.raf);
    dopeSkate.raf = null;
  }
}

function dopeSkateStop(){
  dopeSkateStopLoop();
  dopeSkate.running = false;
  dopeSkate.paused = false;
  dopeSkate.gameOver = false;
  dopeSkate.started = false;
  if(dopeSkate.resizeObserver){
    dopeSkate.resizeObserver.disconnect();
    dopeSkate.resizeObserver = null;
  }
  if(dopeSkate.resizeHandler){
    window.removeEventListener('resize', dopeSkate.resizeHandler);
    window.removeEventListener('orientationchange', dopeSkate.resizeHandler);
    if(window.visualViewport){
      window.visualViewport.removeEventListener('resize', dopeSkate.resizeHandler);
    }
    dopeSkate.resizeHandler = null;
  }
  dopeSkate.els = null;
  dopeSkate.canvas = null;
  dopeSkate.ctx = null;
}

const DopeSkateGame = {
  mount: initDopeSkateInWindow,
  unmount: dopeSkateStop,
};

function dopeSkateLoop(ts){
  if(!dopeSkate.ctx) return;
  const dt = dopeSkate.lastTime ? Math.min(0.05, (ts - dopeSkate.lastTime) / 1000) : 0;
  dopeSkate.lastTime = ts;
  if(dopeSkate.running && !dopeSkate.paused && !dopeSkate.gameOver){
    dopeSkateUpdate(dt);
  }
  dopeSkateDraw();
  dopeSkate.raf = requestAnimationFrame(dopeSkateLoop);
}

function dopeSkateUpdate(dt){
  const groundY = dopeSkate.height - dopeSkate.groundHeight;
  const player = dopeSkate.player;
  dopeSkate.time += dt;
  const wasOnGround = player.onGround;

  if(player.mode === 'grind'){
    dopeSkateUpdateGrind(dt);
  } else {
    player.vy += dopeSkate.gravity * dt;
    player.y += player.vy * dt;
  }
  if(player.y >= groundY - player.h){
    player.y = groundY - player.h;
    if(!player.onGround && player.mode !== 'grind'){
      dopeSkatePlaySound('land');
    }
    player.vy = 0;
    player.onGround = true;
    player.mode = 'ground';
    dopeSkate.lastGroundedAt = dopeSkate.time;
    if(!wasOnGround){
      player.squash = 0.35;
    }
  } else if(player.mode !== 'grind'){
    player.onGround = false;
  }

  if(!wasOnGround && player.onGround){
    dopeSkateResolveCombo();
  }

  dopeSkateTryJump();
  if(dopeSkate.combo.active && player.mode === 'air' && (dopeSkate.time - dopeSkate.lastTrickAt) > dopeSkate.comboWindow){
    dopeSkateResolveCombo();
  }

  dopeSkate.speed = Math.min(dopeSkate.maxSpeed, dopeSkate.speed + dopeSkate.accel * dt);
  dopeSkate.distance += dopeSkate.speed * dt;
  dopeSkate.scoreBase = Math.max(dopeSkate.scoreBase, Math.floor((dopeSkate.distance / 7) * dopeSkate.scoreMultiplier));
  dopeSkate.scoreTotal = dopeSkate.scoreBase + dopeSkate.comboBank;

  dopeSkateHandleSpawns();

  dopeSkate.obstacles.forEach(ob => { ob.x -= dopeSkate.speed * dt; });
  dopeSkate.obstacles = dopeSkate.obstacles.filter(ob => ob.x + ob.w > -80);
  dopeSkate.rails.forEach(rail => { rail.x -= dopeSkate.speed * dt; });
  dopeSkate.rails = dopeSkate.rails.filter(rail => rail.x + rail.w > -120);
  dopeSkate.collectibles.forEach(item => { item.x -= dopeSkate.speed * dt; });
  dopeSkate.collectibles = dopeSkate.collectibles.filter(item => item.x + item.w > -80);

  dopeSkateCheckCollisions();
  dopeSkateUpdateParticles(dt);
  dopeSkateUpdateAnimations(dt);
  dopeSkate.cameraShake = Math.max(0, dopeSkate.cameraShake - dt * 20);

  dopeSkateUpdateOffsets(dt);
  dopeSkateCheckGamepad();
  updateDopeSkateUI();
}

function dopeSkateUpdateOffsets(dt){
  const assets = dopeSkate.assets || {};
  const skyW = assets.sky ? assets.sky.width : dopeSkate.width;
  const cityW = assets.city ? assets.city.width : dopeSkate.width;
  const groundW = assets.ground ? assets.ground.width : dopeSkate.width;
  dopeSkate.offsets.sky = (dopeSkate.offsets.sky + dopeSkate.speed * dt * 0.15) % skyW;
  dopeSkate.offsets.city = (dopeSkate.offsets.city + dopeSkate.speed * dt * 0.35) % cityW;
  dopeSkate.offsets.ground = (dopeSkate.offsets.ground + dopeSkate.speed * dt * 1.0) % groundW;
}

function dopeSkateHandleSpawns(){
  if(dopeSkate.distance >= dopeSkate.spawn.nextObstacleDist){
    dopeSkateSpawnObstacle();
    dopeSkate.spawn.nextObstacleDist += dopeSkateGetObstacleGap();
  }
  if(dopeSkate.distance >= dopeSkate.spawn.nextRailDist){
    const safeGap = dopeSkate.distance - dopeSkate.lastObstacleDist > 320;
    if(safeGap){
      dopeSkateSpawnRail();
      dopeSkate.spawn.nextRailDist += 680 + Math.random() * 560;
    } else {
      dopeSkate.spawn.nextRailDist += 180;
    }
  }
  if(dopeSkate.distance >= dopeSkate.spawn.nextCdDist){
    dopeSkateSpawnCollectible('cd');
    dopeSkate.spawn.nextCdDist += 220 + Math.random() * 220;
  }
  if(dopeSkate.distance >= dopeSkate.spawn.nextLetterDist){
    dopeSkateSpawnCollectible('bliss');
    dopeSkate.spawn.nextLetterDist += 820 + Math.random() * 620;
  }
}

function dopeSkateGetObstacleGap(){
  const jumpTime = Math.abs(dopeSkate.jumpVel) / dopeSkate.gravity * 2;
  const baseGap = Math.max(200, dopeSkate.speed * (jumpTime * 0.8 + 0.2));
  const difficulty = Math.min(1, (dopeSkate.speed - 240) / 180);
  const minGap = Math.max(180, baseGap * (0.92 - difficulty * 0.2));
  return (minGap + Math.random() * (200 - difficulty * 60)) * dopeSkate.spawnMultiplier;
}

function dopeSkateSpawnObstacle(){
  const groundY = dopeSkate.height - dopeSkate.groundHeight;
  const types = [
    { key: 'vodka', w: 24, h: 50 },
    { key: 'trash', w: 36, h: 34 },
    { key: 'cone', w: 28, h: 40 },
  ];
  const pick = types[Math.floor(Math.random() * types.length)];
  const lanes = [0, -6];
  const lane = lanes[Math.floor(Math.random() * lanes.length)];
  dopeSkate.lastObstacleLane = lane;
  dopeSkate.obstacles.push({
    type: pick.key,
    w: pick.w,
    h: pick.h,
    x: dopeSkate.width + 40,
    y: groundY - pick.h + lane,
  });
  dopeSkate.lastObstacleDist = dopeSkate.distance;
}

function dopeSkateSpawnRail(){
  const groundY = dopeSkate.height - dopeSkate.groundHeight;
  dopeSkate.rails.push({
    w: 140,
    h: 12,
    x: dopeSkate.width + 120,
    y: groundY - 90,
  });
  dopeSkate.lastRailDist = dopeSkate.distance;
}

function dopeSkateSpawnCollectible(type){
  const groundY = dopeSkate.height - dopeSkate.groundHeight;
  const lanes = [groundY - 120, groundY - 90, groundY - 60];
  const laneY = lanes[Math.floor(Math.random() * lanes.length)];
  if(type === 'cd'){
    dopeSkate.collectibles.push({
      type: 'cd',
      w: 22,
      h: 22,
      x: dopeSkate.width + 60,
      y: laneY,
    });
    return;
  }
  const letter = dopeSkatePickBlissLetter();
  if(!letter) return;
  dopeSkate.collectibles.push({
    type: 'bliss',
    letter,
    w: 24,
    h: 24,
    x: dopeSkate.width + 60,
    y: groundY - 140,
  });
}

function dopeSkateGameOver(){
  dopeSkate.running = false;
  dopeSkate.paused = false;
  dopeSkate.gameOver = true;
  dopeSkateFinalizeScore();
  updateDopeSkateUI();
  if(dopeSkate.els && dopeSkate.els.overOverlay){
    dopeSkate.els.overOverlay.classList.remove('hidden');
  }
}

function dopeSkateDraw(){
  if(!dopeSkate.ctx) return;
  const ctx = dopeSkate.ctx;
  const w = dopeSkate.width;
  const h = dopeSkate.height;
  const groundY = h - dopeSkate.groundHeight;
  const dpr = dopeSkate.renderDpr || 1;
  const scaleX = dopeSkate.renderScaleX || 1;
  const scaleY = dopeSkate.renderScaleY || 1;

  ctx.setTransform(dpr * scaleX, 0, 0, dpr * scaleY, 0, 0);
  ctx.clearRect(0, 0, w, h);
  ctx.save();
  if(dopeSkate.cameraShake > 0){
    const shake = dopeSkate.cameraShake;
    ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
  }
  const equipped = dopeSkateGetEquippedAssets();
  dopeSkateDrawLayer(equipped.sky, dopeSkate.offsets.sky, 0, h);
  dopeSkateDrawLayer(equipped.background, dopeSkate.offsets.city, 40, h - 80);
  dopeSkateDrawLayer(equipped.ground, dopeSkate.offsets.ground, groundY, dopeSkate.groundHeight);

  if(!dopeSkate.assetsReady){
    ctx.fillStyle = '#2b2b2b';
    ctx.fillRect(0, groundY, w, dopeSkate.groundHeight);
  }

  dopeSkate.obstacles.forEach(ob => {
    const img = dopeSkate.assets ? dopeSkate.assets[ob.type] : null;
    if(img){
      ctx.drawImage(img, ob.x, ob.y, ob.w, ob.h);
    } else {
      ctx.fillStyle = '#b54f2a';
      ctx.fillRect(ob.x, ob.y, ob.w, ob.h);
    }
  });

  dopeSkate.rails.forEach(rail => {
    const img = dopeSkate.assets ? dopeSkate.assets.rail : null;
    if(img){
      ctx.drawImage(img, rail.x, rail.y, rail.w, rail.h);
    } else {
      ctx.fillStyle = '#b0b0b0';
      ctx.fillRect(rail.x, rail.y, rail.w, rail.h);
    }
  });

  dopeSkate.collectibles.forEach(item => {
    if(item.type === 'cd'){
      const img = dopeSkate.assets ? dopeSkate.assets.cd : null;
      if(img){
        ctx.drawImage(img, item.x, item.y, item.w, item.h);
      } else {
        ctx.fillStyle = '#cfd8e3';
        ctx.fillRect(item.x, item.y, item.w, item.h);
      }
      return;
    }
    const img = dopeSkate.assets ? dopeSkate.assets.bliss : null;
    if(img){
      ctx.drawImage(img, item.x, item.y, item.w, item.h);
      ctx.fillStyle = '#5b3a00';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.letter, item.x + item.w / 2, item.y + item.h / 2 + 2);
    } else {
      ctx.fillStyle = '#ffe36e';
      ctx.fillRect(item.x, item.y, item.w, item.h);
      ctx.fillStyle = '#5b3a00';
      ctx.textBaseline = 'middle';
      ctx.fillText(item.letter, item.x + item.w / 2, item.y + item.h / 2 + 2);
    }
  });

  dopeSkateDrawParticles();
  dopeSkateDrawSkater();
  ctx.restore();
}

function dopeSkateDrawLayer(img, offset, y, height){
  const ctx = dopeSkate.ctx;
  const w = dopeSkate.width;
  if(!img){
    ctx.fillStyle = '#6aa6d9';
    ctx.fillRect(0, y, w, height);
    return;
  }
  const tileW = img.width;
  let x = -offset;
  while(x < w){
    ctx.drawImage(img, x, y, tileW, height);
    x += tileW;
  }
}

function dopeSkateDrawSkater(){
  const ctx = dopeSkate.ctx;
  const p = dopeSkate.player;
  if(!p) return;
  const equipped = dopeSkateGetEquippedAssets();
  const body = equipped.skater;
  const hat = equipped.hat;
  const board = equipped.board;
  const wheels = equipped.wheels;

  const bodyW = 44;
  const bodyH = 58;
  const boardW = 60;
  const boardH = 12;
  const wheelW = 12;
  const wheelH = 12;

  const boardX = p.x + bodyW / 2 - boardW / 2;
  const boardY = p.y + bodyH - 12;
  const boardCx = boardX + boardW / 2;
  const boardCy = boardY + boardH / 2;
  const boardAngle = p.boardSpin + p.boardAngle;

  ctx.save();
  ctx.translate(boardCx, boardCy);
  ctx.rotate(boardAngle);
  const wheelSpriteCount = wheels && wheels.width >= wheels.height * 2 ? 2 : 1;
  const wheelSrcW = wheels ? wheels.width / wheelSpriteCount : wheelW;
  const wheelSrcH = wheels ? wheels.height : wheelH;
  const wheelInset = boardW * 0.28;
  const wheelOffsetY = boardH / 2 + 2;
  const wheelPositions = [
    { x: -boardW / 2 + wheelInset, srcX: 0 },
    { x: boardW / 2 - wheelInset, srcX: wheelSpriteCount === 2 ? wheelSrcW : 0 },
  ];
  wheelPositions.forEach(pos => {
    ctx.save();
    ctx.translate(pos.x, wheelOffsetY);
    ctx.rotate(p.wheelAngle);
    if(wheels){
      ctx.drawImage(wheels, pos.srcX, 0, wheelSrcW, wheelSrcH, -wheelW / 2, -wheelH / 2, wheelW, wheelH);
    } else {
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.ellipse(0, 0, wheelW / 2, wheelH / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  });
  if(board){
    ctx.drawImage(board, -boardW / 2, -boardH / 2, boardW, boardH);
  } else {
    ctx.fillStyle = '#c28b2f';
    ctx.fillRect(-boardW / 2, -boardH / 2, boardW, boardH);
  }
  ctx.restore();

  if(body){
    ctx.save();
    ctx.translate(p.x + bodyW / 2, p.y + bodyH / 2 + (p.bodyBob || 0));
    ctx.rotate(p.bodyLean);
    const squash = 1 - p.squash * 0.3;
    ctx.scale(1 + p.squash * 0.2, squash);
    ctx.drawImage(body, -bodyW / 2, -bodyH / 2, bodyW, bodyH);
    if(hat){
      const headX = 0;
      const headY = -bodyH / 2 + 10;
      ctx.save();
      ctx.translate(headX, headY);
      ctx.drawImage(hat, -14, -12, 32, 18);
      ctx.restore();
    }
    ctx.restore();
  } else {
    ctx.fillStyle = '#2f6b9a';
    ctx.fillRect(p.x, p.y + 12, bodyW, bodyH - 12);
    ctx.fillStyle = '#f2c6a0';
    ctx.fillRect(p.x + 12, p.y, 18, 18);
  }
}

function dopeSkateCheckGamepad(){
  const pads = navigator.getGamepads ? navigator.getGamepads() : [];
  if(!pads) return;
  for(const pad of pads){
    if(!pad) continue;
    const jumpPressed = pad.buttons && pad.buttons[0] && pad.buttons[0].pressed;
    const trick1Pressed = pad.buttons && pad.buttons[2] && pad.buttons[2].pressed;
    const trick2Pressed = pad.buttons && pad.buttons[3] && pad.buttons[3].pressed;
    const trick3Pressed = pad.buttons && pad.buttons[1] && pad.buttons[1].pressed;

    if(jumpPressed && !dopeSkate.gamepad.jump){
      dopeSkateRegisterJump();
    }
    if(trick1Pressed && !dopeSkate.gamepad.trick1){
      dopeSkateRegisterTrick('trick1');
    }
    if(trick2Pressed && !dopeSkate.gamepad.trick2){
      dopeSkateRegisterTrick('trick2');
    }
    if(trick3Pressed && !dopeSkate.gamepad.trick3){
      dopeSkateRegisterTrick('trick3');
    }
    dopeSkate.gamepad.jump = jumpPressed;
    dopeSkate.gamepad.trick1 = trick1Pressed;
    dopeSkate.gamepad.trick2 = trick2Pressed;
    dopeSkate.gamepad.trick3 = trick3Pressed;

    if(pad.axes && pad.axes.length){
      dopeSkate.inputs.left = pad.axes[0] < -0.4;
      dopeSkate.inputs.right = pad.axes[0] > 0.4;
    }
  }
}

function updateDopeSkateUI(){
  if(!dopeSkate.els) return;
  if(dopeSkate.els.score) dopeSkate.els.score.textContent = String(dopeSkate.scoreTotal);
  if(dopeSkate.els.combo) dopeSkate.els.combo.textContent = `${dopeSkate.combo.multiplier}x`;
  if(dopeSkate.els.cds) dopeSkate.els.cds.textContent = String(dopeSkate.cds);
  if(dopeSkate.els.best) dopeSkate.els.best.textContent = String(state.dopeSkate.highScore || 0);
  if(dopeSkate.els.localBest) dopeSkate.els.localBest.textContent = String(state.dopeSkate.highScore || 0);
  if(dopeSkate.els.overScore) dopeSkate.els.overScore.textContent = String(dopeSkate.scoreTotal);
  if(dopeSkate.els.overBase) dopeSkate.els.overBase.textContent = String(dopeSkate.scoreBase || 0);
  if(dopeSkate.els.overCombo) dopeSkate.els.overCombo.textContent = String(dopeSkate.comboBank || 0);
  if(dopeSkate.els.overBliss) dopeSkate.els.overBliss.textContent = String(dopeSkate.blissBonus || 0);
  if(dopeSkate.els.overCds) dopeSkate.els.overCds.textContent = String(dopeSkate.cds);
  if(dopeSkate.els.overMoney) dopeSkate.els.overMoney.textContent = String(dopeSkate.cds);
  if(dopeSkate.els.overBest) dopeSkate.els.overBest.textContent = String(state.dopeSkate.highScore || 0);
  if(dopeSkate.els.wallet && dopeSkate.data) dopeSkate.els.wallet.textContent = `CD ${dopeSkate.data.wallet || 0}`;
  if(dopeSkate.els.globalBest) dopeSkate.els.globalBest.textContent = '';
  if(dopeSkate.els.difficultySelect && dopeSkate.data && dopeSkate.data.settings){
    dopeSkate.els.difficultySelect.value = dopeSkate.data.settings.difficulty || 'medium';
  }
  if(dopeSkate.els.sfxToggle && dopeSkate.data && dopeSkate.data.settings){
    const enabled = !!dopeSkate.data.settings.sfx;
    dopeSkate.els.sfxToggle.dataset.enabled = enabled ? '1' : '0';
    dopeSkate.els.sfxToggle.textContent = enabled ? t('skate.settings.sfxOn') : t('skate.settings.sfxOff');
  }
  if(dopeSkate.els.resumeButtons){
    const showResume = dopeSkate.started && !dopeSkate.gameOver;
    dopeSkate.els.resumeButtons.forEach(btn => btn.classList.toggle('hidden', !showResume));
  }
  if(dopeSkate.els.comboMeter){
    const elapsed = Math.max(0, dopeSkate.time - dopeSkate.lastTrickAt);
    const ratio = dopeSkate.combo.active ? Math.max(0, 1 - elapsed / dopeSkate.comboWindow) : 0;
    dopeSkate.els.comboMeter.style.width = `${Math.floor(ratio * 100)}%`;
  }
  dopeSkateRenderComboList();
  dopeSkateRenderBlissHUD();
  dopeSkateUpdateBalanceUI();
}

function dopeSkateHandleKey(e){
  if(!isDopeSkateActive()) return false;
  const tag = e.target && e.target.tagName;
  if(tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return false;

  const key = e.key.toLowerCase();
  let handled = true;
  if(key === 'escape'){
    dopeSkateShowMenu('play');
  } else if(key === 'arrowleft' || key === 'a'){
    dopeSkate.inputs.left = true;
  } else if(key === 'arrowright' || key === 'd'){
    dopeSkate.inputs.right = true;
  } else if(key === 'arrowup' || key === 'w' || key === ' ' || key === 'spacebar'){
    dopeSkateRegisterJump();
  } else if(key === 'z'){
    dopeSkateRegisterTrick('trick1');
  } else if(key === 'x'){
    dopeSkateRegisterTrick('trick2');
  } else if(key === 'c'){
    dopeSkateRegisterTrick('trick3');
  } else if(key === 'enter' && !dopeSkate.running && !dopeSkate.gameOver){
    dopeSkateStartRun();
  } else {
    handled = false;
  }

  if(handled){
    e.preventDefault();
  }
  return handled;
}

function dopeSkateHandleKeyUp(e){
  if(!isDopeSkateActive()) return false;
  const key = e.key.toLowerCase();
  if(key === 'arrowleft' || key === 'a'){
    dopeSkate.inputs.left = false;
    e.preventDefault();
    return true;
  }
  if(key === 'arrowright' || key === 'd'){
    dopeSkate.inputs.right = false;
    e.preventDefault();
    return true;
  }
  return false;
}

function dopeSkateHandleTrick(slot){
  const player = dopeSkate.player;
  if(!player || (player.mode !== 'air' && player.mode !== 'grind')) return;
  const trick = dopeSkatePickTrick(slot);
  if(!trick) return;
  if(dopeSkate.time - dopeSkate.lastTrickAt < 0.14 && dopeSkate.lastTrickId !== 'ollie') return;
  dopeSkate.lastTrickAt = dopeSkate.time;
  dopeSkate.lastTrickId = trick.id;
  dopeSkate.combo.active = true;
  dopeSkate.combo.points += trick.points;
  dopeSkate.combo.tricks.push(trick.name);
  dopeSkate.combo.unique.add(trick.id);
  dopeSkate.combo.multiplier = Math.max(1, dopeSkate.combo.unique.size);
  dopeSkateStartTrickAnim(trick.id);
  dopeSkateSpawnTrickText(trick.name);
  dopeSkate.cameraShake = Math.max(dopeSkate.cameraShake, 4);
  dopeSkatePlaySound('trick');
}

function dopeSkateStartTrickAnim(trickId){
  const player = dopeSkate.player;
  if(!player) return;
  const durationMap = {
    ollie: 0.3,
    kickflip: 0.45,
    heelflip: 0.45,
    shuvit: 0.4,
    hardflip: 0.5,
    varial: 0.5,
  };
  player.trickAnim = {
    id: trickId,
    t: 0,
    duration: durationMap[trickId] || 0.4,
  };
}

function dopeSkateUpdateAnimations(dt){
  const player = dopeSkate.player;
  if(!player) return;
  player.wheelAngle += dopeSkate.speed * dt * 0.08;
  player.squash = Math.max(0, player.squash - dt * 2.8);
  const leanFromVel = Math.max(-0.12, Math.min(0.12, -player.vy / 900));
  const grindLean = player.mode === 'grind' && player.grind ? (player.grind.balance - 0.5) * 0.35 : 0;
  player.bodyLean = leanFromVel + grindLean;
  player.bodyBob = player.mode === 'ground' ? Math.sin(dopeSkate.time * 10) * 1.2 : Math.sin(dopeSkate.time * 6) * 0.6;

  if(player.trickAnim){
    player.trickAnim.t += dt;
    const progress = Math.min(1, player.trickAnim.t / player.trickAnim.duration);
    const swing = Math.sin(progress * Math.PI);
    player.boardSpin = 0;
    player.boardAngle = 0;
    switch(player.trickAnim.id){
      case 'kickflip':
        player.boardAngle = swing * Math.PI;
        break;
      case 'heelflip':
        player.boardAngle = -swing * Math.PI;
        break;
      case 'shuvit':
        player.boardSpin = progress * Math.PI * 2;
        player.boardAngle = swing * 0.3;
        break;
      case 'hardflip':
        player.boardSpin = progress * Math.PI * 2;
        player.boardAngle = swing * Math.PI;
        break;
      case 'varial':
        player.boardSpin = progress * Math.PI * 1.5;
        player.boardAngle = swing * Math.PI;
        break;
      case 'ollie':
      default:
        player.boardAngle = -swing * 0.35;
        break;
    }
    if(progress >= 1){
      player.trickAnim = null;
    }
  } else {
    player.boardAngle *= 0.92;
    player.boardSpin *= 0.92;
  }
  if(player.mode === 'grind'){
    player.boardAngle = (player.grind.balance - 0.5) * 0.4;
  }
}

function dopeSkateSpawnTrickText(text){
  if(dopeSkate.particles.length > 120) return;
  const player = dopeSkate.player;
  const x = player ? player.x + 30 : 160;
  const y = player ? player.y - 8 : 140;
  dopeSkate.particles.push({
    type: 'text',
    text,
    x,
    y,
    vx: -10 + Math.random() * 20,
    vy: -40 - Math.random() * 30,
    life: 0.8,
  });
}

function dopeSkatePickTrick(slot){
  const left = dopeSkate.inputs.left;
  const right = dopeSkate.inputs.right;
  if(slot === 'trick1'){
    if(left || right) return DOPE_SKATE_TRICKS.find(t => t.id === 'heelflip');
    return DOPE_SKATE_TRICKS.find(t => t.id === 'kickflip');
  }
  if(slot === 'trick2'){
    if(left || right) return DOPE_SKATE_TRICKS.find(t => t.id === 'varial');
    return DOPE_SKATE_TRICKS.find(t => t.id === 'shuvit');
  }
  if(slot === 'trick3'){
    return DOPE_SKATE_TRICKS.find(t => t.id === 'hardflip');
  }
  return null;
}

function dopeSkateResolveCombo(){
  if(dopeSkate.combo.points <= 0) return;
  const bonus = Math.floor(dopeSkate.combo.points * dopeSkate.combo.multiplier * dopeSkate.scoreMultiplier);
  dopeSkate.comboBank += bonus;
  dopeSkate.combo.points = 0;
  dopeSkate.combo.tricks = [];
  dopeSkate.combo.unique.clear();
  dopeSkate.combo.multiplier = 1;
  dopeSkate.combo.active = false;
}

function dopeSkateAddTrickById(id){
  const trick = DOPE_SKATE_TRICKS.find(t => t.id === id);
  if(!trick) return;
  dopeSkate.combo.active = true;
  dopeSkate.combo.points += trick.points;
  dopeSkate.combo.tricks.push(trick.name);
  dopeSkate.combo.unique.add(trick.id);
  dopeSkate.combo.multiplier = Math.max(1, dopeSkate.combo.unique.size);
  dopeSkate.lastTrickAt = dopeSkate.time;
  dopeSkate.lastTrickId = trick.id;
  dopeSkateStartTrickAnim(trick.id);
  dopeSkateSpawnTrickText(trick.name);
}

function dopeSkateAddCustomTrick(id, name, points){
  dopeSkate.combo.active = true;
  dopeSkate.combo.points += points;
  dopeSkate.combo.tricks.push(name);
  dopeSkate.combo.unique.add(id);
  dopeSkate.combo.multiplier = Math.max(1, dopeSkate.combo.unique.size);
  dopeSkate.lastTrickAt = dopeSkate.time;
  dopeSkate.lastTrickId = id;
  dopeSkateSpawnTrickText(name);
  dopeSkate.cameraShake = Math.max(dopeSkate.cameraShake, 3);
}

function dopeSkatePickBlissLetter(){
  const remaining = [];
  const counts = dopeSkate.blissCounts;
  if(counts.B < 1) remaining.push('B');
  if(counts.L < 1) remaining.push('L');
  if(counts.I < 1) remaining.push('I');
  if(counts.S < 2) remaining.push('S');
  if(remaining.length === 0) return null;
  return remaining[Math.floor(Math.random() * remaining.length)];
}

function dopeSkateHasBlissComplete(){
  const counts = dopeSkate.blissCounts;
  return counts.B >= 1 && counts.L >= 1 && counts.I >= 1 && counts.S >= 2;
}

function dopeSkateCheckCollisions(){
  const playerBox = dopeSkateGetPlayerHitbox();
  for(const ob of dopeSkate.obstacles){
    if(dopeSkateRectHit(playerBox, ob)){
      dopeSkatePlaySound('crash');
      dopeSkateGameOver();
      return;
    }
  }

  for(const rail of dopeSkate.rails){
    if(dopeSkate.player.mode !== 'grind' && dopeSkate.player.vy > 80){
      const railBox = { x: rail.x, y: rail.y, w: rail.w, h: rail.h };
      const footBox = { x: playerBox.x, y: playerBox.y + playerBox.h - 6, w: playerBox.w, h: 8 };
      if(dopeSkateRectHit(footBox, railBox)){
        dopeSkateStartGrind(rail);
        break;
      }
    }
  }

  for(const item of dopeSkate.collectibles){
    if(dopeSkateRectHit(playerBox, item)){
      dopeSkateCollect(item);
      item.collected = true;
    }
  }
  dopeSkate.collectibles = dopeSkate.collectibles.filter(item => !item.collected);
}

function dopeSkateStartGrind(rail){
  const player = dopeSkate.player;
  if(!player) return;
  player.mode = 'grind';
  player.onGround = false;
  player.vy = 0;
  player.grind = {
    rail,
    balance: 0.5,
    drift: Math.random() > 0.5 ? 1 : -1,
    trick: dopeSkatePickGrindTrick(),
  };
  player.grind.rate = player.grind.trick.rate;
  dopeSkateAddCustomTrick(player.grind.trick.id, player.grind.trick.name, player.grind.trick.points);
  dopeSkate.cameraShake = Math.max(dopeSkate.cameraShake, 5);
  dopeSkatePlaySound('grind');
}

function dopeSkatePickGrindTrick(){
  if(dopeSkate.inputs.left) return { id: 'noseslide', name: 'Noseslide', points: 180, rate: 160 };
  if(dopeSkate.inputs.right) return { id: 'boardslide', name: 'Boardslide', points: 180, rate: 160 };
  return { id: '50-50', name: '50-50', points: 160, rate: 140 };
}

function dopeSkateUpdateGrind(dt){
  const player = dopeSkate.player;
  if(!player || !player.grind) return;
  const rail = player.grind.rail;
  player.y = rail.y - player.h + 10;
  player.x = 130;

  const balanceSpeed = 0.55;
  if(dopeSkate.inputs.left) player.grind.balance -= balanceSpeed * dt;
  if(dopeSkate.inputs.right) player.grind.balance += balanceSpeed * dt;
  player.grind.balance += player.grind.drift * 0.18 * dt;
  if(Math.random() < 0.02) player.grind.drift *= -1;

  dopeSkate.combo.active = true;
  dopeSkate.combo.points += Math.floor(player.grind.rate * dt);
  dopeSkateSpawnSpark(rail.x + 30, rail.y + 6);

  if(player.grind.balance < 0 || player.grind.balance > 1){
    dopeSkatePlaySound('crash');
    dopeSkateGameOver();
    return;
  }

  if(rail.x + rail.w < player.x + 12){
    player.mode = 'air';
    player.grind = null;
    player.vy = 140;
  }
}

function dopeSkateCollect(item){
  if(item.type === 'cd'){
    dopeSkate.cds += 1;
    dopeSkateSpawnCollectFx(item.x + item.w / 2, item.y + item.h / 2);
    dopeSkatePlaySound('collect');
    return;
  }
  if(item.type === 'bliss'){
    const counts = dopeSkate.blissCounts;
    if(item.letter === 'S' && counts.S < 2){
      counts.S += 1;
    } else if(item.letter !== 'S' && counts[item.letter] < 1){
      counts[item.letter] += 1;
    }
    dopeSkateSpawnCollectFx(item.x + item.w / 2, item.y + item.h / 2);
    dopeSkatePlaySound('collect');
  }
}

function dopeSkateGetPlayerHitbox(){
  const p = dopeSkate.player;
  return {
    x: p.x + 6,
    y: p.y + 6,
    w: p.w - 12,
    h: p.h - 8,
  };
}

function dopeSkateRectHit(a, b){
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function dopeSkateRenderComboList(){
  if(!dopeSkate.els || !dopeSkate.els.comboList) return;
  const list = dopeSkate.combo.tricks.slice(-4);
  if(list.length === 0){
    if(dopeSkate.lastComboHtml !== ''){
      dopeSkate.els.comboList.innerHTML = '';
      dopeSkate.lastComboHtml = '';
    }
    return;
  }
  const html = list.map(name => `<span class="skate-combo-item">${name}</span>`).join('');
  if(html !== dopeSkate.lastComboHtml){
    dopeSkate.els.comboList.innerHTML = html;
    dopeSkate.lastComboHtml = html;
  }
}

function dopeSkateRenderBlissHUD(){
  if(!dopeSkate.els || !dopeSkate.els.bliss) return;
  const counts = dopeSkate.blissCounts;
  const key = `${counts.B}${counts.L}${counts.I}${counts.S}`;
  if(key === dopeSkate.lastBlissKey) return;
  const letters = [
    { letter:'B', active: counts.B > 0 },
    { letter:'L', active: counts.L > 0 },
    { letter:'I', active: counts.I > 0 },
    { letter:'S', active: counts.S > 0 },
    { letter:'S', active: counts.S > 1 },
  ];
  dopeSkate.els.bliss.innerHTML = letters.map(item => (
    `<span class="skate-bliss-letter${item.active ? ' active' : ''}">${item.letter}</span>`
  )).join('');
  dopeSkate.lastBlissKey = key;
}

function dopeSkateUpdateBalanceUI(){
  if(!dopeSkate.els || !dopeSkate.els.balance) return;
  const isGrind = dopeSkate.player && dopeSkate.player.mode === 'grind' && dopeSkate.player.grind;
  dopeSkate.els.balance.classList.toggle('hidden', !isGrind);
  if(isGrind && dopeSkate.els.balanceIndicator){
    const pos = Math.max(0, Math.min(1, dopeSkate.player.grind.balance));
    dopeSkate.els.balanceIndicator.style.left = `calc(${pos * 100}% - 2px)`;
  }
}

function dopeSkateSpawnSpark(x, y){
  if(dopeSkate.particles.length > 80) return;
  dopeSkate.particles.push({
    x,
    y,
    vx: -40 + Math.random() * 80,
    vy: -60 + Math.random() * 40,
    life: 0.35 + Math.random() * 0.2,
  });
}

function dopeSkateSpawnCollectFx(x, y){
  if(dopeSkate.particles.length > 120) return;
  for(let i = 0; i < 6; i += 1){
    dopeSkate.particles.push({
      x,
      y,
      vx: -60 + Math.random() * 120,
      vy: -120 + Math.random() * 80,
      life: 0.35 + Math.random() * 0.2,
    });
  }
}

function dopeSkateUpdateParticles(dt){
  dopeSkate.particles.forEach(p => {
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 220 * dt;
  });
  dopeSkate.particles = dopeSkate.particles.filter(p => p.life > 0);
}

function dopeSkateDrawParticles(){
  const ctx = dopeSkate.ctx;
  dopeSkate.particles.forEach(p => {
    if(p.type === 'text'){
      ctx.fillStyle = '#f8fffd';
      ctx.font = '12px "Segoe UI", Arial, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.globalAlpha = Math.max(0, Math.min(1, p.life));
      ctx.fillText(p.text, p.x, p.y);
      ctx.globalAlpha = 1;
      return;
    }
    ctx.fillStyle = '#ffd27d';
    ctx.fillRect(p.x, p.y, 2, 2);
  });
}

function dopeSkateFinalizeScore(){
  const base = dopeSkate.scoreBase + dopeSkate.comboBank;
  const blissComplete = dopeSkateHasBlissComplete();
  dopeSkate.blissBonus = blissComplete ? base : 0;
  dopeSkate.scoreTotal = base + dopeSkate.blissBonus;
  if(dopeSkate.scoreTotal > state.dopeSkate.highScore){
    state.dopeSkate.highScore = dopeSkate.scoreTotal;
    saveDopeSkateHighScore(state.dopeSkate.highScore);
  }
  recordGameScore('dopeSkate', state.dopeSkate.highScore, new Date().toISOString());
  if(dopeSkate.data){
    dopeSkate.data.wallet = (dopeSkate.data.wallet || 0) + dopeSkate.cds;
    saveDopeSkateData(dopeSkate.data);
  }
}

function dopeSkateGetEquippedAssets(){
  if(dopeSkate.equippedAssets && !dopeSkate.equippedDirty){
    return dopeSkate.equippedAssets;
  }
  const assets = dopeSkate.assets || {};
  const eq = (dopeSkate.data && dopeSkate.data.equipped) ? dopeSkate.data.equipped : {};
  const equipped = {
    sky: assets[DOPE_SKATE_SHOP.sky.find(item => item.id === eq.sky)?.asset || 'sky'],
    background: assets[DOPE_SKATE_SHOP.background.find(item => item.id === eq.background)?.asset || 'city'],
    ground: assets[DOPE_SKATE_SHOP.ground.find(item => item.id === eq.ground)?.asset || 'ground'],
    skater: assets[DOPE_SKATE_SHOP.skater.find(item => item.id === eq.skater)?.asset || 'body'],
    hat: assets[DOPE_SKATE_SHOP.hat.find(item => item.id === eq.hat)?.asset || 'hat'],
    board: assets[DOPE_SKATE_SHOP.board.find(item => item.id === eq.board)?.asset || 'board'],
    wheels: assets[DOPE_SKATE_SHOP.wheels.find(item => item.id === eq.wheels)?.asset || 'wheels'],
  };
  if(!dopeSkate.assetsReady){
    return equipped;
  }
  dopeSkate.equippedAssets = equipped;
  dopeSkate.equippedDirty = false;
  return dopeSkate.equippedAssets;
}

function dopeSkateGetAssetsForLoadout(loadout){
  const assets = dopeSkate.assets || {};
  const getAsset = (cat, fallbackKey) => {
    const id = loadout && loadout[cat];
    const item = (DOPE_SKATE_SHOP[cat] || []).find(entry => entry.id === id);
    return assets[item ? item.asset : fallbackKey];
  };
  return {
    sky: getAsset('sky', 'sky'),
    background: getAsset('background', 'city'),
    ground: getAsset('ground', 'ground'),
    skater: getAsset('skater', 'body'),
    hat: getAsset('hat', 'hat'),
    board: getAsset('board', 'board'),
    wheels: getAsset('wheels', 'wheels'),
  };
}

function dopeSkateRenderShop(){
  if(!dopeSkate.els || !dopeSkate.els.shopList || !dopeSkate.data) return;
  const wallet = dopeSkate.data.wallet || 0;
  dopeSkate.els.wallet.textContent = `CD ${wallet}`;
  const equipped = dopeSkate.data.equipped || {};
  const preview = getDopeSkatePreviewState();
  const previewLoadout = preview.active ? { ...equipped, ...preview.loadout } : equipped;

  const currentCat = DOPE_SKATE_SHOP[dopeSkate.shopCategory] ? dopeSkate.shopCategory : 'skater';
  dopeSkate.shopCategory = currentCat;
  if(dopeSkate.els.shopTabs){
    dopeSkate.els.shopTabs.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.skateShopTab === currentCat);
    });
  }

  const labelMap = {
    ground: t('skate.shop.ground'),
    background: t('skate.shop.background'),
    sky: t('skate.shop.sky'),
    skater: t('skate.shop.skater'),
    hat: t('skate.shop.hat'),
    board: t('skate.shop.board'),
    wheels: t('skate.shop.wheels'),
  };
  const html = (DOPE_SKATE_SHOP[currentCat] || []).map(item => {
    const cat = currentCat;
    const label = labelMap[cat] || cat;
    const owned = (dopeSkate.data.owned[cat] || []).includes(item.id);
    const isEquipped = equipped[cat] === item.id;
    const isPreview = preview.active && preview.selectedCategory === cat && preview.selectedItemId === item.id;
    const actionLabel = owned ? (isEquipped ? t('skate.shop.equipped') : t('skate.shop.equip')) : `${t('skate.shop.buy')} CD ${item.cost}`;
    return `
      <div class="skate-shop-item ${isEquipped ? 'active' : ''} ${isPreview ? 'preview' : ''}" data-skate-item="${item.id}" data-skate-cat="${cat}">
        <strong>${label}: ${item.name}</strong>
        <span class="tiny">${isPreview ? t('skate.shop.previewing') : (owned ? t('skate.shop.owned') : `CD ${item.cost}`)}</span>
        <button class="skate-btn ghost" type="button" data-skate-shop-action>${actionLabel}</button>
      </div>
    `;
  }).join('');
  dopeSkate.els.shopList.innerHTML = html;

  dopeSkate.els.shopList.querySelectorAll('[data-skate-shop-action]').forEach(btn => {
    btn.addEventListener('click', (e)=>{
      const card = e.target.closest('[data-skate-item]');
      if(!card) return;
      dopeSkateHandleShopAction(card.dataset.skateCat, card.dataset.skateItem, card);
      e.stopPropagation();
    });
  });
  dopeSkate.els.shopList.querySelectorAll('[data-skate-item]').forEach(card => {
    card.addEventListener('click', ()=>{
      dopeSkateSetPreview(card.dataset.skateCat, card.dataset.skateItem);
      dopeSkateRenderShop();
    });
  });

  dopeSkateRenderPreview(previewLoadout);
  if(dopeSkate.els.previewStatus){
    dopeSkate.els.previewStatus.textContent = preview.active ? t('skate.shop.previewActive') : t('skate.shop.previewNone');
  }
  if(dopeSkate.els.previewReset){
    dopeSkate.els.previewReset.classList.toggle('hidden', !preview.active);
  }
}

function dopeSkateHandleShopAction(cat, itemId, cardEl){
  if(!dopeSkate.data) return;
  const item = (DOPE_SKATE_SHOP[cat] || []).find(entry => entry.id === itemId);
  if(!item) return;
  const owned = dopeSkate.data.owned[cat] || [];
  const isEquipped = dopeSkate.data.equipped[cat] === itemId;
  if(!owned.includes(itemId)){
    if((dopeSkate.data.wallet || 0) < item.cost){
      if(cardEl){
        cardEl.classList.add('locked');
        cardEl.addEventListener('animationend', ()=>{ cardEl.classList.remove('locked'); }, { once:true });
      }
      dopeSkatePlaySound('crash');
      return;
    }
    dopeSkate.data.wallet -= item.cost;
    owned.push(itemId);
    dopeSkate.data.owned[cat] = owned;
    dopeSkatePlaySound('collect');
  } else if(!isEquipped){
    dopeSkatePlaySound('trick');
    dopeSkate.data.equipped[cat] = itemId;
    dopeSkate.equippedDirty = true;
  }
  saveDopeSkateData(dopeSkate.data);
  if(cardEl){
    cardEl.classList.add('flash');
    cardEl.addEventListener('animationend', ()=>{ cardEl.classList.remove('flash'); }, { once:true });
  }
  dopeSkateRenderShop();
}

function dopeSkateRenderPreview(loadout){
  if(!dopeSkate.els || !dopeSkate.els.previewStage) return;
  const effectiveLoadout = loadout || (dopeSkate.data ? dopeSkate.data.equipped : {});
  const assets = dopeSkateGetAssetsForLoadout(effectiveLoadout);
  dopeSkate.els.previewStage.innerHTML = '';
  const stage = dopeSkate.els.previewStage;
  const makeImg = (src, style) => {
    if(!src) return;
    const img = document.createElement('img');
    img.src = src.src || src;
    Object.assign(img.style, style);
    stage.appendChild(img);
  };
  if(assets.sky) makeImg(assets.sky, { inset:'0', width:'100%', height:'100%', objectFit:'cover' });
  if(assets.background) makeImg(assets.background, { inset:'0', width:'100%', height:'100%', objectFit:'cover', opacity:'0.85' });
  if(assets.ground) makeImg(assets.ground, { left:'0', bottom:'0', width:'100%', height:'40px', objectFit:'cover' });
  if(assets.board) makeImg(assets.board, { left:'45%', bottom:'24px', width:'80px', height:'18px' });
  if(assets.wheels) makeImg(assets.wheels, { left:'49%', bottom:'16px', width:'34px', height:'12px' });
  if(assets.skater) makeImg(assets.skater, { left:'47%', bottom:'32px', width:'48px', height:'64px' });
  if(assets.hat) makeImg(assets.hat, { left:'50%', bottom:'84px', width:'28px', height:'16px' });
  if(dopeSkate.els.equippedList && dopeSkate.data){
    dopeSkate.els.equippedList.textContent = Object.entries(dopeSkate.data.equipped).map(([cat, id]) => {
      const item = (DOPE_SKATE_SHOP[cat] || []).find(entry => entry.id === id);
      const label = cat.charAt(0).toUpperCase() + cat.slice(1);
      return `${label}: ${item ? item.name : id}`;
    }).join('  ');
  }
}

function dopeSkateUnlockAudio(){
  if(dopeSkate.audio.unlocked) return;
  try{
    if(!dopeSkate.audio.ctx){
      dopeSkate.audio.ctx = new (window.AudioContext || window.webkitAudioContext)();
    }
    dopeSkate.audio.ctx.resume();
    dopeSkate.audio.unlocked = true;
  } catch {}
}

function dopeSkatePlaySound(name){
  if(!dopeSkateIsSfxEnabled()) return;
  if(!dopeSkate.audio.unlocked || !dopeSkate.audio.ctx) return;
  const ctx = dopeSkate.audio.ctx;
  const osc = ctx.createOscillator();
  const gain = ctx.createGain();
  const vol = dopeSkateGetVolume();
  gain.gain.value = 0.0001;
  osc.type = 'square';
  const tones = {
    jump: 440,
    land: 220,
    trick: 520,
    grind: 180,
    collect: 660,
    crash: 120,
  };
  osc.frequency.value = tones[name] || 300;
  osc.connect(gain);
  gain.connect(ctx.destination);
  const now = ctx.currentTime;
  gain.gain.exponentialRampToValueAtTime(vol * 0.25, now + 0.02);
  gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
  osc.start(now);
  osc.stop(now + 0.16);
}

function dopeSkateGetVolume(){
  const volEl = document.getElementById('mpVol');
  const val = volEl ? parseFloat(volEl.value) : 0.6;
  return Number.isFinite(val) ? Math.max(0, Math.min(1, val)) : 0.6;
}

function loadClothesCache(){
  try{
    const raw = localStorage.getItem(CLOTHES_CACHE_KEY);
    if(!raw) return null;
    const parsed = JSON.parse(raw);
    if(!parsed || !Array.isArray(parsed.items)) return null;
    if(!parsed.ts || (Date.now() - parsed.ts) > CLOTHES_CACHE_TTL) return null;
    return parsed.items;
  } catch {
    return null;
  }
}

function saveClothesCache(items){
  try{
    localStorage.setItem(CLOTHES_CACHE_KEY, JSON.stringify({ ts: Date.now(), items }));
  } catch {}
}

function decodeInstagramUrl(url){
  if(!url) return '';
  return url
    .replace(/\\u0026/g, '&')
    .replace(/\\u003d/g, '=')
    .replace(/\\\//g, '/');
}

function parseInstagramHtml(html){
  if(!html) return [];
  const items = [];
  const re = /"shortcode":"(.*?)".*?"display_url":"(.*?)"/g;
  let match;
  while((match = re.exec(html)) && items.length < 12){
    const shortcode = match[1];
    const display = decodeInstagramUrl(match[2]);
    if(!shortcode || !display) continue;
    items.push({
      img: display,
      url: `https://www.instagram.com/p/${shortcode}/`
    });
  }
  return items;
}

function fetchClothesFromInstagram(){
  const url = 'https://r.jina.ai/http://www.instagram.com/blissworldweb/';
  return fetch(url, { cache: 'no-store' })
    .then(res => res.ok ? res.text() : Promise.reject(new Error('bad')))
    .then(html => parseInstagramHtml(html))
    .catch(() => []);
}

function renderClothesItems(winEl, items){
  const grid = winEl.querySelector('#clothesGrid');
  if(!grid) return;
  const profile = 'https://www.instagram.com/blissworldweb/';
  const alt = t('clothes.thumbAlt');
  grid.innerHTML = items.map(item => {
    const href = item.url || profile;
    const img = item.img || './assets/icons/Clothes.png';
    return `
      <a class="clothes-item" href="${href}" target="_blank" rel="noopener noreferrer" aria-label="${alt}">
        <img class="clothes-thumb" src="${img}" alt="${alt}" loading="lazy" />
      </a>
    `;
  }).join('');
}

function updateClothesStatus(winEl, key){
  const status = winEl.querySelector('#clothesStatus');
  if(!status) return;
  if(!key){
    status.textContent = '';
    status.classList.add('hidden');
  } else {
    status.textContent = t(key);
    status.classList.remove('hidden');
  }
}

function initClothesWindow(winEl){
  const win = winEl || document.getElementById('win_clothes');
  if(!win) return;
  const cached = loadClothesCache();
  if(cached && cached.length){
    renderClothesItems(win, cached);
    updateClothesStatus(win, null);
    return;
  }
  updateClothesStatus(win, 'clothes.loading');
  fetchClothesFromInstagram().then(items => {
    if(items && items.length) saveClothesCache(items);
    const fallback = (items && items.length) ? items : CLOTHES_FALLBACK;
    if(fallback && fallback.length){
      renderClothesItems(win, fallback);
      updateClothesStatus(win, null);
    } else {
      renderClothesItems(win, []);
      updateClothesStatus(win, 'clothes.unavailable');
    }
  });
}

function initSettingsTabs(winEl){
  const win = winEl || document.getElementById('win_settings');
  if(!win) return;
  const tabs = Array.from(win.querySelectorAll('.settings-tab'));
  const panels = Array.from(win.querySelectorAll('.settings-panel'));
  if(!tabs.length || !panels.length) return;
  const panelMap = new Map(panels.map(p => [p.dataset.tab, p]));

  const activate = (tabId)=>{
    if(!panelMap.has(tabId)) return;
    state.settings.tab = tabId;
    tabs.forEach(tab => {
      const active = tab.dataset.tab === tabId;
      tab.setAttribute('aria-selected', active ? 'true' : 'false');
      tab.tabIndex = active ? 0 : -1;
    });
    panels.forEach(panel => {
      panel.classList.toggle('active', panel.dataset.tab === tabId);
    });
    updateWallpaperButtons(win);
    updateAnimationButtons(win);
    updateScanlinesButtons(win);
    const content = win.querySelector('.content');
    if(content){
      content.dataset.fitKey = `settings:${tabId}`;
      if(tabId === 'appearance'){
        content.dataset.fitMinW = '560';
      } else {
        delete content.dataset.fitMinW;
      }
    }
    autoFitWindow(win, 'settings');
  };

  const current = (state.settings.tab && panelMap.has(state.settings.tab))
    ? state.settings.tab
    : tabs[0].dataset.tab;
  activate(current);

  tabs.forEach((tab, idx) => {
    tab.addEventListener('click', ()=>{
      activate(tab.dataset.tab);
    });
    tab.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(key === 'Enter' || key === ' '){
        e.preventDefault();
        activate(tab.dataset.tab);
        return;
      }
      if(key === 'ArrowRight' || key === 'ArrowLeft' || key === 'Home' || key === 'End'){
        e.preventDefault();
        let nextIdx = idx;
        if(key === 'ArrowRight') nextIdx = (idx + 1) % tabs.length;
        if(key === 'ArrowLeft') nextIdx = (idx - 1 + tabs.length) % tabs.length;
        if(key === 'Home') nextIdx = 0;
        if(key === 'End') nextIdx = tabs.length - 1;
        tabs[nextIdx].focus();
      }
    });
  });
}

function openSettingsAndTab(tabId, scrollId){
  state.settings.tab = tabId || 'general';
  openApp('settings');
  setTimeout(()=>{
    const winEl = document.getElementById('win_settings');
    if(winEl) initSettingsTabs(winEl);
    if(winEl && scrollId){
      const target = winEl.querySelector(`#${scrollId}`);
      if(target && target.scrollIntoView){
        target.scrollIntoView({ block: 'nearest' });
      }
    }
  }, 0);
}

function selectPoetryItem(id){
  state.poetry.selectedId = id;
  const win = document.getElementById('win_poetry');
  if(!win) return;
  win.querySelectorAll('[data-poem-id]').forEach(item => {
    item.classList.toggle('selected', item.dataset.poemId === id);
  });
}

function arrangeIcons(){
  const next = getDefaultIconLayout();
  saveIconPositions(next);
  renderIcons();
}

function resetIconPositions(){
  try{ localStorage.removeItem(ICON_POS_KEY); } catch {}
  renderIcons();
}

function loadAnimations(){
  try{
    const raw = localStorage.getItem(ANIMATIONS_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveAnimations(){
  try{
    localStorage.setItem(ANIMATIONS_KEY, state.animations ? '1' : '0');
  } catch {}
}

function updateAnimationButtons(root=document){
  $$('[data-set-animations]', root).forEach(btn => {
    const on = btn.dataset.setAnimations === 'on';
    btn.classList.toggle('pressed', on === state.animations);
  });
}

function setAnimations(enabled){
  state.animations = !!enabled;
  saveAnimations();
  updateAnimationButtons();
}

function updateScanlinesButtons(root=document){
  $$('[data-set-scanlines]', root).forEach(btn => {
    const on = btn.dataset.setScanlines === 'on';
    btn.classList.toggle('pressed', on === state.settings.scanlines);
  });
}

function setScanlines(enabled){
  state.settings.scanlines = !!enabled;
  applyScanlines();
  updateScanlinesButtons();
}

function updateRetroGlowButtons(root=document){
  $$('[data-set-retro]', root).forEach(btn => {
    const on = btn.dataset.setRetro === 'on';
    btn.classList.toggle('pressed', on === state.settings.retroGlow);
  });
}

function setRetroGlow(enabled){
  state.settings.retroGlow = !!enabled;
  applyRetroGlow();
  updateRetroGlowButtons();
}

function updateDarkModeButtons(root=document){
  $$('[data-set-darkmode]', root).forEach(btn => {
    const on = btn.dataset.setDarkmode === 'on';
    btn.classList.toggle('pressed', on === state.settings.darkMode);
  });
}

function setDarkMode(enabled, fromPreset=false){
  state.settings.darkMode = !!enabled;
  applyDarkMode();
  updateDarkModeButtons();
  if(!fromPreset && !themeApplying) setThemePresetCustom();
}

function loadScanlines(){
  try{
    const raw = localStorage.getItem(SCANLINES_KEY);
    if(raw === null) return false;
    return raw === '1';
  } catch {
    return false;
  }
}

function loadDarkMode(){
  try{
    const raw = localStorage.getItem(DARKMODE_KEY);
    if(raw === null) return false;
    return raw === '1';
  } catch {
    return false;
  }
}

function loadTitlebarTheme(){
  try{
    const raw = localStorage.getItem(TITLEBAR_KEY);
    if(raw === 'transparent') return 'blank';
    return raw || 'defaultBlue';
  } catch {
    return 'defaultBlue';
  }
}

function loadThemePreset(){
  try{
    const raw = localStorage.getItem(THEME_PRESET_KEY);
    return raw || 'default';
  } catch {
    return 'default';
  }
}

function saveScanlines(){
  try{
    localStorage.setItem(SCANLINES_KEY, state.settings.scanlines ? '1' : '0');
  } catch {}
}

function saveDarkMode(){
  try{
    localStorage.setItem(DARKMODE_KEY, state.settings.darkMode ? '1' : '0');
  } catch {}
}

function saveTitlebarTheme(){
  try{
    localStorage.setItem(TITLEBAR_KEY, state.theme.titlebar);
  } catch {}
}

function saveThemePreset(){
  try{
    localStorage.setItem(THEME_PRESET_KEY, state.theme.preset);
  } catch {}
}

function loadTrash(){
  try{
    const raw = localStorage.getItem(TRASH_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}

function saveTrash(){
  try{
    localStorage.setItem(TRASH_KEY, JSON.stringify(Array.from(state.trash)));
  } catch {}
}

function loadIconLabels(){
  try{
    const raw = localStorage.getItem(ICON_LABELS_KEY);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function saveIconLabels(){
  try{
    localStorage.setItem(ICON_LABELS_KEY, JSON.stringify(state.iconLabels));
  } catch {}
}

function loadFolders(){
  try{
    const raw = localStorage.getItem(FOLDER_KEY);
    if(raw) return JSON.parse(raw);
  } catch {}
  return { games: ['snake', 'dope-skate'] };
}

function saveFolders(){
  try{
    localStorage.setItem(FOLDER_KEY, JSON.stringify(state.folders));
  } catch {}
}

function loadWallpaper(){
  try{
    const saved = localStorage.getItem(WALLPAPER_KEY);
    return saved || WALLPAPERS[0].id;
  } catch {
    return WALLPAPERS[0].id;
  }
}

function updateWallpaperButtons(root=document){
  $$('[data-set-wallpaper]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setWallpaper === state.wallpaper);
  });
}

let themeApplying = false;

function loadGamesLayout(){
  try{
    const raw = localStorage.getItem(GAMES_VIEW_KEY);
    return raw || 'grid';
  } catch {
    return 'grid';
  }
}

function saveGamesLayout(){
  try{
    localStorage.setItem(GAMES_VIEW_KEY, state.games.layout);
  } catch {}
}

function loadGamesBigIcons(){
  try{
    const raw = localStorage.getItem(GAMES_BIG_KEY);
    return raw === '1';
  } catch {
    return false;
  }
}

function saveGamesBigIcons(){
  try{
    localStorage.setItem(GAMES_BIG_KEY, state.games.bigIcons ? '1' : '0');
  } catch {}
}

function loadRetroGlow(){
  try{
    const raw = localStorage.getItem(RETRO_KEY);
    return raw === '1';
  } catch {
    return false;
  }
}

function saveRetroGlow(){
  try{
    localStorage.setItem(RETRO_KEY, state.settings.retroGlow ? '1' : '0');
  } catch {}
}

function updateTitlebarButtons(root=document){
  $$('[data-set-titlebar]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setTitlebar === state.theme.titlebar);
  });
}

function updateThemeButtons(root=document){
  $$('[data-set-theme]', root).forEach(btn => {
    btn.classList.toggle('pressed', btn.dataset.setTheme === state.theme.preset);
  });
  const current = root.querySelector('[data-theme-current]');
  if(current){
    const key = `theme.${state.theme.preset}`;
    current.textContent = t(key);
  }
}

function applyThemePalette(){
  const palette = state.theme.palette || (state.theme.preset === 'xp98' ? 'xp98' : 'default');
  document.body.classList.toggle('theme-xp98', palette === 'xp98');
}

function setThemePresetCustom(){
  if(state.theme.preset !== 'custom'){
    state.theme.preset = 'custom';
    saveThemePreset();
    applyThemePalette();
    updateThemeButtons();
    updateThemeThumbs();
  }
}

function applyWallpaper(id){
  const wp = WALLPAPERS.find(w => w.id === id) || WALLPAPERS[0];
  state.wallpaper = wp.id;
  const desktop = $('#desktop');
  if(desktop){
    desktop.classList.remove('wallpaper-matrix');
    if(wp.className){
      desktop.classList.add(wp.className);
      desktop.style.background = '';
      desktop.style.backgroundSize = '';
      desktop.style.backgroundRepeat = '';
      desktop.style.backgroundPosition = '';
    } else {
      desktop.style.background = wp.background;
      desktop.style.backgroundSize = wp.size || 'auto';
      desktop.style.backgroundRepeat = wp.repeat || 'repeat';
      desktop.style.backgroundPosition = wp.position || 'top left';
    }
  }
  try{ localStorage.setItem(WALLPAPER_KEY, wp.id); } catch {}
  updateWallpaperButtons();
  renderCtxMenu();
  if(!themeApplying) setThemePresetCustom();
}

function setTitlebarTheme(id, fromPreset=false){
  state.theme.titlebar = id;
  saveTitlebarTheme();
  applyTitlebarTheme();
  updateTitlebarButtons();
  if(!fromPreset && !themeApplying) setThemePresetCustom();
}

function applyTitlebarTheme(){
  const cur = TITLEBAR_THEMES[state.theme.titlebar] || TITLEBAR_THEMES.defaultBlue;
  document.body.classList.toggle('titlebar-blank', state.theme.titlebar === 'blank');
  document.body.style.setProperty('--title', cur.bar1);
  document.body.style.setProperty('--title2', cur.bar2);
  document.body.style.setProperty('--titlebar-text', cur.text);
}

function setThemePreset(id, opts={}){
  const preset = THEME_PRESETS.find(t => t.id === id);
  if(!preset) return;
  themeApplying = true;
  state.theme.preset = id;
  state.theme.palette = (id === 'xp98') ? 'xp98' : 'default';
  saveThemePreset();
  applyThemePalette();
  setDarkMode(preset.darkMode, true);
  applyWallpaper(preset.wallpaperId);
  setTitlebarTheme(preset.titlebarColor, true);
  themeApplying = false;
  updateThemeButtons();
  updateThemeThumbs();
  if(!opts.init) renderCtxMenu();
}

function loadCustomTheme(){
  try{
    const raw = localStorage.getItem(THEME_CUSTOM_KEY);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function saveCustomTheme(data){
  try{
    localStorage.setItem(THEME_CUSTOM_KEY, JSON.stringify(data));
  } catch {}
}

function updateThemeThumbs(root=document){
  $$('[data-theme-thumb]', root).forEach(btn => {
    btn.classList.toggle('selected', btn.dataset.themeThumb === state.theme.preset);
  });
  const customBtn = root.querySelector('[data-theme-custom="load"]');
  if(customBtn){
    const hasCustom = !!loadCustomTheme();
    customBtn.classList.toggle('disabled', !hasCustom);
    const label = customBtn.querySelector('[data-theme-custom-label]');
    if(label) label.textContent = hasCustom ? t('theme.custom') : t('theme.customEmpty');
  }
}

function saveCustomThemeFromState(){
  const data = {
    wallpaper: state.wallpaper,
    titlebar: state.theme.titlebar,
    darkMode: state.settings.darkMode,
    scanlines: state.settings.scanlines,
    retroGlow: state.settings.retroGlow,
    palette: state.theme.palette || 'default'
  };
  saveCustomTheme(data);
  updateThemeThumbs();
}

function applyCustomTheme(){
  const data = loadCustomTheme();
  if(!data) return;
  themeApplying = true;
  state.theme.preset = 'custom';
  state.theme.palette = data.palette || 'default';
  saveThemePreset();
  applyThemePalette();
  setDarkMode(!!data.darkMode, true);
  applyWallpaper(data.wallpaper || WALLPAPERS[0].id);
  setTitlebarTheme(data.titlebar || 'defaultBlue', true);
  state.settings.scanlines = !!data.scanlines;
  applyScanlines();
  state.settings.retroGlow = !!data.retroGlow;
  applyRetroGlow();
  themeApplying = false;
  updateThemeButtons();
  updateThemeThumbs();
  renderCtxMenu();
}

function applyMusicState(winEl){
  const win = winEl || document.getElementById('win_music');
  if(!win) return;
  const grid = win.querySelector('.music-grid');
  if(!grid) return;
  grid.classList.toggle('music-small', state.music.tileSize === 'small');
  win.classList.toggle('music-hide-icons', !state.music.showIcons);
  grid.querySelectorAll('[data-music-id]').forEach(card => {
    const id = card.dataset.musicId;
    card.classList.toggle('selected', state.music.selected.has(id));
  });
}

function applyMediaplayerState(winEl){
  const win = winEl || document.getElementById('win_mediaplayer');
  if(!win) return;
  const hasList = !!win.querySelector('#mpList');
  if(hasList){
    win.classList.toggle('mp-hide-list', !state.mediaplayer.showPlaylist);
  }
  win.classList.toggle('mp-compact', state.mediaplayer.compact);
}

function applyDievState(winEl){
  const win = winEl || document.getElementById('win_diev');
  if(!win) return;
  win.classList.toggle('diev-small', state.diev.textSize === 'small');
  win.classList.toggle('diev-large', state.diev.textSize === 'large');
  win.classList.toggle('diev-contrast', state.diev.highContrast);
}

function applyArtState(winEl){
  const win = winEl || document.getElementById('win_art');
  if(!win) return;
  win.classList.toggle('art-zoom-50', state.art.zoom === 50);
  win.classList.toggle('art-zoom-100', state.art.zoom === 100);
  win.classList.toggle('art-zoom-200', state.art.zoom === 200);
}

function getAppById(id){
  return APPS.find(a => a.id === id) || null;
}

function getVirtualIconById(id){
  return VIRTUAL_ICONS.find(v => v.id === id) || null;
}

function openIconById(id){
  if(id === 'snake'){
    openApp('games');
    state.games.view = 'snake';
    state.games.selectedId = 'snake';
    renderGamesWindow();
    return;
  }
  openApp(id);
}

function isInFolder(id){
  return (state.folders.games || []).includes(id);
}

function addToFolder(folderId, ids){
  const folder = state.folders[folderId] || [];
  ids.forEach(id => {
    if(id === 'games' || id === 'trash') return;
    if(!folder.includes(id)) folder.push(id);
  });
  state.folders[folderId] = folder;
  saveFolders();
}

function removeFromFolder(folderId, ids){
  const folder = state.folders[folderId] || [];
  state.folders[folderId] = folder.filter(id => !ids.includes(id));
  saveFolders();
}

function isOverTrashWindow(x, y){
  const win = document.getElementById('win_trash');
  if(!win || win.classList.contains('hidden')) return false;
  const content = win.querySelector('.content');
  if(!content) return false;
  const r = content.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function isOverGamesWindow(x, y){
  const win = document.getElementById('win_games');
  if(!win || win.classList.contains('hidden')) return false;
  if(state.games.view !== 'list') return false;
  const content = win.querySelector('.content');
  if(!content) return false;
  const r = content.getBoundingClientRect();
  return x >= r.left && x <= r.right && y >= r.top && y <= r.bottom;
}

function isOverDesktopArea(x, y){
  const area = $('#desktopArea').getBoundingClientRect();
  return x >= area.left && x <= area.right && y >= area.top && y <= area.bottom;
}

function setIconPosition(id, x, y){
  const saved = loadIconPositions();
  const metrics = getGridMetrics();
  let nx = x;
  let ny = y;
  if(state.gridSnap){
    const snapped = snapToGrid(nx, ny);
    nx = snapped.x;
    ny = snapped.y;
  }
  const occupied = buildOccupied([id], metrics);
  const placed = placeOnFreeCell(nx, ny, occupied, metrics);
  saved[id] = { x: placed.x, y: placed.y };
  saveIconPositions(saved);
}

function makeGameItemDraggable(itemEl, id){
  let down = false;
  let dragging = false;
  let pointerId = null;
  let startX = 0;
  let startY = 0;
  let ghost = null;
  const dragLayer = $('#dragLayer');

  const onPointerDown = (e)=>{
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    down = true;
    dragging = false;
    pointerId = e.pointerId;
    startX = e.clientX;
    startY = e.clientY;
    itemEl.setPointerCapture(pointerId);
    itemEl.addEventListener('pointermove', onPointerMove);
    itemEl.addEventListener('pointerup', onPointerUp);
    itemEl.addEventListener('pointercancel', onPointerUp);
  };

  const onPointerMove = (e)=>{
    if(!down) return;
    if(pointerId !== null && e.pointerId !== pointerId) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    if(!dragging && (Math.abs(dx) + Math.abs(dy) > 4)){
      dragging = true;
      if(dragLayer){
        dragLayer.classList.add('active');
        ghost = itemEl.cloneNode(true);
        ghost.classList.add('games-drag-ghost');
        if(state.games.bigIcons && state.games.layout === 'grid') ghost.classList.add('big');
        dragLayer.appendChild(ghost);
      }
    }
    if(!dragging || !ghost) return;
    const area = $('#desktopArea').getBoundingClientRect();
    ghost.style.left = (e.clientX - area.left - 20) + 'px';
    ghost.style.top = (e.clientY - area.top - 20) + 'px';
  };

  const onPointerUp = (e)=>{
    if(pointerId !== null && e.pointerId !== pointerId) return;
    down = false;
    try{ itemEl.releasePointerCapture(e.pointerId); } catch {}
    itemEl.removeEventListener('pointermove', onPointerMove);
    itemEl.removeEventListener('pointerup', onPointerUp);
    itemEl.removeEventListener('pointercancel', onPointerUp);

    if(ghost && dragLayer){
      ghost.remove();
      dragLayer.classList.remove('active');
      ghost = null;
    }

    if(dragging && isOverDesktopArea(e.clientX, e.clientY) && !isOverGamesWindow(e.clientX, e.clientY)){
      removeFromFolder('games', [id]);
      const area = $('#desktopArea').getBoundingClientRect();
      const x = clamp(Math.round(e.clientX - area.left - ICON_SIZE.w / 2), 0, area.width - ICON_SIZE.w - 6);
      const y = clamp(Math.round(e.clientY - area.top - ICON_SIZE.h / 2), 0, area.height - ICON_SIZE.h - 6);
      setIconPosition(id, x, y);
      renderIcons();
      renderGamesWindow();
    }

    dragging = false;
    pointerId = null;
  };

  itemEl.addEventListener('pointerdown', onPointerDown);
}

function loadYouTubeApiKey(){
  try{
    return localStorage.getItem(YOUTUBE_KEY) || '';
  } catch {
    return '';
  }
}

function saveYouTubeApiKey(key){
  try{
    if(key){
      localStorage.setItem(YOUTUBE_KEY, key);
    } else {
      localStorage.removeItem(YOUTUBE_KEY);
    }
  } catch {}
}

function getFallbackEmbedUrl(){
  return `https://www.youtube.com/embed?listType=search&list=${encodeURIComponent(VIDEO_CHANNEL_HANDLE)}`;
}

function formatIsoDuration(iso){
  const match = /PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/.exec(iso || '');
  if(!match) return '';
  const h = parseInt(match[1] || '0', 10);
  const m = parseInt(match[2] || '0', 10);
  const s = parseInt(match[3] || '0', 10);
  const mm = String(m + (h * 60)).padStart(2, '0');
  const ss = String(s).padStart(2, '0');
  return `${mm}:${ss}`;
}

function formatVideoDate(iso){
  const d = new Date(iso);
  if(Number.isNaN(d.getTime())) return '';
  const locale = state.lang === 'pt' ? 'pt-BR' : 'en-US';
  return d.toLocaleDateString(locale, { year:'numeric', month:'short', day:'numeric' });
}

async function fetchYouTubeVideos(apiKey){
  const base = 'https://www.googleapis.com/youtube/v3';
  const channelUrl = `${base}/channels?part=contentDetails&forHandle=${encodeURIComponent(VIDEO_CHANNEL_HANDLE)}&key=${encodeURIComponent(apiKey)}`;
  const chRes = await fetch(channelUrl);
  if(!chRes.ok) throw new Error('channel');
  const chData = await chRes.json();
  const uploads = chData?.items?.[0]?.contentDetails?.relatedPlaylists?.uploads;
  if(!uploads) throw new Error('uploads');

  const listUrl = `${base}/playlistItems?part=snippet,contentDetails&maxResults=24&playlistId=${uploads}&key=${encodeURIComponent(apiKey)}`;
  const listRes = await fetch(listUrl);
  if(!listRes.ok) throw new Error('playlist');
  const listData = await listRes.json();
  const items = (listData.items || []).map(it => ({
    id: it?.contentDetails?.videoId,
    title: it?.snippet?.title || '',
    thumb: it?.snippet?.thumbnails?.medium?.url || it?.snippet?.thumbnails?.default?.url || '',
    publishedAt: it?.contentDetails?.videoPublishedAt || it?.snippet?.publishedAt || ''
  })).filter(it => it.id);

  const ids = items.map(it => it.id).join(',');
  if(!ids) return [];
  const videosUrl = `${base}/videos?part=contentDetails&id=${ids}&key=${encodeURIComponent(apiKey)}`;
  const vidsRes = await fetch(videosUrl);
  if(!vidsRes.ok) throw new Error('videos');
  const vidsData = await vidsRes.json();
  const durationMap = new Map();
  (vidsData.items || []).forEach(v => {
    durationMap.set(v.id, formatIsoDuration(v?.contentDetails?.duration));
  });

  return items.map(it => ({
    ...it,
    duration: durationMap.get(it.id) || ''
  }));
}

function renderVideoPlayer(winEl, videoId, opts = {}){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const frame = win.querySelector('#videosPlayer');
  if(!frame) return;
  const src = videoId
    ? `https://www.youtube.com/embed/${videoId}?rel=0`
    : getFallbackEmbedUrl();
  if(opts.force || frame.src !== src){
    frame.src = src;
  }
}

function renderVideosList(winEl, items){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const list = win.querySelector('#videosList');
  if(!list) return;
  if(!items || items.length === 0){
    list.innerHTML = `<div class="tiny" data-i18n="videos.listEmpty">${t('videos.listEmpty')}</div>`;
    return;
  }
  list.innerHTML = items.map(it => {
    const selected = it.id === state.videos.selectedId;
    const date = formatVideoDate(it.publishedAt);
    const meta = [it.duration, date].filter(Boolean).join('  ');
    return `
      <button class="videos-item bevel-in${selected ? ' selected' : ''}" type="button" data-video-id="${it.id}">
        <img class="videos-thumb pixel" src="${it.thumb}" alt="" />
        <div class="videos-meta">
          <div class="videos-title">${it.title}</div>
          <div class="videos-sub">${meta}</div>
        </div>
      </button>
    `;
  }).join('');
}

function initVideosWindow(winEl){
  const win = winEl || document.getElementById('win_videos');
  if(!win) return;
  const status = win.querySelector('#videosStatus');
  if(status) status.textContent = '';
  renderVideoPlayer(win, null, { force:true });

  const key = loadYouTubeApiKey();
  if(!key){
    if(status) status.textContent = t('videos.noKey');
    renderVideosList(win, []);
    return;
  }

  if(status) status.textContent = t('videos.loading');
  fetchYouTubeVideos(key).then(items => {
    state.videos.items = items;
    state.videos.selectedId = items[0]?.id || null;
    if(items[0]) renderVideoPlayer(win, items[0].id, { force:true });
    renderVideosList(win, items);
    if(status) status.textContent = items.length ? '' : t('videos.listEmpty');
  }).catch(()=>{
    if(status) status.textContent = t('videos.autoFail');
    renderVideosList(win, []);
    renderVideoPlayer(win, null, { force:true });
  });
}

function applyScanlines(){
  document.body.classList.toggle('scanlines', state.settings.scanlines);
  saveScanlines();
  updateScanlinesButtons();
}

function applyRetroGlow(){
  document.body.classList.toggle('retro-glow', state.settings.retroGlow);
  saveRetroGlow();
  updateRetroGlowButtons();
}

function applyDarkMode(){
  document.body.classList.toggle('dark', state.settings.darkMode);
  saveDarkMode();
  updateDarkModeButtons();
  renderCtxMenu();
  applyTitlebarTheme();
}

function applyWindowState(winEl, appId){
  if(appId === 'music') applyMusicState(winEl);
  if(appId === 'mediaplayer') applyMediaplayerState(winEl);
  if(appId === 'diev') applyDievState(winEl);
  if(appId === 'art') applyArtState(winEl);
}

function getPoemById(id){
  return POEMS.find(p => p.id === id) || null;
}

function getPoemBody(poem, lang){
  if(!poem) return '';
  if(lang === 'pt') return poem.body_pt || poem.body_en || '';
  return poem.body_en || poem.body_pt || '';
}

// Context menu state
let ctxState = { open:false, target:'desktop', appId:null };

function renderCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;

  const isIcon = ctxState.target === 'icon' && !!ctxState.appId;
  const gridMark = state.gridSnap ? '' : '';

  const items = [];
  if(isIcon){
    items.push({ action:'open', label:t('ctx.open') });
    items.push({ sep:true });
    if(ctxState.appId === 'trash'){
      items.push({ action:'emptyTrash', label:t('ctx.emptyTrash') });
      items.push({ sep:true });
    } else {
      items.push({ action:'rename', label:t('ctx.rename') });
      items.push({ action:'crop', label:t('ctx.crop') });
      items.push({ action:'copy', label:t('ctx.copy') });
      items.push({ sep:true });
      items.push({ action:'moveTrash', label:t('ctx.moveTrash') });
      items.push({ sep:true });
    }
  }

  if(!isIcon){
    items.push({ action:'arrange', label:t('ctx.arrange') });
    items.push({ action:'grid', label:t('ctx.grid'), check:gridMark });
    items.push({ action:'wallpaper', label:t('ctx.wallpaper') });
    items.push({ sep:true });
    items.push({ action:'settings', label:t('ctx.settings') });
    items.push({ action:'language', label:t('ctx.language'), right: state.lang.toUpperCase() });
    items.push({ action:'about', label:t('ctx.about') });
    items.push({ sep:true });
    items.push({ action:'logoff', label:t('ctx.logoff') });
  }

  menu.innerHTML = items.map(it => {
    if(it.sep) return `<div class="ctx-sep"></div>`;
    const check = it.check ? `<span class="ctx-check" aria-hidden="true">${it.check}</span>` : `<span class="ctx-check" aria-hidden="true"></span>`;
    const right = it.right ? `<span class="ctx-shortcut">${it.right}</span>` : `<span class="ctx-shortcut"></span>`;
    return `
      <button class="ctx-item" type="button" role="menuitem" data-ctx-action="${it.action}">
        <span class="ctx-left">${check}<span>${it.label}</span></span>
        ${right}
      </button>
    `;
  }).join('');
}

function positionCtxMenu(x, y){
  const menu = $('#ctxMenu');
  if(!menu) return;
  const area = $('#desktopArea').getBoundingClientRect();

  menu.classList.remove('hidden');
  menu.style.left = '0px';
  menu.style.top = '0px';
  const rect = menu.getBoundingClientRect();

  const maxX = area.left + area.width - rect.width - 6;
  const maxY = area.top + area.height - rect.height - 6;

  const px = clamp(x, area.left + 6, maxX);
  const py = clamp(y, area.top + 6, area.top + area.height - rect.height - 6);

  menu.style.left = (px - area.left) + 'px';
  menu.style.top = (py - area.top) + 'px';
}

function openCtxMenu(x, y, target='desktop', appId=null){
  if($('#desktop').classList.contains('hidden')) return;
  ctxState = { open:true, target, appId };
  closeStartMenu();
  closeWindowMenu();
  renderCtxMenu();
  positionCtxMenu(x, y);
  const menu = $('#ctxMenu');
  if(menu){
    menu.classList.remove('hidden');
    const first = menu.querySelector('.ctx-item');
    if(first) first.focus();
  }
}

function closeCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;
  menu.classList.add('hidden');
  ctxState = { open:false, target:'desktop', appId:null };
}

function handleCtxAction(action){
  if(action === 'open' && ctxState.target === 'icon' && ctxState.appId){
    openIconById(ctxState.appId);
  }
  if(action === 'rename' && ctxState.target === 'icon' && ctxState.appId && ctxState.appId !== 'trash'){
    const app = getAppById(ctxState.appId);
    const virtual = getVirtualIconById(ctxState.appId);
    const key = app ? app.titleKey : (virtual ? virtual.titleKey : null);
    if(!key) return;
    const current = state.iconLabels[ctxState.appId] || t(key);
    showInputDialog({
      titleKey: 'dialog.rename.title',
      descKey: 'dialog.rename.desc',
      value: current,
      confirmKey: 'dialog.rename.confirm',
      onConfirm: (val)=>{
        const next = String(val || '').trim();
        if(next){
          state.iconLabels[ctxState.appId] = next;
        } else {
          delete state.iconLabels[ctxState.appId];
        }
        saveIconLabels();
        renderIcons();
      }
    });
  }
  if(action === 'crop' && ctxState.target === 'icon' && ctxState.appId){
    showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
  }
  if(action === 'copy' && ctxState.target === 'icon' && ctxState.appId){
    const app = APPS.find(a => a.id === ctxState.appId);
    const label = app ? getIconLabel(app) : '';
    if(label){
      copyText(label).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
    } else {
      showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
    }
  }
  if(action === 'moveTrash' && ctxState.target === 'icon' && ctxState.appId){
    moveIconsToTrash([ctxState.appId]);
  }
  if(action === 'emptyTrash' && ctxState.target === 'icon' && ctxState.appId === 'trash'){
    emptyTrash();
  }
  if(action === 'arrange') arrangeIcons();
  if(action === 'grid'){
    state.gridSnap = !state.gridSnap;
    saveGridSnap();
    renderCtxMenu();
  }
  if(action === 'wallpaper'){
    openSettingsAndTab('appearance', 'settingsWallpaper');
  }
  if(action === 'settings') openApp('settings');
  if(action === 'language') toggleLang();
  if(action === 'about') openApp('about');
  if(action === 'logoff'){
    closeCtxMenu();
    closeStartMenu();
    doLogoff();
  }
}

// Long-press support (mobile/touch)
function installLongPress(el, getTarget){
  let timer = null;
  let start = null;
  const threshold = 8;
  const delay = 520;

  const clear = ()=>{
    if(timer){ clearTimeout(timer); timer = null; }
    start = null;
  };

  el.addEventListener('pointerdown', (e)=>{
    if(e.pointerType !== 'touch') return;
    start = { x:e.clientX, y:e.clientY };
    timer = setTimeout(()=>{
      const tgt = getTarget ? getTarget() : { target:'desktop', appId:null };
      openCtxMenu(e.clientX, e.clientY, tgt.target, tgt.appId);
      clear();
    }, delay);
  });

  el.addEventListener('pointermove', (e)=>{
    if(!start || !timer) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    if(Math.hypot(dx,dy) > threshold){
      clear();
    }
  });

  el.addEventListener('pointerup', clear);
  el.addEventListener('pointercancel', clear);
}

      const I18N = {
        en: {
          'login.sub': 'Enter your name to login',
          'login.labelName': 'Name:',
          'login.placeholder': 'Enter your name',
          'login.hint': 'Hint: Ignorance is BLISS',
          'login.clear': 'Clear',
          'login.enter': 'Enter',
          'login.copyright': ' BLISS / DIEV  Bliss 98 OS',

          'common.soon': 'Soon.',
          'common.ok': 'OK',
          'common.cancel': 'Cancel',
          'common.save': 'Save',
          'common.open': 'Open',
          'common.copy': 'Copy',

          'aria.language': 'Language',
          'aria.startMenu': 'BLISS Menu',
          'aria.contextMenu': 'Context menu',
          'aria.close': 'Close',
          'start.menu': 'Menu',

          'menubar.file': 'File',
          'menubar.edit': 'Edit',
          'menubar.view': 'View',
          'menubar.help': 'Help',

          'status.ready': 'Ready',

          'win.minimize': 'Minimize',
          'win.maximize': 'Fit to content',
          'win.close': 'Close',
          'win.resize': 'Resize',

          'app.clothes': 'Clothes',
          'app.music': 'Music',
          'app.art': 'Art',
          'app.games': 'Games',
          'app.videos': 'Videos',
          'app.about': 'About',
          'app.contact': 'Contact',
          'app.diev': 'DIEV',
          'app.settings': 'Settings',
          'app.poetry': 'Poetry',
          'app.trash': 'Recycle Bin',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.dopeSkate': 'Dope Skate',
          'games.back': 'Back',
          'games.empty': 'No games yet.',
          'games.tab.hub': 'Games',
          'games.tab.leaderboard': 'Leaderboard',
          'games.leaderboard.total': 'Total Score',
          'games.leaderboard.empty': 'No scores yet.',
          'skate.menu.play': 'Play',
          'skate.menu.settings': 'Settings',
          'skate.menu.shop': 'Shop',
          'skate.menu.howto': 'How to play',
          'skate.menu.leaderboard': 'Leaderboard',
          'skate.menu.playDesc': 'Skate away',
          'skate.action.start': 'Start run',
          'skate.action.retry': 'Retry',
          'skate.action.menu': 'Menu',
          'skate.action.resume': 'Resume',
          'skate.action.back': 'Back to menu',
          'skate.action.jump': 'Jump',
          'skate.action.trick1': 'Trick 1',
          'skate.action.trick2': 'Trick 2',
          'skate.action.trick3': 'Trick 3',
          'skate.hud.score': 'Score',
          'skate.hud.combo': 'Combo',
          'skate.hud.best': 'Best',
          'skate.hud.cds': 'CDs',
          'skate.gameOver': 'Game Over',
          'skate.grind.balance': 'Balance',
          'skate.settings.camera': 'Camera',
          'skate.settings.cameraDesc': 'Classic side view',
          'skate.settings.speed': 'Speed',
          'skate.settings.speedDesc': 'Auto runner',
          'skate.settings.difficulty': 'Difficulty',
          'skate.settings.difficultyEasy': 'Easy',
          'skate.settings.difficultyMedium': 'Medium',
          'skate.settings.difficultyHard': 'Hard',
          'skate.settings.sfx': 'Sound effects',
          'skate.settings.sfxOn': 'On',
          'skate.settings.sfxOff': 'Off',
          'skate.shop.ground': 'Ground',
          'skate.shop.background': 'Background',
          'skate.shop.sky': 'Sky',
          'skate.shop.skater': 'Skater',
          'skate.shop.hat': 'Hat',
          'skate.shop.board': 'Skate',
          'skate.shop.wheels': 'Wheels',
          'skate.shop.wallet': 'Wallet',
          'skate.shop.owned': 'Owned',
          'skate.shop.buy': 'Buy',
          'skate.shop.equip': 'Equip',
          'skate.shop.equipped': 'Equipped',
          'skate.shop.previewing': 'Previewing',
          'skate.shop.previewActive': 'Preview active',
          'skate.shop.previewNone': 'Use equipped',
          'skate.shop.useEquipped': 'Use equipped',
          'skate.howto.body': 'Jump, throw tricks in the air, and link combos before you land.',
          'skate.howto.controls': 'Controls',
          'skate.howto.controlsDesc': 'Jump: Space/Up/X. Tricks: Z/X/C or Square/Triangle/Circle.',
          'skate.howto.trick1': 'Trick 1',
          'skate.howto.trick1Desc': 'Kickflip in the air. Hold Left/Right for Heelflip.',
          'skate.howto.trick2': 'Trick 2',
          'skate.howto.trick2Desc': 'Shuv-it in the air. Hold Left/Right for Varial Kickflip.',
          'skate.howto.trick3': 'Trick 3',
          'skate.howto.trick3Desc': 'Hardflip in the air or on a grind.',
          'skate.howto.combo': 'Combos',
          'skate.howto.comboDesc': 'Tricks only count in air or grind. Chain tricks before landing to raise the multiplier.',
          'skate.howto.grind': 'Grinds',
          'skate.howto.grindDesc': 'Jump onto a rail, balance with Left/Right, and press Jump to exit.',
          'skate.leaderboard.body': 'Local and global records will show here.',
          'skate.leaderboard.local': 'Local best',
          'skate.leaderboard.global': 'Global best',
          'skate.over.base': 'Base',
          'skate.over.combo': 'Combo bonus',
          'skate.over.bliss': 'BLISS bonus',
          'skate.over.total': 'Total',
          'skate.over.cds': 'CDs',
          'skate.over.money': 'Money',
          'snake.title': 'Snake',
          'snake.start': 'Start',
          'snake.restart': 'Restart',
          'snake.pause': 'Pause',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Speed:',
          'snake.speed.slow': 'Slow',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Fast',
          'snake.instructions': 'Use arrow keys or WASD. On mobile, swipe.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Play again',

          'menu.logoff': 'Log off',

          'ctx.open': 'Open',
          'ctx.rename': 'Rename',
          'ctx.crop': 'Crop',
          'ctx.copy': 'Copy',
          'ctx.moveTrash': 'Move to Recycle Bin',
          'ctx.emptyTrash': 'Empty Recycle Bin',
          'ctx.arrange': 'Arrange icons',
          'ctx.grid': 'Grid (snap)',
          'ctx.wallpaper': 'Wallpaper',
          'ctx.settings': 'Settings',
          'ctx.language': 'Language',
          'ctx.about': 'About',
          'ctx.logoff': 'Log off',

          'settings.title': 'Settings',
          'settings.tab.general': 'General',
          'settings.tab.language': 'Language',
          'settings.tab.appearance': 'Appearance',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'System properties and preferences for BLISS 98.',
          'settings.general.user': 'User:',
          'settings.general.guest': 'Guest',
          'settings.general.version': 'Version:',
          'settings.general.registeredTo': 'Registered to:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Language',
          'settings.languageDesc': 'Choose your language for BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Portugus (BR)',
          'settings.appearanceTab': 'Appearance',
          'settings.appearanceDesc': 'Customize how BLISS 98 looks.',
          'settings.themes.title': 'Themes',
          'settings.themes.desc': 'Select a theme to change wallpaper, title color, and dark mode.',
          'settings.themes.current': 'Current theme:',
          'settings.titlebar.title': 'Window Title Color',
          'settings.titlebar.desc': 'Choose the color of the window title bars.',
          'settings.darkMode.title': 'Dark Mode',
          'settings.darkMode.desc': 'Makes BLISS 98 darker and easier on the eyes.',
          'settings.darkMode.on': 'On',
          'settings.darkMode.off': 'Off',
          'settings.retro.title': 'Retro Glow',
          'settings.retro.desc': 'Add a soft glow to windows and icons.',
          'settings.retro.on': 'On',
          'settings.retro.off': 'Off',
          'settings.animationsTab': 'Animations',
          'settings.animationsDesc': 'Toggle window animations.',
          'settings.animations.on': 'On',
          'settings.animations.off': 'Off',
          'settings.wallpaperTab': 'Wallpaper',
          'settings.wallpaperDesc': 'Choose a wallpaper for your desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Add scanline effect to the display.',
          'settings.scanlines.on': 'On',
          'settings.scanlines.off': 'Off',
          'titlebar.defaultBlue': 'Default Blue',
          'titlebar.pinkLight': 'Light Pink',
          'titlebar.purpleDark': 'Dark Purple',
          'titlebar.offWhite': 'Off-white',
          'titlebar.greenDark': 'Dark Green',
          'titlebar.redDark': 'Dark Red',
          'titlebar.blank': 'Blank',
          'titlebar.xpBlue': 'XP Blue',
          'theme.default': 'Default',
          'theme.totvers': 'Totvers',
          'theme.matrix': 'Matrix',
          'theme.xp98': 'XP98',
          'theme.blank': 'Blank',
          'theme.custom': 'Custom',
          'theme.customEmpty': 'Empty',
          'theme.save': 'Save Custom',
          'poetry.title': 'Poetry Library',
          'poetry.back': 'Back',
          'poetry.language': 'Language',
          'poetry.empty': 'No poems yet.',

          'menu.file.newWindow': 'New Window',
          'menu.file.close': 'Close',
          'menu.file.logoff': 'Log off',
          'menu.help.controls': 'Controls',
          'menu.help.about': 'About BLISS 98',

          'menu.music.openLink': 'Open Link',
          'menu.music.copyLink': 'Copy Link',
          'menu.music.selectAll': 'Select All',
          'menu.music.clearSelection': 'Clear Selection',
          'menu.music.tileSize': 'Tile size',
          'menu.music.tileSize.small': 'Small',
          'menu.music.tileSize.large': 'Large',
          'menu.music.openNewTab': 'Open in new tab (default)',
          'menu.music.showIcons': 'Show platform icons',
          'menu.music.where': 'Where to listen',

          'menu.player.openTrack': 'Open Track',
          'menu.player.reload': 'Reload Library',
          'menu.player.selectAll': 'Select All',
          'menu.player.copyName': 'Copy Track Name',
          'menu.player.clearSelection': 'Clear Selection',
          'menu.player.shuffle': 'Shuffle',
          'menu.player.repeat': 'Repeat',
          'menu.player.repeat.off': 'Off',
          'menu.player.repeat.one': 'One',
          'menu.player.repeat.all': 'All',
          'menu.player.showPlaylist': 'Show Playlist',
          'menu.player.compact': 'Compact mode',
          'menu.player.tips': 'Playback tips',
          'menu.player.howto': 'How to add songs',

          'menu.clothes.openLookbook': 'Open Lookbook',
          'menu.clothes.shop': 'Shop',
          'menu.clothes.copy': 'Copy',
          'menu.clothes.selectAll': 'Select All',
          'menu.clothes.viewGrid': 'Grid',
          'menu.clothes.sort': 'Sort by',
          'menu.clothes.sort.new': 'New',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Preview images',
          'menu.clothes.sizing': 'Sizing',

          'menu.diev.openPress': 'Open Press Kit',
          'menu.diev.copyBio': 'Copy Bio',
          'menu.diev.copy': 'Copy',
          'menu.diev.selectAll': 'Select All',
          'menu.diev.textSize': 'Text size',
          'menu.diev.textSize.small': 'Small',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Large',
          'menu.diev.highContrast': 'High contrast',
          'menu.diev.links': 'Links',

          'menu.contact.copyEmail': 'Copy Email',
          'menu.contact.openInstagram': 'Open Instagram',
          'menu.contact.copy': 'Copy',
          'menu.contact.selectAll': 'Select All',
          'menu.contact.showQr': 'Show QR',
          'menu.contact.compact': 'Compact',
          'menu.contact.support': 'Support',

          'menu.settings.apply': 'Apply',
          'menu.settings.reset': 'Reset to default',
          'menu.settings.undo': 'Undo',
          'menu.settings.redo': 'Redo',
          'menu.settings.fullscreen': 'Fullscreen',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Wallpaper',
          'menu.settings.what': 'What is this?',

          'menu.art.openGallery': 'Open Gallery',
          'menu.art.saveImage': 'Save Image',
          'menu.art.copy': 'Copy',
          'menu.art.selectAll': 'Select All',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Slideshow',
          'menu.art.credits': 'Credits',

          'menu.games.openFolder': 'Open Games Folder',
          'menu.games.download': 'Download',
          'menu.games.copy': 'Copy',
          'menu.games.selectAll': 'Select All',
          'menu.games.grid': 'Grid',
          'menu.games.sort': 'Sort by',
          'menu.games.sort.new': 'New',
          'menu.games.sort.favorite': 'Favorite',
          'menu.games.requirements': 'Requirements',

          'menu.videos.openChannel': 'Open Channel',
          'menu.videos.copyLink': 'Copy Link',
          'menu.videos.copy': 'Copy',
          'menu.videos.selectAll': 'Select All',
          'menu.videos.thumbSize': 'Thumbnail size',
          'menu.videos.thumbSize.small': 'Small',
          'menu.videos.thumbSize.large': 'Large',
          'menu.videos.openNewTab': 'Open in new tab',
          'menu.videos.tips': 'Playback tips',
          'videos.channelLink': 'YouTube: @DIEVBLISS',
          'videos.watchTitle': 'Watch inside BLISS 98',
          'videos.openChannel': 'Watch channel videos',
          'videos.addKey': 'Add YouTube API Key',
          'videos.noKey': 'Add a YouTube API key to load the full list. You can still watch here.',
          'videos.autoFail': 'Unable to load videos automatically. You can still open the channel.',
          'videos.loading': 'Loading videos',
          'videos.listEmpty': 'No videos yet.',
          'videos.keyTitle': 'YouTube API Key',
          'videos.keyDesc': 'Paste your YouTube Data API v3 key to load the channel videos.',

          'menu.about.copy': 'Copy',
          'menu.about.selectAll': 'Select All',
          'menu.about.version': 'Version info',
          'menu.about.credits': 'Credits',
          'menu.about.controls': 'Controls',

          'dialog.newWindow.title': 'New Window',
          'dialog.newWindow.desc': 'Choose an app to open.',
          'dialog.newWindow.open': 'Open',
          'dialog.openLink.title': 'Open Link',
          'dialog.openLink.desc': 'Choose a platform.',
          'dialog.openLink.open': 'Open',
          'dialog.openTrack.title': 'Open Track',
          'dialog.openTrack.desc': 'Choose a track from the playlist.',
          'dialog.openTrack.open': 'Open',
          'dialog.controls.title': 'Controls',
          'dialog.controls.body': 'Drag windows by the title bar. Resize from the corner. Right-click or long-press the desktop for options.',
          'dialog.where.title': 'Where to listen',
          'dialog.where.body': 'These are official BLISS links. Pick a platform to open or copy the link.',
          'dialog.playerTips.title': 'Playback tips',
          'dialog.playerTips.body': 'Autoplay may be blocked. If it does not start, press Play once.',
          'dialog.support.title': 'Support',
          'dialog.support.body': 'Report issues through the Contact window when available. We will keep the system updated.',
          'dialog.settingsWhat.title': 'Settings',
          'dialog.settingsWhat.body': 'Adjust language, wallpaper, and window animations for BLISS 98.',
          'dialog.version.title': 'Version info',
          'dialog.version.body': 'BLISS 98  Build 98.0',
          'dialog.credits.title': 'Credits',
          'dialog.credits.body': 'Created by DIEV.',
          'dialog.notAvailable.title': 'Coming soon',
          'dialog.notAvailable.body': 'This feature is not available yet.',
          'dialog.selectItem.title': 'Select an item',
          'dialog.selectItem.body': 'Select an item first to continue.',
          'dialog.copied.title': 'Copied',
          'dialog.copied.body': 'Copied to clipboard.',
          'dialog.settingsApplied.title': 'Settings',
          'dialog.settingsApplied.body': 'Settings applied.',
          'dialog.noUndo.title': 'Undo',
          'dialog.noUndo.body': 'Nothing to undo.',
          'dialog.noRedo.title': 'Redo',
          'dialog.noRedo.body': 'Nothing to redo.',
          'dialog.rename.title': 'Rename',
          'dialog.rename.desc': 'Enter a new name.',
          'dialog.rename.confirm': 'Rename',
          'dialog.loginEmpty.title': 'Enter your name',
          'dialog.loginEmpty.body': 'Please type a name to continue.',
          'dialog.trash.empty': 'Recycle Bin is empty.',
          'dialog.trash.restore': 'Restore',
          'dialog.trash.restoreAll': 'Restore All',
          'dialog.trash.emptyAction': 'Empty Recycle Bin',

          'wallpaper.classic': 'Classic Teal',
          'wallpaper.bliss': 'Sunrise',
          'wallpaper.clouds': 'Clouds',
          'wallpaper.diev': 'Grid',
          'wallpaper.tot': 'Tot (Pink)',
          'wallpaper.matrix': 'Matrix',
          'wallpaper.xp98bliss': 'XP Bliss 98',

          'music.title': 'BLISS  Music',
          'music.subtitle': 'Listen everywhere:',
          'music.tip': 'Music is a beautiful thing, innit?',

          'clothes.title': 'BLISS  Clothes',
          'clothes.subtitle': 'Latest from Instagram.',
          'clothes.loading': 'Loading',
          'clothes.unavailable': 'Unable to load right now.',
          'clothes.thumbAlt': 'BLISS Instagram',

          'about.title': 'About',
          'about.p1': 'BLISS is a project that aims to bring together independent, weird, and unique artists,',
          'about.p2': 'supporting every form of art and self-expression.',
          'about.p3': 'Against the system and the dogmas created by humans,',
          'about.p4': 'we are our own GODS.',
          'about.p5': 'There are no rules.',
          'about.p6': 'We create our own world from the inside out.',
          'about.footer': 'Designed By DIEV',

          'contact.title': 'Contact',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Official page for DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Now playing:',
          'player.play': 'Play',
          'player.pause': 'Pause',
          'player.prev': 'Prev',
          'player.next': 'Next',
          'player.vol': 'Vol',
          'player.shuffle': 'Shuffle',
          'player.repeat': 'Repeat',
          'player.repeat.off': 'Off',
          'player.repeat.one': 'One',
          'player.repeat.all': 'All',
          'player.loading': 'Loading tracks',
          'player.notfound': 'No songs yet.',
          'player.autoplay': 'Autoplay may be blocked by your browser. If it does not start, press Play.',
          'player.addSongs': 'Add songs',
          'player.reimport': 'Re-import files',
          'player.reimportHint': 'Re-import files to restore your playlist.',
          'player.drop': 'Drop audio files here',
          'player.flacUnsupported': 'Your browser does not support FLAC. Use MP3/WAV/OGG or another browser.',
          'dialog.playerHowTo.title': 'How to add songs',
          'dialog.playerHowTo.body': 'Add songs by dragging audio files into the player window, or click Add songs to choose files.'
        },
        pt: {
          'login.sub': 'Digite seu nome para entrar',
          'login.labelName': 'Nome:',
          'login.placeholder': 'Digite seu nome',
          'login.hint': 'Dica: Ignorncia  BLISS',
          'login.clear': 'Limpar',
          'login.enter': 'Entrar',
          'login.copyright': ' BLISS / DIEV  Bliss 98 OS',

          'common.soon': 'Em breve.',
          'common.ok': 'OK',
          'common.cancel': 'Cancelar',
          'common.save': 'Salvar',
          'common.open': 'Abrir',
          'common.copy': 'Copiar',

          'aria.language': 'Idioma',
          'aria.startMenu': 'Menu BLISS',
          'aria.contextMenu': 'Menu de contexto',
          'aria.close': 'Fechar',
          'start.menu': 'Menu',

          'menubar.file': 'Arquivo',
          'menubar.edit': 'Editar',
          'menubar.view': 'Exibir',
          'menubar.help': 'Ajuda',

          'status.ready': 'Pronto',

          'win.minimize': 'Minimizar',
          'win.maximize': 'Ajustar ao contedo',
          'win.close': 'Fechar',
          'win.resize': 'Redimensionar',

          'app.clothes': 'Roupas',
          'app.music': 'Msica',
          'app.art': 'Arte',
          'app.games': 'Jogos',
          'app.videos': 'Vdeos',
          'app.about': 'Sobre',
          'app.contact': 'Contato',
          'app.diev': 'DIEV',
          'app.settings': 'Configuraes',
          'app.poetry': 'Poesias',
          'app.trash': 'Lixeira',
          'app.mediaplayer': 'BLISS Media Player',
          'games.snake': 'Snake',
          'games.dopeSkate': 'Dope Skate',
          'games.back': 'Voltar',
          'games.empty': 'Sem jogos ainda.',
          'games.tab.hub': 'Jogos',
          'games.tab.leaderboard': 'Leaderboard',
          'games.leaderboard.total': 'Score total',
          'games.leaderboard.empty': 'Sem scores ainda.',
          'skate.menu.play': 'Jogar',
          'skate.menu.settings': 'Configuraes',
          'skate.menu.shop': 'Shop',
          'skate.menu.howto': 'Como jogar',
          'skate.menu.leaderboard': 'Leaderboard',
          'skate.menu.playDesc': 'Skate away',
          'skate.action.start': 'Iniciar run',
          'skate.action.retry': 'Tentar de novo',
          'skate.action.menu': 'Menu',
          'skate.action.resume': 'Voltar ao jogo',
          'skate.action.back': 'Voltar ao menu',
          'skate.action.jump': 'Pular',
          'skate.action.trick1': 'Trick 1',
          'skate.action.trick2': 'Trick 2',
          'skate.action.trick3': 'Trick 3',
          'skate.hud.score': 'Score',
          'skate.hud.combo': 'Combo',
          'skate.hud.best': 'Recorde',
          'skate.hud.cds': 'CDs',
          'skate.gameOver': 'Game Over',
          'skate.grind.balance': 'Equilibrio',
          'skate.settings.difficulty': 'Dificuldade',
          'skate.settings.difficultyEasy': 'Fcil',
          'skate.settings.difficultyMedium': 'Mdia',
          'skate.settings.difficultyHard': 'Difcil',
          'skate.settings.sfx': 'Efeitos sonoros',
          'skate.settings.sfxOn': 'Ligado',
          'skate.settings.sfxOff': 'Desligado',
          'skate.shop.ground': 'Chao',
          'skate.shop.background': 'Fundo',
          'skate.shop.sky': 'Ceu',
          'skate.shop.skater': 'Skater',
          'skate.shop.hat': 'Chapeu',
          'skate.shop.board': 'Skate',
          'skate.shop.wheels': 'Rodas',
          'skate.shop.wallet': 'Carteira',
          'skate.shop.owned': 'Comprado',
          'skate.shop.buy': 'Comprar',
          'skate.shop.equip': 'Equipar',
          'skate.shop.equipped': 'Equipado',
          'skate.shop.previewing': 'Preview',
          'skate.shop.previewActive': 'Preview ativo',
          'skate.shop.previewNone': 'Usar equipado',
          'skate.shop.useEquipped': 'Usar equipado',
          'skate.howto.body': 'Pule, mande tricks no ar e mantenha o combo antes de aterrissar.',
          'skate.howto.controls': 'Controles',
          'skate.howto.controlsDesc': 'Pulo: Espaco/Seta cima/X. Tricks: Z/X/C ou Quadrado/Triangulo/Circulo.',
          'skate.howto.trick1': 'Trick 1',
          'skate.howto.trick1Desc': 'Kickflip no ar. Segure Esquerda/Direita para Heelflip.',
          'skate.howto.trick2': 'Trick 2',
          'skate.howto.trick2Desc': 'Shuv-it no ar. Segure Esquerda/Direita para Varial Kickflip.',
          'skate.howto.trick3': 'Trick 3',
          'skate.howto.trick3Desc': 'Hardflip no ar ou no grind.',
          'skate.howto.combo': 'Combos',
          'skate.howto.comboDesc': 'Tricks so contam no ar ou no grind. Encadeie antes de aterrissar para subir o multiplicador.',
          'skate.howto.grind': 'Grinds',
          'skate.howto.grindDesc': 'Pule em um rail, equilibre com Esquerda/Direita e aperte Pulo para sair.',
          'skate.leaderboard.body': 'Records locais e globais aparecem aqui.',
          'skate.leaderboard.local': 'Recorde local',
          'skate.leaderboard.global': 'Recorde global',
          'skate.over.base': 'Base',
          'skate.over.combo': 'Bonus combo',
          'skate.over.bliss': 'Bonus BLISS',
          'skate.over.total': 'Total',
          'skate.over.cds': 'CDs',
          'skate.over.money': 'Dinheiro',
          'snake.title': 'Snake',
          'snake.start': 'Iniciar',
          'snake.restart': 'Reiniciar',
          'snake.pause': 'Pausar',
          'snake.score': 'Score:',
          'snake.highScore': 'High Score:',
          'snake.speed': 'Velocidade:',
          'snake.speed.slow': 'Lento',
          'snake.speed.normal': 'Normal',
          'snake.speed.fast': 'Rpido',
          'snake.instructions': 'Use as setas ou WASD. No celular, deslize.',
          'snake.gameOver': 'Game Over',
          'snake.playAgain': 'Jogar novamente',

          'menu.logoff': 'Sair',

          'ctx.open': 'Abrir',
          'ctx.rename': 'Renomear',
          'ctx.crop': 'Recortar',
          'ctx.copy': 'Copiar',
          'ctx.moveTrash': 'Mover para a Lixeira',
          'ctx.emptyTrash': 'Esvaziar Lixeira',
          'ctx.arrange': 'Organizar cones',
          'ctx.grid': 'Grade (snap)',
          'ctx.wallpaper': 'Plano de Fundo',
          'ctx.settings': 'Configuraes',
          'ctx.language': 'Idioma',
          'ctx.about': 'Sobre',
          'ctx.logoff': 'Sair',

          'settings.title': 'Configuraes',
          'settings.tab.general': 'Geral',
          'settings.tab.language': 'Idioma',
          'settings.tab.appearance': 'Aparncia',
          'settings.tab.performance': 'Performance',
          'settings.general.title': 'BLISS 98',
          'settings.general.desc': 'Propriedades e ajustes do BLISS 98.',
          'settings.general.user': 'Usurio:',
          'settings.general.guest': 'Convidado',
          'settings.general.version': 'Verso:',
          'settings.general.registeredTo': 'Registrado para:',
          'settings.general.registeredName': 'A Bad Motherfucker',
          'settings.general.registeredCode': '616-FTP-420-333',
          'settings.languageTab': 'Idioma',
          'settings.languageDesc': 'Escolha o idioma do BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Portugus (BR)',
          'settings.appearanceTab': 'Aparncia',
          'settings.appearanceDesc': 'Personalize o visual do BLISS 98.',
          'settings.themes.title': 'Temas',
          'settings.themes.desc': 'Selecione um tema para mudar papel de parede, cor do topo e dark mode.',
          'settings.themes.current': 'Tema atual:',
          'settings.titlebar.title': 'Cor do topo da janela',
          'settings.titlebar.desc': 'Escolha a cor das barras de ttulo.',
          'settings.darkMode.title': 'Modo Escuro',
          'settings.darkMode.desc': 'Deixa o BLISS 98 mais escuro e confortvel.',
          'settings.darkMode.on': 'Ligado',
          'settings.darkMode.off': 'Desligado',
          'settings.retro.title': 'Brilho Retro',
          'settings.retro.desc': 'Adicione um brilho suave nas janelas e cones.',
          'settings.retro.on': 'Ligado',
          'settings.retro.off': 'Desligado',
          'settings.animationsTab': 'Animaes',
          'settings.animationsDesc': 'Ative ou desative as animaes das janelas.',
          'settings.animations.on': 'Ligado',
          'settings.animations.off': 'Desligado',
          'settings.wallpaperTab': 'Papel de parede',
          'settings.wallpaperDesc': 'Escolha um papel de parede para o desktop.',
          'settings.scanlinesTab': 'Scanlines',
          'settings.scanlinesDesc': 'Adicione efeito de scanlines na tela.',
          'settings.scanlines.on': 'Ligado',
          'settings.scanlines.off': 'Desligado',
          'titlebar.defaultBlue': 'Azul padro',
          'titlebar.pinkLight': 'Rosa claro',
          'titlebar.purpleDark': 'Roxo escuro',
          'titlebar.offWhite': 'Branco off-white',
          'titlebar.greenDark': 'Verde escuro',
          'titlebar.redDark': 'Vermelho escuro',
          'titlebar.blank': 'Vazio',
          'titlebar.xpBlue': 'Azul XP',
          'theme.default': 'Padro',
          'theme.totvers': 'Totvers',
          'theme.matrix': 'Matrix',
          'theme.xp98': 'XP98',
          'theme.blank': 'Vazio',
          'theme.custom': 'Personalizado',
          'theme.customEmpty': 'Vazio',
          'theme.save': 'Salvar personalizado',
          'poetry.title': 'Biblioteca de Poesias',
          'poetry.back': 'Voltar',
          'poetry.language': 'Idioma',
          'poetry.empty': 'Sem poesias ainda.',

          'menu.file.newWindow': 'Nova janela',
          'menu.file.close': 'Fechar',
          'menu.file.logoff': 'Sair',
          'menu.help.controls': 'Controles',
          'menu.help.about': 'Sobre BLISS 98',

          'menu.music.openLink': 'Abrir link',
          'menu.music.copyLink': 'Copiar link',
          'menu.music.selectAll': 'Selecionar tudo',
          'menu.music.clearSelection': 'Limpar seleo',
          'menu.music.tileSize': 'Tamanho dos cards',
          'menu.music.tileSize.small': 'Pequeno',
          'menu.music.tileSize.large': 'Grande',
          'menu.music.openNewTab': 'Abrir em nova aba (padro)',
          'menu.music.showIcons': 'Mostrar cones',
          'menu.music.where': 'Onde ouvir',

          'menu.player.openTrack': 'Abrir faixa',
          'menu.player.reload': 'Recarregar biblioteca',
          'menu.player.selectAll': 'Selecionar tudo',
          'menu.player.copyName': 'Copiar nome da faixa',
          'menu.player.clearSelection': 'Limpar seleo',
          'menu.player.shuffle': 'Aleatrio',
          'menu.player.repeat': 'Repetir',
          'menu.player.repeat.off': 'Desligado',
          'menu.player.repeat.one': 'Uma',
          'menu.player.repeat.all': 'Todas',
          'menu.player.showPlaylist': 'Mostrar playlist',
          'menu.player.compact': 'Modo compacto',
          'menu.player.tips': 'Dicas de reproduo',
          'menu.player.howto': 'Como adicionar msicas',

          'menu.clothes.openLookbook': 'Abrir lookbook',
          'menu.clothes.shop': 'Loja',
          'menu.clothes.copy': 'Copiar',
          'menu.clothes.selectAll': 'Selecionar tudo',
          'menu.clothes.viewGrid': 'Grade',
          'menu.clothes.sort': 'Ordenar por',
          'menu.clothes.sort.new': 'Novidades',
          'menu.clothes.sort.popular': 'Popular',
          'menu.clothes.preview': 'Pr-visualizar',
          'menu.clothes.sizing': 'Tamanhos',

          'menu.diev.openPress': 'Abrir press kit',
          'menu.diev.copyBio': 'Copiar bio',
          'menu.diev.copy': 'Copiar',
          'menu.diev.selectAll': 'Selecionar tudo',
          'menu.diev.textSize': 'Tamanho do texto',
          'menu.diev.textSize.small': 'Pequeno',
          'menu.diev.textSize.normal': 'Normal',
          'menu.diev.textSize.large': 'Grande',
          'menu.diev.highContrast': 'Alto contraste',
          'menu.diev.links': 'Links oficiais',

          'menu.contact.copyEmail': 'Copiar e-mail',
          'menu.contact.openInstagram': 'Abrir Instagram',
          'menu.contact.copy': 'Copiar',
          'menu.contact.selectAll': 'Selecionar tudo',
          'menu.contact.showQr': 'Mostrar QR',
          'menu.contact.compact': 'Compacto',
          'menu.contact.support': 'Suporte',

          'menu.settings.apply': 'Aplicar',
          'menu.settings.reset': 'Restaurar padro',
          'menu.settings.undo': 'Desfazer',
          'menu.settings.redo': 'Refazer',
          'menu.settings.fullscreen': 'Tela cheia',
          'menu.settings.scanlines': 'Scanlines',
          'menu.settings.wallpaper': 'Papel de parede',
          'menu.settings.what': 'O que  isso?',

          'menu.art.openGallery': 'Abrir galeria',
          'menu.art.saveImage': 'Salvar imagem',
          'menu.art.copy': 'Copiar',
          'menu.art.selectAll': 'Selecionar tudo',
          'menu.art.zoom': 'Zoom',
          'menu.art.zoom.50': '50%',
          'menu.art.zoom.100': '100%',
          'menu.art.zoom.200': '200%',
          'menu.art.slideshow': 'Apresentao',
          'menu.art.credits': 'Crditos',

          'menu.games.openFolder': 'Abrir pasta de jogos',
          'menu.games.download': 'Download',
          'menu.games.copy': 'Copiar',
          'menu.games.selectAll': 'Selecionar tudo',
          'menu.games.grid': 'Grade',
          'menu.games.sort': 'Ordenar por',
          'menu.games.sort.new': 'Novidades',
          'menu.games.sort.favorite': 'Favorito',
          'menu.games.requirements': 'Requisitos',

          'menu.videos.openChannel': 'Abrir canal',
          'menu.videos.copyLink': 'Copiar link',
          'menu.videos.copy': 'Copiar',
          'menu.videos.selectAll': 'Selecionar tudo',
          'menu.videos.thumbSize': 'Tamanho das miniaturas',
          'menu.videos.thumbSize.small': 'Pequeno',
          'menu.videos.thumbSize.large': 'Grande',
          'menu.videos.openNewTab': 'Abrir em nova aba',
          'menu.videos.tips': 'Dicas',
          'videos.channelLink': 'YouTube: @DIEVBLISS',
          'videos.watchTitle': 'Assista no BLISS 98',
          'videos.openChannel': 'Assistir vdeos do canal',
          'videos.addKey': 'Adicionar chave da API do YouTube',
          'videos.noKey': 'Adicione uma chave da API do YouTube para carregar a lista completa. Ainda d para assistir por aqui.',
          'videos.autoFail': 'No foi possvel carregar os vdeos automaticamente. Voc ainda pode abrir o canal.',
          'videos.loading': 'Carregando vdeos',
          'videos.listEmpty': 'Ainda no h vdeos.',
          'videos.keyTitle': 'Chave da API do YouTube',
          'videos.keyDesc': 'Cole sua chave da API do YouTube Data v3 para carregar os vdeos do canal.',

          'menu.about.copy': 'Copiar',
          'menu.about.selectAll': 'Selecionar tudo',
          'menu.about.version': 'Informaes da verso',
          'menu.about.credits': 'Crditos',
          'menu.about.controls': 'Controles',

          'dialog.newWindow.title': 'Nova janela',
          'dialog.newWindow.desc': 'Escolha um app para abrir.',
          'dialog.newWindow.open': 'Abrir',
          'dialog.openLink.title': 'Abrir link',
          'dialog.openLink.desc': 'Escolha uma plataforma.',
          'dialog.openLink.open': 'Abrir',
          'dialog.openTrack.title': 'Abrir faixa',
          'dialog.openTrack.desc': 'Escolha uma faixa da playlist.',
          'dialog.openTrack.open': 'Abrir',
          'dialog.controls.title': 'Controles',
          'dialog.controls.body': 'Arraste a janela pela barra de ttulo. Redimensione pelo canto. Clique com o boto direito ou pressione e segure no desktop para opes.',
          'dialog.where.title': 'Onde ouvir',
          'dialog.where.body': 'Estes so links oficiais da BLISS. Escolha uma plataforma para abrir ou copiar.',
          'dialog.playerTips.title': 'Dicas de reproduo',
          'dialog.playerTips.body': 'O autoplay pode ser bloqueado. Se no tocar, aperte Play uma vez.',
          'dialog.support.title': 'Suporte',
          'dialog.support.body': 'Reporte problemas pela janela de Contato quando estiver disponvel. Vamos manter o sistema atualizado.',
          'dialog.settingsWhat.title': 'Configuraes',
          'dialog.settingsWhat.body': 'Ajuste idioma, papel de parede e animaes das janelas do BLISS 98.',
          'dialog.version.title': 'Informaes da verso',
          'dialog.version.body': 'BLISS 98  Build 98.0',
          'dialog.credits.title': 'Crditos',
          'dialog.credits.body': 'Criado por DIEV.',
          'dialog.notAvailable.title': 'Em breve',
          'dialog.notAvailable.body': 'Este recurso ainda no est disponvel.',
          'dialog.selectItem.title': 'Selecione um item',
          'dialog.selectItem.body': 'Selecione um item para continuar.',
          'dialog.copied.title': 'Copiado',
          'dialog.copied.body': 'Copiado para a rea de transferncia.',
          'dialog.settingsApplied.title': 'Configuraes',
          'dialog.settingsApplied.body': 'Configuraes aplicadas.',
          'dialog.noUndo.title': 'Desfazer',
          'dialog.noUndo.body': 'Nada para desfazer.',
          'dialog.noRedo.title': 'Refazer',
          'dialog.noRedo.body': 'Nada para refazer.',
          'dialog.rename.title': 'Renomear',
          'dialog.rename.desc': 'Digite um novo nome.',
          'dialog.rename.confirm': 'Renomear',
          'dialog.loginEmpty.title': 'Digite seu nome',
          'dialog.loginEmpty.body': 'Digite um nome para continuar.',
          'dialog.trash.empty': 'A lixeira est vazia.',
          'dialog.trash.restore': 'Restaurar',
          'dialog.trash.restoreAll': 'Restaurar tudo',
          'dialog.trash.emptyAction': 'Esvaziar Lixeira',

          'wallpaper.classic': 'Teal clssico',
          'wallpaper.bliss': 'Nascer do Sol',
          'wallpaper.clouds': 'Nuvens',
          'wallpaper.diev': 'Grid',
          'wallpaper.tot': 'Tot (Rosa)',
          'wallpaper.matrix': 'Matrix',
          'wallpaper.xp98bliss': 'XP Bliss 98',

          'music.title': 'BLISS  Msica',
          'music.subtitle': 'Oua em todas as plataformas:',
          'music.tip': 'Msica  uma coisa linda, no ?',

          'clothes.title': 'BLISS  Roupas',
          'clothes.subtitle': 'ltimos do Instagram.',
          'clothes.loading': 'Carregando',
          'clothes.unavailable': 'No foi possvel carregar agora.',
          'clothes.thumbAlt': 'Instagram da BLISS',

          'about.title': 'Sobre',
          'about.p1': 'BLISS  um projeto que visa unir artistas independentes, estranhos e nicos,',
          'about.p2': 'apoiando toda forma de arte e autoexpresso.',
          'about.p3': 'Contra o sistema e os dogmas criados por humanos,',
          'about.p4': 'ns somos nossos prprios DEUSES.',
          'about.p5': 'No existem regras.',
          'about.p6': 'Ns criamos o nosso prprio mundo de dentro para fora.',
          'about.footer': 'Design by DIEV',

          'contact.title': 'Contato',
          'contact.label.instagramDIEV': 'Instagram (DIEV):',
          'contact.label.twitterDIEV': 'Twitter/X (DIEV):',
          'contact.label.emailBusiness': 'Email (Business):',
          'contact.label.instagramBLISS': 'Instagram (BLISS):',
          'diev.title': 'DIEV',
          'diev.p1': 'Pgina oficial do DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Tocando:',
          'player.play': 'Play',
          'player.pause': 'Pausar',
          'player.prev': 'Anterior',
          'player.next': 'Prxima',
          'player.vol': 'Vol',
          'player.shuffle': 'Aleatrio',
          'player.repeat': 'Repetir',
          'player.repeat.off': 'Desligado',
          'player.repeat.one': 'Uma',
          'player.repeat.all': 'Todas',
          'player.loading': 'Carregando msicas',
          'player.notfound': 'Sem msicas ainda.',
          'player.autoplay': 'O autoplay pode ser bloqueado. Se no tocar, aperte Play.',
          'player.addSongs': 'Adicionar msicas',
          'player.reimport': 'Reimportar arquivos',
          'player.reimportHint': 'Reimporte os arquivos para restaurar sua playlist.',
          'player.drop': 'Solte arquivos de udio aqui',
          'player.flacUnsupported': 'Seu navegador no suporta FLAC. Use MP3/WAV/OGG ou outro navegador.',
          'dialog.playerHowTo.title': 'Como adicionar msicas',
          'dialog.playerHowTo.body': 'Adicione msicas arrastando arquivos de udio para a janela do player, ou clique em Adicionar msicas para escolher arquivos.'
        }
      };

      function t(key){
        return (I18N[state.lang] && I18N[state.lang][key]) || (I18N.en && I18N.en[key]) || key;
      }

      function applyI18nTo(root){
        // text nodes
        $$('[data-i18n]', root).forEach(el => {
          const key = el.getAttribute('data-i18n');
          if(key) el.textContent = t(key);
        });
        // titles
        $$('[data-i18n-title]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-title');
          if(key) el.setAttribute('title', t(key));
        });
        // aria labels
        $$('[data-i18n-aria]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-aria');
          if(key) el.setAttribute('aria-label', t(key));
        });
        // placeholders
        $$('[data-i18n-placeholder]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-placeholder');
          if(key) el.setAttribute('placeholder', t(key));
        });
        updateWallpaperButtons(root);
        updateAnimationButtons(root);
        updateDarkModeButtons(root);
        updateTitlebarButtons(root);
        updateThemeButtons(root);
        updateThemeThumbs(root);
        updateRetroGlowButtons(root);
      }

      function applyI18n(){
        applyI18nTo(document);

        // Update language button label
        const lb = $('#langBtn');
        if(lb) lb.textContent = state.lang.toUpperCase();

        // Re-render desktop UI labels
        renderIcons();
        renderStartMenu();
        updateOpenWindowTitles();
        renderTaskButtons();
        renderCtxMenu();
        updateSnakeUI();
        mpRender();
      }

      function setLang(lang){
        state.lang = (lang === 'pt') ? 'pt' : 'en';
        localStorage.setItem('bliss98_lang', state.lang);
        applyI18n();
      }

      function toggleLang(){
        setLang(state.lang === 'en' ? 'pt' : 'en');
      }

      function getWindowId(winEl){
        if(!winEl || !winEl.id) return null;
        return winEl.id.replace('win_', '');
      }

      function renderMenuItems(items){
        return items.map(item => {
          if(item.type === 'sep') return '<div class="menu-sep"></div>';
          const label = t(item.labelKey);
          const checkMark = item.type === 'radio' ? '' : '';
          const check = item.checked ? checkMark : '';
          const left = `<span class="menu-left"><span class="menu-check">${check}</span><span>${label}</span></span>`;
          if(item.type === 'submenu'){
            return `
              <div class="menu-item has-sub" tabindex="0">
                ${left}
                <span class="menu-right"></span>
                <div class="menu-sub">
                  ${renderMenuItems(item.items)}
                </div>
              </div>
            `;
          }
          const actionAttr = item.action ? `data-menu-action="${item.action}"` : '';
          const right = item.right ? `<span class="menu-right">${item.right}</span>` : '<span class="menu-right"></span>';
          return `
            <button class="menu-item" type="button" ${actionAttr}>
              ${left}
              ${right}
            </button>
          `;
        }).join('');
      }

      function getMenuItems(appId, menuKey){
        const items = [];
        const addSep = () => { if(items.length && items[items.length-1].type !== 'sep') items.push({ type:'sep' }); };

        if(menuKey === 'file'){
          items.push({ labelKey:'menu.file.newWindow', action:'global:newWindow' });
          addSep();
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.openLink', action:'music:openLink' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.openTrack', action:'player:openTrack' });
            items.push({ labelKey:'menu.player.reload', action:'player:reload' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.openLookbook', action:'clothes:openLookbook' });
            items.push({ labelKey:'menu.clothes.shop', action:'clothes:shop' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.openPress', action:'diev:openPress' });
            items.push({ labelKey:'menu.diev.copyBio', action:'diev:copyBio' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copyEmail', action:'contact:copyEmail' });
            items.push({ labelKey:'menu.contact.openInstagram', action:'contact:openInstagram' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.apply', action:'settings:apply' });
            items.push({ labelKey:'menu.settings.reset', action:'settings:reset' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.openGallery', action:'art:openGallery' });
            items.push({ labelKey:'menu.art.saveImage', action:'art:saveImage' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.openFolder', action:'games:openFolder' });
            items.push({ labelKey:'menu.games.download', action:'games:download' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.openChannel', action:'videos:openChannel' });
            items.push({ labelKey:'menu.videos.copyLink', action:'videos:copyLink' });
          }
          addSep();
          items.push({ labelKey:'menu.file.close', action:'global:close' });
          items.push({ labelKey:'menu.file.logoff', action:'global:logoff' });
        }

        if(menuKey === 'edit'){
          if(appId === 'music'){
            items.push({ labelKey:'menu.music.selectAll', action:'music:selectAll' });
            items.push({ labelKey:'menu.music.copyLink', action:'music:copyLink' });
            items.push({ labelKey:'menu.music.clearSelection', action:'music:clearSelection' });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.selectAll', action:'player:selectAll' });
            items.push({ labelKey:'menu.player.copyName', action:'player:copyName' });
            items.push({ labelKey:'menu.player.clearSelection', action:'player:clearSelection' });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.copy', action:'clothes:copy' });
            items.push({ labelKey:'menu.clothes.selectAll', action:'clothes:selectAll' });
          }
          if(appId === 'diev'){
            items.push({ labelKey:'menu.diev.copy', action:'diev:copy' });
            items.push({ labelKey:'menu.diev.selectAll', action:'diev:selectAll' });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.copy', action:'contact:copy' });
            items.push({ labelKey:'menu.contact.selectAll', action:'contact:selectAll' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.undo', action:'settings:undo' });
            items.push({ labelKey:'menu.settings.redo', action:'settings:redo' });
          }
          if(appId === 'art'){
            items.push({ labelKey:'menu.art.copy', action:'art:copy' });
            items.push({ labelKey:'menu.art.selectAll', action:'art:selectAll' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.copy', action:'games:copy' });
            items.push({ labelKey:'menu.games.selectAll', action:'games:selectAll' });
          }
          if(appId === 'videos'){
            items.push({ labelKey:'menu.videos.copy', action:'videos:copy' });
            items.push({ labelKey:'menu.videos.selectAll', action:'videos:selectAll' });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.copy', action:'about:copy' });
            items.push({ labelKey:'menu.about.selectAll', action:'about:selectAll' });
          }
        }

        if(menuKey === 'view'){
          if(appId === 'music'){
            items.push({
              type:'submenu',
              labelKey:'menu.music.tileSize',
              items:[
                { labelKey:'menu.music.tileSize.small', action:'music:tileSmall', type:'radio', checked: state.music.tileSize === 'small' },
                { labelKey:'menu.music.tileSize.large', action:'music:tileLarge', type:'radio', checked: state.music.tileSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.music.openNewTab', action:'music:toggleNewTab', type:'checkbox', checked: state.music.openNewTab });
            items.push({ labelKey:'menu.music.showIcons', action:'music:toggleIcons', type:'checkbox', checked: state.music.showIcons });
          }
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.shuffle', action:'player:toggleShuffle', type:'checkbox', checked: state.mediaplayer.shuffle });
            items.push({
              type:'submenu',
              labelKey:'menu.player.repeat',
              items:[
                { labelKey:'menu.player.repeat.off', action:'player:repeatOff', type:'radio', checked: state.mediaplayer.repeat === 'off' },
                { labelKey:'menu.player.repeat.one', action:'player:repeatOne', type:'radio', checked: state.mediaplayer.repeat === 'one' },
                { labelKey:'menu.player.repeat.all', action:'player:repeatAll', type:'radio', checked: state.mediaplayer.repeat === 'all' }
              ]
            });
            items.push({ labelKey:'menu.player.showPlaylist', action:'player:togglePlaylist', type:'checkbox', checked: state.mediaplayer.showPlaylist });
            items.push({ labelKey:'menu.player.compact', action:'player:toggleCompact', type:'checkbox', checked: state.mediaplayer.compact });
          }
          if(appId === 'clothes'){
            items.push({ labelKey:'menu.clothes.viewGrid', action:'clothes:viewGrid' });
            items.push({
              type:'submenu',
              labelKey:'menu.clothes.sort',
              items:[
                { labelKey:'menu.clothes.sort.new', action:'clothes:sortNew' },
                { labelKey:'menu.clothes.sort.popular', action:'clothes:sortPopular' }
              ]
            });
            items.push({ labelKey:'menu.clothes.preview', action:'clothes:togglePreview', type:'checkbox', checked: false });
          }
          if(appId === 'diev'){
            items.push({
              type:'submenu',
              labelKey:'menu.diev.textSize',
              items:[
                { labelKey:'menu.diev.textSize.small', action:'diev:textSmall', type:'radio', checked: state.diev.textSize === 'small' },
                { labelKey:'menu.diev.textSize.normal', action:'diev:textNormal', type:'radio', checked: state.diev.textSize === 'normal' },
                { labelKey:'menu.diev.textSize.large', action:'diev:textLarge', type:'radio', checked: state.diev.textSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.diev.highContrast', action:'diev:toggleContrast', type:'checkbox', checked: state.diev.highContrast });
          }
          if(appId === 'contact'){
            items.push({ labelKey:'menu.contact.showQr', action:'contact:showQr' });
            items.push({ labelKey:'menu.contact.compact', action:'contact:compact' });
          }
          if(appId === 'settings'){
            items.push({ labelKey:'menu.settings.fullscreen', action:'settings:fullscreen', type:'checkbox', checked: !!document.fullscreenElement });
            items.push({ labelKey:'menu.settings.scanlines', action:'settings:scanlines', type:'checkbox', checked: state.settings.scanlines });
            items.push({ labelKey:'menu.settings.wallpaper', action:'settings:wallpaper' });
          }
          if(appId === 'art'){
            items.push({
              type:'submenu',
              labelKey:'menu.art.zoom',
              items:[
                { labelKey:'menu.art.zoom.50', action:'art:zoom50', type:'radio', checked: state.art.zoom === 50 },
                { labelKey:'menu.art.zoom.100', action:'art:zoom100', type:'radio', checked: state.art.zoom === 100 },
                { labelKey:'menu.art.zoom.200', action:'art:zoom200', type:'radio', checked: state.art.zoom === 200 }
              ]
            });
            items.push({ labelKey:'menu.art.slideshow', action:'art:slideshow' });
          }
          if(appId === 'games'){
            items.push({ labelKey:'menu.games.grid', action:'games:grid' });
            items.push({
              type:'submenu',
              labelKey:'menu.games.sort',
              items:[
                { labelKey:'menu.games.sort.new', action:'games:sortNew' },
                { labelKey:'menu.games.sort.favorite', action:'games:sortFavorite' }
              ]
            });
          }
          if(appId === 'videos'){
            items.push({
              type:'submenu',
              labelKey:'menu.videos.thumbSize',
              items:[
                { labelKey:'menu.videos.thumbSize.small', action:'videos:thumbSmall', type:'radio', checked: state.videos.thumbSize === 'small' },
                { labelKey:'menu.videos.thumbSize.large', action:'videos:thumbLarge', type:'radio', checked: state.videos.thumbSize === 'large' }
              ]
            });
            items.push({ labelKey:'menu.videos.openNewTab', action:'videos:toggleNewTab', type:'checkbox', checked: state.videos.openNewTab });
          }
          if(appId === 'about'){
            items.push({ labelKey:'menu.about.version', action:'about:version' });
            items.push({ labelKey:'menu.about.credits', action:'about:credits' });
          }
        }

        if(menuKey === 'help'){
          if(appId === 'music') items.push({ labelKey:'menu.music.where', action:'music:where' });
          if(appId === 'mediaplayer'){
            items.push({ labelKey:'menu.player.tips', action:'player:tips' });
            items.push({ labelKey:'menu.player.howto', action:'player:howto' });
          }
          if(appId === 'clothes') items.push({ labelKey:'menu.clothes.sizing', action:'clothes:sizing' });
          if(appId === 'diev') items.push({ labelKey:'menu.diev.links', action:'diev:links' });
          if(appId === 'contact') items.push({ labelKey:'menu.contact.support', action:'contact:support' });
          if(appId === 'settings') items.push({ labelKey:'menu.settings.what', action:'settings:what' });
          if(appId === 'art') items.push({ labelKey:'menu.art.credits', action:'art:credits' });
          if(appId === 'games') items.push({ labelKey:'menu.games.requirements', action:'games:requirements' });
          if(appId === 'videos') items.push({ labelKey:'menu.videos.tips', action:'videos:tips' });
          if(appId === 'about') items.push({ labelKey:'menu.about.controls', action:'about:controls' });

          addSep();
          items.push({ labelKey:'menu.help.controls', action:'global:controls' });
          items.push({ labelKey:'menu.help.about', action:'global:about' });
        }

        return items;
      }

      function openWindowMenu(winEl, menuKey, anchorEl){
        if(!winEl) return;
        const drop = winEl.querySelector('.menu-drop');
        const appId = getWindowId(winEl);
        if(!drop || !appId) return;

        if(state.menuOpen && state.menuOpen.winId !== appId){
          closeWindowMenu();
        }
        const items = getMenuItems(appId, menuKey);
        if(items.length === 0){
          closeWindowMenu();
          return;
        }
        drop.innerHTML = renderMenuItems(items);
        drop.classList.remove('hidden');

        const winRect = winEl.getBoundingClientRect();
        const anchorRect = anchorEl.getBoundingClientRect();
        drop.style.top = (anchorRect.bottom - winRect.top) + 'px';
        drop.style.left = (anchorRect.left - winRect.left) + 'px';

        winEl.querySelectorAll('.menubar span').forEach(span => {
          span.classList.toggle('active', span.dataset.menu === menuKey);
        });

        state.menuOpen = { winId: appId, menuKey };
      }

      function closeWindowMenu(){
        if(!state.menuOpen) return;
        const winEl = document.getElementById(`win_${state.menuOpen.winId}`);
        if(winEl){
          const drop = winEl.querySelector('.menu-drop');
          if(drop) drop.classList.add('hidden');
          winEl.querySelectorAll('.menubar span').forEach(span => span.classList.remove('active'));
        }
        state.menuOpen = null;
      }

      const modalState = { onConfirm: null };

      function showModal({ title, body, actions }){
        const modal = $('#modal');
        if(!modal) return;
        $('#modalTitle').textContent = title || '';
        $('#modalBody').innerHTML = body || '';
        const actionsEl = $('#modalActions');
        actionsEl.innerHTML = (actions || []).map((a, idx) => `
          <button class="btn bevel" type="button" data-modal-action="${a.action}" style="${a.primary ? 'font-weight:700;' : ''}">${a.label}</button>
        `).join('');
        modal.classList.remove('hidden');
        const firstBtn = actionsEl.querySelector('button');
        if(firstBtn) firstBtn.focus();
      }

      function closeModal(){
        const modal = $('#modal');
        if(!modal) return;
        modal.classList.add('hidden');
        $('#modalBody').innerHTML = '';
        $('#modalActions').innerHTML = '';
        modalState.onConfirm = null;
      }

      function showMessage(titleKey, bodyKey){
        showModal({
          title: t(titleKey),
          body: `<p style="margin:0;">${t(bodyKey)}</p>`,
          actions: [{ label: t('common.ok'), action: 'close', primary: true }]
        });
      }

      function showSelectDialog({ titleKey, descKey, options, confirmKey, onConfirm, selected }){
        const opts = options.map(o => {
          const sel = (selected !== undefined && String(selected) === String(o.value)) ? ' selected' : '';
          return `<option value="${o.value}"${sel}>${o.label}</option>`;
        }).join('');
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <select id="modalSelect" class="bevel-in" style="width:100%; height:26px;">${opts}</select>
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      function showInputDialog({ titleKey, descKey, value, confirmKey, onConfirm }){
        const safeValue = value ? String(value).replace(/"/g, '&quot;') : '';
        const body = `
          <p style="margin:0 0 8px 0;">${t(descKey)}</p>
          <input id="modalInput" class="bevel-in" type="text" value="${safeValue}" style="width:100%; height:26px;" />
        `;
        modalState.onConfirm = onConfirm || null;
        showModal({
          title: t(titleKey),
          body,
          actions: [
            { label: t(confirmKey), action: 'confirm', primary: true },
            { label: t('common.cancel'), action: 'close' }
          ]
        });
      }

      async function copyText(text){
        if(!text) return false;
        try{
          await navigator.clipboard.writeText(text);
          return true;
        } catch {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand('copy');
          ta.remove();
          return ok;
        }
      }

      function selectAllInWindow(winId){
        const winEl = document.getElementById(`win_${winId}`);
        if(!winEl) return;
        const content = winEl.querySelector('.content');
        if(!content) return;
        const range = document.createRange();
        range.selectNodeContents(content);
        const sel = window.getSelection();
        if(sel){
          sel.removeAllRanges();
          sel.addRange(range);
        }
      }

      function getSelectedText(){
        const sel = window.getSelection();
        return sel ? String(sel.toString()) : '';
      }

      function copySelectedTextOrWarn(){
        const text = getSelectedText();
        if(!text){
          showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
          return;
        }
        copyText(text).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
      }

      function openLink(url, appId){
        if(!url) return;
        if(appId === 'music'){
          if(state.music.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        if(appId === 'videos'){
          if(state.videos.openNewTab) window.open(url, '_blank', 'noreferrer');
          else window.location.href = url;
          return;
        }
        window.open(url, '_blank', 'noreferrer');
      }

      function handleMenuAction(action){
        const winId = state.menuOpen ? state.menuOpen.winId : null;
        if(!action) return;

        if(action === 'global:newWindow'){
          const options = APPS.filter(a => a.showInStart !== false).map(a => ({ value: a.id, label: t(a.titleKey) }));
          showSelectDialog({
            titleKey: 'dialog.newWindow.title',
            descKey: 'dialog.newWindow.desc',
            options,
            confirmKey: 'dialog.newWindow.open',
            onConfirm: (val)=>{ openApp(val); }
          });
          return;
        }
        if(action === 'global:close' && winId){
          closeApp(winId);
          return;
        }
        if(action === 'global:logoff'){
          doLogoff();
          return;
        }
        if(action === 'global:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'global:about'){
          openApp('about');
          return;
        }

        if(action === 'music:openLink'){
          const options = MUSIC_LINKS.map(l => ({ value: l.id, label: l.label }));
          const selectedId = Array.from(state.music.selected)[0];
          showSelectDialog({
            titleKey: 'dialog.openLink.title',
            descKey: 'dialog.openLink.desc',
            options,
            confirmKey: 'dialog.openLink.open',
            selected: selectedId,
            onConfirm: (val)=>{
              const link = MUSIC_LINKS.find(l => l.id === val);
              if(link) openLink(link.url, 'music');
            }
          });
          return;
        }
        if(action === 'music:copyLink'){
          const ids = Array.from(state.music.selected);
          const selected = ids.length ? ids : [];
          if(selected.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const urls = selected.map(id => (MUSIC_LINKS.find(l => l.id === id) || {}).url).filter(Boolean);
          copyText(urls.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'music:selectAll'){
          state.music.selected = new Set(MUSIC_LINKS.map(l => l.id));
          applyMusicState();
          return;
        }
        if(action === 'music:clearSelection'){
          state.music.selected = new Set();
          applyMusicState();
          return;
        }
        if(action === 'music:tileSmall'){
          state.music.tileSize = 'small';
          applyMusicState();
          return;
        }
        if(action === 'music:tileLarge'){
          state.music.tileSize = 'large';
          applyMusicState();
          return;
        }
        if(action === 'music:toggleNewTab'){
          state.music.openNewTab = !state.music.openNewTab;
          return;
        }
        if(action === 'music:toggleIcons'){
          state.music.showIcons = !state.music.showIcons;
          applyMusicState();
          return;
        }
        if(action === 'music:where'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'player:openTrack'){
          const options = mp.tracks.map((tr, i) => ({ value: String(i), label: tr.title }));
          if(options.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          showSelectDialog({
            titleKey: 'dialog.openTrack.title',
            descKey: 'dialog.openTrack.desc',
            options,
            confirmKey: 'dialog.openTrack.open',
            selected: mp.idx,
            onConfirm: (val)=>{
              const idx = Number(val);
              state.mediaplayer.selected = new Set([idx]);
              mpSetTrack(idx);
              mpPlay();
            }
          });
          return;
        }
        if(action === 'player:reload'){
          mpLoadTracks();
          return;
        }
        if(action === 'player:selectAll'){
          state.mediaplayer.selected = new Set(mp.tracks.map((_, i) => i));
          mpRender();
          return;
        }
        if(action === 'player:copyName'){
          const ids = Array.from(state.mediaplayer.selected);
          if(ids.length === 0){
            showMessage('dialog.selectItem.title', 'dialog.selectItem.body');
            return;
          }
          const names = ids.map(i => (mp.tracks[i] ? mp.tracks[i].title : '')).filter(Boolean);
          copyText(names.join('\n')).then(ok => {
            if(ok) showMessage('dialog.copied.title', 'dialog.copied.body');
          });
          return;
        }
        if(action === 'player:clearSelection'){
          state.mediaplayer.selected = new Set();
          mpRender();
          return;
        }
        if(action === 'player:toggleShuffle'){
          state.mediaplayer.shuffle = !state.mediaplayer.shuffle;
          mpRender();
          return;
        }
        if(action === 'player:repeatOff'){
          state.mediaplayer.repeat = 'off';
          mpRender();
          return;
        }
        if(action === 'player:repeatOne'){
          state.mediaplayer.repeat = 'one';
          mpRender();
          return;
        }
        if(action === 'player:repeatAll'){
          state.mediaplayer.repeat = 'all';
          mpRender();
          return;
        }
        if(action === 'player:togglePlaylist'){
          state.mediaplayer.showPlaylist = !state.mediaplayer.showPlaylist;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:toggleCompact'){
          state.mediaplayer.compact = !state.mediaplayer.compact;
          applyMediaplayerState();
          return;
        }
        if(action === 'player:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }
        if(action === 'player:howto'){
          showMessage('dialog.playerHowTo.title', 'dialog.playerHowTo.body');
          return;
        }

        if(action === 'clothes:openLookbook' || action === 'clothes:shop' || action === 'clothes:sizing' || action === 'clothes:viewGrid' || action === 'clothes:sortNew' || action === 'clothes:sortPopular' || action === 'clothes:togglePreview'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'clothes:copy' || action === 'clothes:selectAll'){
          if(action === 'clothes:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'clothes:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'diev:openPress' || action === 'diev:copyBio'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'diev:copy' || action === 'diev:selectAll'){
          if(action === 'diev:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'diev:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'diev:textSmall'){
          state.diev.textSize = 'small';
          applyDievState();
          return;
        }
        if(action === 'diev:textNormal'){
          state.diev.textSize = 'normal';
          applyDievState();
          return;
        }
        if(action === 'diev:textLarge'){
          state.diev.textSize = 'large';
          applyDievState();
          return;
        }
        if(action === 'diev:toggleContrast'){
          state.diev.highContrast = !state.diev.highContrast;
          applyDievState();
          return;
        }
        if(action === 'diev:links'){
          showMessage('dialog.where.title', 'dialog.where.body');
          return;
        }

        if(action === 'contact:support'){
          showMessage('dialog.support.title', 'dialog.support.body');
          return;
        }
        if(action === 'contact:copyEmail' || action === 'contact:openInstagram' || action === 'contact:showQr' || action === 'contact:compact'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'contact:copy' || action === 'contact:selectAll'){
          if(action === 'contact:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'contact:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'settings:apply'){
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:reset'){
          setLang('en');
          applyWallpaper('classic');
          setAnimations(true);
          state.settings.scanlines = false;
          applyScanlines();
          showMessage('dialog.settingsApplied.title', 'dialog.settingsApplied.body');
          return;
        }
        if(action === 'settings:undo'){
          showMessage('dialog.noUndo.title', 'dialog.noUndo.body');
          return;
        }
        if(action === 'settings:redo'){
          showMessage('dialog.noRedo.title', 'dialog.noRedo.body');
          return;
        }
        if(action === 'settings:fullscreen'){
          if(!document.fullscreenElement){
            document.documentElement.requestFullscreen().catch(()=>{});
          } else {
            document.exitFullscreen().catch(()=>{});
          }
          return;
        }
        if(action === 'settings:scanlines'){
          state.settings.scanlines = !state.settings.scanlines;
          applyScanlines();
          return;
        }
        if(action === 'settings:wallpaper'){
          openSettingsAndTab('appearance', 'settingsWallpaper');
          return;
        }
        if(action === 'settings:what'){
          showMessage('dialog.settingsWhat.title', 'dialog.settingsWhat.body');
          return;
        }

        if(action === 'art:openGallery' || action === 'art:saveImage' || action === 'art:slideshow' || action === 'art:credits'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'art:copy' || action === 'art:selectAll'){
          if(action === 'art:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'art:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'art:zoom50'){
          state.art.zoom = 50;
          applyArtState();
          return;
        }
        if(action === 'art:zoom100'){
          state.art.zoom = 100;
          applyArtState();
          return;
        }
        if(action === 'art:zoom200'){
          state.art.zoom = 200;
          applyArtState();
          return;
        }

        if(action === 'games:openFolder' || action === 'games:download' || action === 'games:grid' || action === 'games:sortNew' || action === 'games:sortFavorite' || action === 'games:requirements'){
          showMessage('dialog.notAvailable.title', 'dialog.notAvailable.body');
          return;
        }
        if(action === 'games:copy' || action === 'games:selectAll'){
          if(action === 'games:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'games:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }

        if(action === 'videos:openChannel'){
          openLink(VIDEO_CHANNEL_URL, 'videos');
          return;
        }
        if(action === 'videos:copyLink'){
          copyText(VIDEO_CHANNEL_URL).then(ok => ok && showMessage('dialog.copied.title', 'dialog.copied.body'));
          return;
        }
        if(action === 'videos:copy' || action === 'videos:selectAll'){
          if(action === 'videos:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'videos:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
        if(action === 'videos:thumbSmall'){
          state.videos.thumbSize = 'small';
          return;
        }
        if(action === 'videos:thumbLarge'){
          state.videos.thumbSize = 'large';
          return;
        }
        if(action === 'videos:toggleNewTab'){
          state.videos.openNewTab = !state.videos.openNewTab;
          return;
        }
        if(action === 'videos:tips'){
          showMessage('dialog.playerTips.title', 'dialog.playerTips.body');
          return;
        }

        if(action === 'about:version'){
          showMessage('dialog.version.title', 'dialog.version.body');
          return;
        }
        if(action === 'about:credits'){
          showMessage('dialog.credits.title', 'dialog.credits.body');
          return;
        }
        if(action === 'about:controls'){
          showMessage('dialog.controls.title', 'dialog.controls.body');
          return;
        }
        if(action === 'about:copy' || action === 'about:selectAll'){
          if(action === 'about:selectAll' && winId) selectAllInWindow(winId);
          if(action === 'about:copy'){
            copySelectedTextOrWarn();
          }
          return;
        }
      }

      function updateOpenWindowTitles(){
        // Update stored titles and the DOM titlebars
        state.windows.forEach((w, id) => {
          const app = APPS.find(a => a.id === id);
          const title = app ? t(app.titleKey) : (w.titleKey ? t(w.titleKey) : id);
          w.title = title;
          const winEl = document.getElementById(`win_${id}`);
          if(winEl){
            const titleEl = winEl.querySelector('.title-left strong');
            if(titleEl) titleEl.textContent = title;

            const c = winEl.querySelector('.content');
            if(c && CONTENT[id]) {
              c.innerHTML = CONTENT[id]();
            }
            applyI18nTo(winEl);
            applyWindowState(winEl, id);

            const minCtl = winEl.querySelector('[data-action="min"]');
            const maxCtl = winEl.querySelector('[data-action="max"]');
            const closeCtl = winEl.querySelector('[data-action="close"]');
            const resizeCtl = winEl.querySelector('.resize');
            if(minCtl) minCtl.title = t('win.minimize');
            if(maxCtl) maxCtl.title = t('win.maximize');
            if(closeCtl) closeCtl.title = t('win.close');
            if(resizeCtl) resizeCtl.title = t('win.resize');
            const status = winEl.querySelector('.statusbar');
            if(status){
              let center = status.querySelector('.status-center');
              if(!center){
                center = document.createElement('span');
                center.className = 'status-center';
                center.setAttribute('data-i18n', 'about.footer');
                status.insertBefore(center, status.lastElementChild);
              }
              center.textContent = t('about.footer');
            }

          if(id === 'mediaplayer') {
            setTimeout(mpInitInWindow, 0);
          }
          if(id === 'trash'){
            updateTrashIconUI();
          }
          if(id === 'poetry'){
            renderPoetryWindow();
          }
          if(id === 'clothes'){
            initClothesWindow(winEl);
          }
          if(id === 'settings'){
            initSettingsTabs(winEl);
          }
          if(id === 'videos'){
            initVideosWindow(winEl);
          }
        }
      });
      }

      function iconSVG(type){
        const common = `viewBox="0 0 16 16" class="pixel" aria-hidden="true"`;
        switch(type){
          case 'folder':
            return `<svg ${common}><rect width="16" height="16" fill="none"/><path d="M1 4h6l1 2h7v8H1z" fill="#ffcc66" stroke="#000" stroke-width="1"/><path d="M1 4h6l1 2H1z" fill="#ffd88a" stroke="#000" stroke-width="1"/></svg>`;
          case 'music':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><path d="M10 3v7.5a2 2 0 1 1-1-1.7V5h-3V3z" fill="#000080"/></svg>`;
          case 'art':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="3" y="3" width="10" height="10" fill="#c0c0c0" stroke="#000"/><path d="M4 11l2-2 2 2 2-3 3 3" stroke="#000080" stroke-width="1" fill="none"/></svg>`;
          case 'game':
            return `<svg ${common}><rect x="2" y="5" width="12" height="7" rx="2" fill="#c0c0c0" stroke="#000"/><rect x="5" y="7" width="1" height="3" fill="#000"/><rect x="4" y="8" width="3" height="1" fill="#000"/><circle cx="11" cy="8" r="1" fill="#ff3366"/><circle cx="12.8" cy="9.5" r="1" fill="#66ccff"/></svg>`;
          case 'video':
            return `<svg ${common}><rect x="1" y="3" width="12" height="10" fill="#fff" stroke="#000"/><path d="M13 6l2-1v6l-2-1z" fill="#000"/></svg>`;
          case 'info':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="5" r="1" fill="#000"/><rect x="7" y="7" width="2" height="6" fill="#000080"/></svg>`;
          case 'mail':
            return `<svg ${common}><rect x="1" y="3" width="14" height="10" fill="#fff" stroke="#000"/><path d="M1 4l7 5 7-5" fill="none" stroke="#000080" stroke-width="1"/></svg>`;
          case 'user':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="6" r="2" fill="#000080"/><path d="M4 13c1-2 7-2 8 0" stroke="#000080" fill="none"/></svg>`;
          case 'settings':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="8" r="3" fill="#c0c0c0" stroke="#000"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.5 3.5l1.4 1.4M11.1 11.1l1.4 1.4M12.5 3.5l-1.4 1.4M4.9 11.1l-1.4 1.4" stroke="#000080"/></svg>`;
          case 'trash':
            return `<svg ${common}><rect x="1" y="3" width="14" height="12" fill="#fff" stroke="#000"/><rect x="4" y="1" width="8" height="2" fill="#c0c0c0" stroke="#000"/><path d="M5 5v8M8 5v8M11 5v8" stroke="#000080"/></svg>`;
          default:
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="4" y="4" width="8" height="8" fill="#000080"/></svg>`;
        }
      }

      const APPS = [
        { id:'trash', titleKey:'app.trash', icon:'trash', iconFile:getTrashIconFile, showInStart:false },
        { id:'poetry', titleKey:'app.poetry', icon:'file', iconFile:'./assets/icons/poetry.png' },
        { id:'clothes', titleKey:'app.clothes', icon:'folder', iconFile:'./assets/icons/Clothes.png' },
        { id:'music', titleKey:'app.music', icon:'music', iconFile:'./assets/icons/Music.png' },
        { id:'mediaplayer', titleKey:'app.mediaplayer', icon:'music', iconFile:'./assets/icons/BLISS%20mediaplayer.png' },
        { id:'art', titleKey:'app.art', icon:'art', iconFile:'./assets/icons/Art.png' },
        { id:'games', titleKey:'app.games', icon:'game', iconFile:'./assets/icons/Games.png' },
        { id:'videos', titleKey:'app.videos', icon:'video', iconFile:'./assets/icons/Videos.png' },
        { id:'about', titleKey:'app.about', icon:'info', iconFile:'./assets/icons/About.png' },
        { id:'contact', titleKey:'app.contact', icon:'mail', iconFile:'./assets/icons/Contact.png' },
        { id:'diev', titleKey:'app.diev', icon:'user', iconFile:'./assets/icons/DIEV.png' },
        { id:'settings', titleKey:'app.settings', icon:'settings', iconFile:'./assets/icons/Settings.png' },
      ];

      const MUSIC_LINKS = [
        {
          id: 'spotify',
          label: 'Spotify',
          url: 'https://open.spotify.com/artist/6bjnHKF2yjUlKyYD15cNGq',
          icon: './assets/icons/spotify.png'
        },
        {
          id: 'youtubemusic',
          label: 'YouTube Music',
          url: 'https://music.youtube.com/channel/UCSjAU7hceaYUQPZml7HUFgA',
          icon: './assets/icons/youtubemusic.png'
        },
        {
          id: 'applemusic',
          label: 'Apple Music',
          url: 'https://music.apple.com/us/artist/diev/1586153318',
          icon: './assets/icons/applemusic.png'
        },
        {
          id: 'amazonmusic',
          label: 'Amazon Music',
          url: 'https://music.amazon.com.br/artists/B00F5I7CC6/diev',
          icon: './assets/icons/amazonmusic.png'
        },
        {
          id: 'soundcloud',
          label: 'SoundCloud',
          url: 'https://soundcloud.com/die_v/tracks',
          icon: './assets/icons/soundcloud.png'
        },
        {
          id: 'deezer',
          label: 'Deezer',
          url: 'https://www.deezer.com/en/artist/5170963',
          icon: './assets/icons/deezer.png'
        }
      ];

      // Update the fallback list with real Instagram thumbnails when needed.
      const CLOTHES_FALLBACK = [
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' },
        { img: './assets/icons/Clothes.png', url: 'https://www.instagram.com/blissworldweb/' }
      ];

      const VIDEO_CHANNEL_HANDLE = 'DIEVBLISS';
      const VIDEO_CHANNEL_URL = 'https://www.youtube.com/@DIEVBLISS';

      // Add new poems here. Always provide body_en and body_pt.
      const POEMS = [
        {
          id: 'evolve',
          title: 'Evolve',
          body_en: `To evolve is to change
More than it is to progress
The human race is in its teenager phase
We break everything
And apologize for nothing

And the ones closer to the truth
Are the ones who say, I know nothing

But its different when it comes from the temple
And when it comes from the streets
Because insanity is a common trait
Associated with unearned wisdom`,
          body_pt: `Evoluir  mudar
Mais do que  progredir
A raa humana vive sua fase adolescente
Quebramos tudo
E no pedimos desculpas por nada

E os que esto mais perto da verdade
So os que dizem: Eu nada sei

Mas  diferente quando vem do templo
E quando vem das ruas
Porque a insanidade  um trao comum
Associado  sabedoria no conquistada`
        },
        {
          id: 'tedio',
          title: 'Tedio',
          body_en: `Boredom

The walls bore me
The floor bores me
The blue sky with the bright sun bores me
Sometimes I think I understand
But the eternal boredom ends up taking me
I think about having a beer
Maybe that will cheer me up
The idea excites more than the act
After the first sip
I feel only boredom
They told me that growing old was good
Knowledge
Maturity
All of that brought me boredom
Now I sit doing nothing inside buildings
Waiting for the invitation that changes
The novelty that arrives
While I carry a cigarette
Around the boredom
In the idea I am happy
In the idea I am free and excited
In the act I find myself dull
In this eternal hell of boredom`,
          body_pt: `Tedio

As paredes me entediam
O cho me entedia
O cu azul com o sol brilhando me entedia
As vezes acho que entendo
Mas o tdio eterno acaba me tomando
Penso em tomar uma cerveja
Talvez isso me anime
A ideia anima mais que o ato
Depois do primeiro gole
Sinto apenas o tdio
Me disseram que envelhecer era bom
Conhecimento
Amadurecimento
Tudo isso me trouxe tdio
Agora fico sem fazer nada dentro de prdios
Esperando o convite que mude
A novidade que traga
Enquanto trago um cigarro
Em volta do tdio
Na ideia sou feliz
Na ideia sou livre e animado
No ato me encontro chato
Nesse inferno eterno tdio`
        },
        {
          id: 'la-vai-ela',
          title: 'La vai ela',
          body_en: `There she goes

There she goes to the phone
There I go to the music and a distant stare
There we go, arguing
There we go, hating and loving each other
She drinks from my sip
We share the same visions
We argue hard about the differences
We fight
We love
We look at ourselves
Who are we
Two lost children
Two angry children
In the end we love each other
As always, we love each other`,
          body_pt: `La vai ela

La vai ela pro celular
La vai eu pra musica e olhar distante
La vamos nos discutindo
La vamos nos se odiando e se amando
Ela bebe do meu gole
Dividimos mesmas vises
Discutimos forte as diferenas
Brigamos
Nos amamos
No olhamos
Quem somo nos
Duas crianas perdidas
Duas crianas bravas
No fim nos amamos
Como sempre nos amamos`
        },
        {
          id: 'falta-de-palavras',
          title: 'A falta de palavras',
          body_en: `The lack of words
Is the poets suicide
And she wanted me to try harder
To be with her
Cooking dinner
And I wanted to be far away`,
          body_pt: `A falta de palavras
 o suicido do poeta
E ela queria que eu me esforasse mais
Pra estar com ela
Cozinhando a janta
E eu querendo estar longe`
        },
        {
          id: 'no-fim-foi-isso',
          title: 'No fim foi isso',
          body_en: `In the end, that was it
In the end, that was it
A balancing of egos
One had too much
Another had too little
But it is all right
The scale goes up and down
And in the end, maybe
It levels`,
          body_pt: `No fim foi isso
No fim foi isso
Um balanceamento de egos
Um tinha demais
Outro tinha de menos
Mas esta tudo bem
A balana sobe e desce
E no fim talvez
Nivele`
        },
        {
          id: 'sua-interpretacao',
          title: 'Sua interpretao',
          body_en: `Your interpretation

Why do I feel so much empathy
For the mad?

Me, who considers myself so sane

Did you read this in a sarcastic tone
Or not?`,
          body_pt: `Sua interpretao

Porque tenho tanta empatia
Pelos loucos?

Logo eu que me considero to so

Voc leu isso em tom de sarcasmo
Ou no?`
        },
        {
          id: 'um-sanduiche',
          title: 'Um sanduche',
          body_en: `A sandwich

When I see lives at the edge of the limit
I realize my life
doesnt have enough strength
to drive me insane
While I sit at the table
to make a sandwich
My father speaks arrogantly
that no one does anything in this house
except him
So I get up
I pour myself a glass of coke
I observe things
And as always
they remain the same
They seem to never change
But I
I did something
A sandwich`,
          body_pt: `Um sanduche

Quando vejo vidas a beira do limite
Percebo que a minha vida
no tem foras o suficiente
Para me enlouquecer
Enquanto me sento a mesa
para fazer um sanduche
Meu pai fala com arrogncia
que ningum faz nada nessa casa
a no ser ele
Ai ento me levanto
Me sirvo um copo de coca
Observo as coisas
E como sempre
se mantm iguais
Parecem nunca mudar
Mas eu
Eu fiz algo
Um sanduche`
        },
        {
          id: 'conversas',
          title: 'Conversas',
          body_en: `Conversations

Conversations are poems
That we throw against the wind
My life looks like yours
I did that to have this
I went through pains like yours
I smiled in some moments
I cried in others
I wish I had made more of these poems`,
          body_pt: `Conversas

Conversas so poesias
Que jogamos contra o vento
Minha vida parece com a sua
Eu fiz aquilo para ter isso
Eu passei por dores como a suas
Eu sorri em momentos
Eu chorei em outros
Queria ter feito mais dessas poesias`
        },
        {
          id: 'a-surpresa-em-sentir-se-livre',
          title: 'A surpresa em sentir-se livre',
          body_en: `The surprise of feeling free

That feeling that catches me by surprise
In a trivial activity
In the midst of total boredom
That feeling of freedom
That arrives between a deep sigh
Arrives unexpectedly
Like the visit
Of an old friend`,
          body_pt: `A surpresa em sentir-se livre

Essa sensao que me pega de surpresa
Em uma atividade banal
Em meio ao tdio total
Essa sensao de liberdade
Que chega entre o suspiro profundo
Chega de surpresa
Como a visita
De um velho amigo`
        },
        {
          id: 'morte-e-compromisso',
          title: 'Morte e compromisso',
          body_en: `Death and commitment

Sometimes I feel taken over
By an idea
An idea that I can die
At any moment
Maybe now...
And that creates a fear
At the same time it creates an excitement
Because it is all so mysterious
How will I die?
What is death like?
And what comes after?
Then time passes
And all of that goes away
And I go back to worrying about life
And about my living problems
And I forget
I forget that death
Death doesnt care about my commitments`,
          body_pt: `Morte e compromisso

As vezes me sinto tomado
Por uma ideia
Uma ideia de que posso morrer
A qualquer momento
Talvez agora...
E isso gera um medo
ao mesmo tempo que gera uma excitao
Porque  tudo to misterioso
Como ser que vou morrer?
Como ser que  a morte?
E oque vem depois?
Ai ento o tempo passa
E tudo isso vai embora
E volto a me preocupar com a vida
E com meus problemas de vivo
E me esqueo
Me esqueo de que a morte
A morte no liga pro meus compromissos`
        },
        {
          id: 'quieto',
          title: 'Quieto',
          body_en: `Quiet

All my life I have always found myself
Quiet
In the middle of people always
Quiet
In the middle of family
Quiet
In the middle of friends
Quiet
In the middle of women
Quiet
All my life I have always been very quiet
What should I say?
What difference would it make?
I dont know
Now I will be silent

2019`,
          body_pt: `Quieto

Minha vida inteira eu sempre me encontrei
Quieto
No meio das pessoas sempre
Quieto
No meio da famlia
Quieto
No meio dos amigos
Quieto
No meio das mulheres
Quieto
Minha vida inteira eu sempre fui muito quieto
Oque eu deveria dizer?
Que diferena faria?
No sei
Agora vou me calar

2019`
        },
        {
          id: 'buffalo-branco-extinto',
          title: 'Buffalo branco extinto',
          body_en: `Extinct white buffalo

In the streets people look at me with strangeness
People who spend their whole lives seeing their own reflection
Wherever they go they always see the same
And when something like this appears, they find it strange
A figure so different
So rare
Strange
And interesting
Among the buffalo
I am the extinct white buffalo`,
          body_pt: `Buffalo branco extinto

Nas ruas pessoas me olham com estranheza
Pessoas que passam a vida toda vendo seu prprio reflexo
Aonde quer que vo veem sempre o mesmo
E quando algo assim aparece, estranham
Uma figura to diferente
To rara
Estranha
E Interessante
Em meio aos buffalos
Eu sou o buffalo branco extinto`
        }
      ];

      const CONTENT = {
        about: () => `
          <h2>${t('about.title')}</h2>
          <p>${t('about.p1')}</p>
          <p>${t('about.p2')}</p>
          <p>${t('about.p3')}</p>
          <p>${t('about.p4')}</p>
          <p>${t('about.p5')}</p>
          <p>${t('about.p6')}</p>
        `,
        clothes: () => `
          <h2>${t('clothes.title')}</h2>
          <p class="tiny" data-i18n="clothes.subtitle">${t('clothes.subtitle')}</p>
          <div class="clothes-grid" id="clothesGrid"></div>
          <div class="tiny clothes-status" id="clothesStatus" data-i18n="clothes.loading">${t('clothes.loading')}</div>
        `,
        music: () => `
  <h2>${t('music.title')}</h2>
  <p style="margin:0 0 10px 0;">${t('music.subtitle')}</p>

  <div class="music-grid">
    ${MUSIC_LINKS.map(link => `
      <button class="music-item" type="button" data-music-id="${link.id}" data-music-link="${link.url}">
        <div class="music-icon pixel">
          <img class="pixel" src="${link.icon}" width="48" height="48" alt="${link.label}" style="display:block;" />
        </div>
        <span class="music-label" style="font-weight:700;">${link.label}</span>
      </button>
    `).join('')}
  </div>

  <div class="hr98"></div>
  <div class="tiny">${t('music.tip')}</div>
`,

        mediaplayer: () => `
          <div class="mp-mini bevel">
            <div class="mp-now">
              <span class="tiny" data-i18n="player.now">Now playing:</span>
              <span class="mp-title" id="mpNow"></span>
            </div>

            <audio id="mpAudio" preload="metadata"></audio>

            <div class="mp-controls">
              <button class="btn bevel" type="button" data-mp-action="prev"> ${t('player.prev')}</button>
              <button class="btn bevel" type="button" data-mp-action="toggle"> ${t('player.play')}</button>
              <button class="btn bevel" type="button" data-mp-action="next"> ${t('player.next')}</button>
              <button class="btn bevel" type="button" data-mp-action="shuffle"></button>
              <button class="btn bevel" type="button" data-mp-action="repeat"></button>
            </div>

            <div class="mp-seek-row">
              <input class="mp-seek" id="mpSeek" type="range" min="0" max="1000" step="1" value="0" />
              <div class="mp-time"><span data-mp-current>0:00</span> / <span data-mp-total>--:--</span></div>
            </div>

            <div class="mp-bottom">
              <div class="mp-actions">
                <button class="btn bevel" type="button" data-mp-action="add" data-i18n="player.addSongs">Add songs</button>
                <button class="btn bevel hidden" type="button" data-mp-action="reimport" data-i18n="player.reimport">Re-import files</button>
              </div>
              <div class="tiny mp-status" id="mpMsg"></div>
              <div class="mp-vol">
                <span class="kbd" data-i18n="player.vol">Vol</span>
                <input id="mpVol" type="range" min="0" max="1" step="0.01" value="0.8" />
              </div>
            </div>
            <div class="tiny mp-drop hidden" id="mpDropHint" data-i18n="player.drop">Drop audio files here</div>
            <input id="mpFileInput" class="hidden" type="file" multiple accept=".flac,.mp3,.wav,.ogg,audio/*" />
          </div>
        `,

        art: () => `<h2>BLISS  ${t('app.art')}</h2><p>${t('common.soon')}</p>`,
        games: () => {
          if(state.games.view === 'dope-skate'){
            return `
              <div class="skate-shell">
                <div class="skate-topbar">
                  <button class="skate-btn ghost" type="button" data-games-action="back" data-i18n="games.back">Back</button>
                  <h2 class="skate-title" data-i18n="games.dopeSkate">Dope Skate</h2>
                  <div class="skate-topbar-actions">
                    <button class="skate-btn subtle" type="button" data-skate-action="menu" data-i18n="skate.action.menu">Menu</button>
                  </div>
                </div>
                <div class="skate-body">
                  <div class="skate-screen" id="skateScreen">
                    <div class="skate-canvas-wrap">
                      <canvas id="skateCanvas" class="pixel" width="640" height="360"></canvas>
                    </div>
                    <div class="skate-hud" id="skateHud">
                      <div><span data-i18n="skate.hud.score">Score</span>: <strong data-skate-score>0</strong></div>
                      <div><span data-i18n="skate.hud.combo">Combo</span>: <strong data-skate-combo>1x</strong></div>
                      <div class="skate-combo-list" data-skate-combo-list></div>
                      <div class="skate-combo-meter"><span data-skate-combo-meter></span></div>
                      <div class="skate-combo-list" data-skate-bliss></div>
                      <div><span data-i18n="skate.hud.best">Best</span>: <strong data-skate-best>0</strong></div>
                      <div><span data-i18n="skate.hud.cds">CDs</span>: <strong data-skate-cds>0</strong></div>
                    </div>
                    <div class="skate-balance hidden" id="skateBalance">
                      <span class="tiny" data-i18n="skate.grind.balance">Balance</span>
                      <div class="skate-balance-bar"><span class="skate-balance-indicator" data-skate-balance-indicator></span></div>
                    </div>
                    <div class="skate-overlay" id="skateMenuOverlay">
                      <div class="skate-menu">
                        <div class="skate-menu-header">
                          <div class="skate-menu-title" data-i18n="games.dopeSkate">Dope Skate</div>
                          <div class="skate-menu-actions">
                            <button class="skate-btn ghost" type="button" data-skate-action="resume" data-i18n="skate.action.resume">Resume</button>
                          </div>
                        </div>
                        <div class="skate-tabs">
                          <button class="skate-tab" type="button" data-skate-tab="play" data-i18n="skate.menu.play">Play</button>
                          <button class="skate-tab" type="button" data-skate-tab="settings" data-i18n="skate.menu.settings">Settings</button>
                          <button class="skate-tab" type="button" data-skate-tab="shop" data-i18n="skate.menu.shop">Shop</button>
                          <button class="skate-tab" type="button" data-skate-tab="howto" data-i18n="skate.menu.howto">How to play</button>
                          <button class="skate-tab" type="button" data-skate-tab="leaderboard" data-i18n="skate.menu.leaderboard">Leaderboard</button>
                        </div>
                        <div class="skate-menu-panels">
                          <div class="skate-panel active" data-skate-panel="play">
                            <p class="skate-panel-text" data-i18n="skate.menu.playDesc">Endless run through the city. Jump obstacles, keep the combo alive.</p>
                            <div class="skate-panel-actions">
                              <button class="skate-btn primary" type="button" data-skate-action="start" data-i18n="skate.action.start">Start run</button>
                              <button class="skate-btn ghost" type="button" data-skate-action="resume" data-i18n="skate.action.resume">Resume</button>
                            </div>
                          </div>
                          <div class="skate-panel" data-skate-panel="settings">
                            <div class="skate-panel-title" data-i18n="skate.menu.settings">Settings</div>
                            <div class="skate-shop-grid">
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.settings.difficulty">Difficulty</strong>
                                <select class="skate-select" data-skate-setting="difficulty">
                                  <option value="easy" data-i18n="skate.settings.difficultyEasy">Easy</option>
                                  <option value="medium" data-i18n="skate.settings.difficultyMedium">Medium</option>
                                  <option value="hard" data-i18n="skate.settings.difficultyHard">Hard</option>
                                </select>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.settings.sfx">Sound effects</strong>
                                <button class="skate-btn ghost" type="button" data-skate-setting="sfx" data-i18n="skate.settings.sfxOn">On</button>
                              </div>
                            </div>
                            <div class="skate-panel-actions">
                              <button class="skate-btn ghost" type="button" data-skate-action="menu" data-i18n="skate.action.back">Back to menu</button>
                            </div>
                          </div>
                          <div class="skate-panel" data-skate-panel="shop">
                            <div class="skate-panel-title" data-i18n="skate.menu.shop">Shop</div>
                            <div class="skate-tabs skate-shop-tabs">
                              <button class="skate-tab" type="button" data-skate-shop-tab="skater" data-i18n="skate.shop.skater">Skater</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="hat" data-i18n="skate.shop.hat">Hat</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="board" data-i18n="skate.shop.board">Skate</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="wheels" data-i18n="skate.shop.wheels">Wheels</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="ground" data-i18n="skate.shop.ground">Ground</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="background" data-i18n="skate.shop.background">Background</button>
                              <button class="skate-tab" type="button" data-skate-shop-tab="sky" data-i18n="skate.shop.sky">Sky</button>
                            </div>
                            <div class="skate-shop-header">
                              <div class="tiny" data-i18n="skate.shop.wallet">Wallet</div>
                              <strong data-skate-wallet>0</strong>
                            </div>
                            <div class="skate-shop-layout">
                              <div class="skate-shop-shelves" data-skate-shop-list></div>
                              <div class="skate-shop-preview">
                                <div class="skate-preview-stage" data-skate-preview-stage></div>
                                <div class="tiny skate-preview-status" data-skate-preview-status></div>
                                <div class="tiny" data-i18n="skate.shop.equipped">Equipped</div>
                                <div class="tiny" data-skate-equipped-list></div>
                              </div>
                            </div>
                            <div class="skate-panel-actions">
                              <button class="skate-btn ghost hidden" type="button" data-skate-action="revert-preview" data-skate-preview-reset data-i18n="skate.shop.useEquipped">Use equipped</button>
                              <button class="skate-btn ghost" type="button" data-skate-action="menu" data-i18n="skate.action.back">Back to menu</button>
                            </div>
                          </div>
                          <div class="skate-panel" data-skate-panel="howto">
                            <div class="skate-panel-title" data-i18n="skate.menu.howto">How to play</div>
                            <p class="skate-panel-text" data-i18n="skate.howto.body">Jump, throw tricks in the air, and link combos before you land.</p>
                            <div class="skate-shop-grid">
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.controls">Controls</strong>
                                <span class="tiny" data-i18n="skate.howto.controlsDesc">Jump: Space/Up/X. Tricks: Z/X/C or Square/Triangle/Circle.</span>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.trick1">Trick 1</strong>
                                <span class="tiny" data-i18n="skate.howto.trick1Desc">Kickflip in the air. Hold Left/Right for Heelflip.</span>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.trick2">Trick 2</strong>
                                <span class="tiny" data-i18n="skate.howto.trick2Desc">Shuv-it in the air. Hold Left/Right for Varial Kickflip.</span>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.trick3">Trick 3</strong>
                                <span class="tiny" data-i18n="skate.howto.trick3Desc">Hardflip in the air or on a grind.</span>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.combo">Combos</strong>
                                <span class="tiny" data-i18n="skate.howto.comboDesc">Tricks only count in air or grind. Chain tricks before landing to raise the multiplier.</span>
                              </div>
                              <div class="skate-shop-item">
                                <strong data-i18n="skate.howto.grind">Grinds</strong>
                                <span class="tiny" data-i18n="skate.howto.grindDesc">Jump onto a rail, balance with Left/Right, and press Jump to exit.</span>
                              </div>
                            </div>
                            <div class="skate-panel-actions">
                              <button class="skate-btn ghost" type="button" data-skate-action="menu" data-i18n="skate.action.back">Back to menu</button>
                            </div>
                          </div>
                          <div class="skate-panel" data-skate-panel="leaderboard">
                            <div class="skate-panel-title" data-i18n="skate.menu.leaderboard">Leaderboard</div>
                            <p class="skate-panel-text" data-i18n="skate.leaderboard.body">Local and global records will show here.</p>
                            <div class="skate-shop-item">
                              <strong data-i18n="skate.leaderboard.local">Local best</strong>
                              <span class="tiny" data-skate-local-best>0</span>
                            </div>
                            <div class="skate-shop-item">
                              <strong data-i18n="skate.leaderboard.global">Global best</strong>
                              <span class="tiny" data-skate-global-best></span>
                            </div>
                            <div class="skate-panel-actions">
                              <button class="skate-btn ghost" type="button" data-skate-action="menu" data-i18n="skate.action.back">Back to menu</button>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    <div class="skate-overlay hidden" id="skateOverOverlay">
                      <div class="skate-over-box">
                        <strong data-i18n="skate.gameOver">Game Over</strong>
                        <div class="tiny"><span data-i18n="skate.over.base">Base</span>: <span data-skate-over-base>0</span></div>
                        <div class="tiny"><span data-i18n="skate.over.combo">Combo bonus</span>: <span data-skate-over-combo>0</span></div>
                        <div class="tiny"><span data-i18n="skate.over.bliss">BLISS bonus</span>: <span data-skate-over-bliss>0</span></div>
                        <div class="tiny"><span data-i18n="skate.over.total">Total</span>: <span data-skate-over-score>0</span></div>
                        <div class="tiny"><span data-i18n="skate.over.cds">CDs</span>: <span data-skate-over-cds>0</span></div>
                        <div class="tiny"><span data-i18n="skate.over.money">Money</span>: <span data-skate-over-money>0</span></div>
                        <div class="tiny"><span data-i18n="skate.hud.best">Best</span>: <span data-skate-over-best>0</span></div>
                        <button class="skate-btn primary" type="button" data-skate-action="retry" data-i18n="skate.action.retry">Retry</button>
                        <button class="skate-btn ghost" type="button" data-skate-action="menu" data-i18n="skate.action.menu">Menu</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            `;
          }
          if(state.games.view === 'snake'){
            return `
              <div class="snake-topbar">
                <button class="btn bevel" type="button" data-games-action="back" data-i18n="games.back">Back</button>
                <div class="snake-topbar-stats">
                  <div class="tiny"><span data-i18n="snake.score">Score:</span> <strong data-snake-score>0</strong></div>
                  <div class="tiny"><span data-i18n="snake.highScore">High Score:</span> <strong data-snake-high>0</strong></div>
                  <label class="snake-speed">
                    <span class="tiny" data-i18n="snake.speed">Speed:</span>
                    <select data-snake-speed>
                      <option value="slow" data-i18n="snake.speed.slow">Slow</option>
                      <option value="normal" data-i18n="snake.speed.normal">Normal</option>
                      <option value="fast" data-i18n="snake.speed.fast">Fast</option>
                    </select>
                  </label>
                </div>
              </div>
              <h2>${t('games.snake')}</h2>
              <div class="snake-layout">
                <div class="snake-board bevel-in" id="snakeBoard">
                  <canvas id="snakeCanvas" class="pixel" width="320" height="320"></canvas>
                  <div class="snake-overlay hidden" id="snakeOverlay">
                    <div class="snake-overlay-box bevel">
                      <strong data-i18n="snake.gameOver">Game Over</strong>
                      <div class="tiny"><span data-i18n="snake.score">Score:</span> <span data-snake-over-score>0</span></div>
                      <button class="btn bevel" type="button" data-snake-action="playAgain" data-i18n="snake.playAgain">Play again</button>
                    </div>
                  </div>
                </div>
                <div class="snake-side">
                  <div class="snake-controls">
                    <button class="btn bevel" type="button" data-snake-action="start" data-i18n="snake.start">Start</button>
                    <button class="btn bevel" type="button" data-snake-action="pause" data-i18n="snake.pause">Pause</button>
                  </div>
                </div>
              </div>
            `;
          }
          if(state.games.view === 'leaderboard'){
            const lb = getGamesLeaderboard();
            const rows = lb.items.map(item => `
              <div class="games-leaderboard-row">
                <strong>${item.label}</strong>
                <span>${item.best}</span>
              </div>
            `).join('');
            return `
              <div class="games-shell">
                <div class="games-skin">
                  <div class="games-surface">
                    <div class="games-tabs">
                      <button class="games-tab${state.games.view === 'list' ? ' active' : ''}" type="button" data-games-tab="hub" data-i18n="games.tab.hub">Games</button>
                      <button class="games-tab${state.games.view === 'leaderboard' ? ' active' : ''}" type="button" data-games-tab="leaderboard" data-i18n="games.tab.leaderboard">Leaderboard</button>
                    </div>
                    <div class="games-leaderboard">
                      <div class="games-leaderboard-row">
                        <strong data-i18n="games.leaderboard.total">Total Score</strong>
                        <span>${lb.total}</span>
                      </div>
                      ${rows || `<div class="tiny" data-i18n="games.leaderboard.empty">No scores yet.</div>`}
                    </div>
                  </div>
                </div>
              </div>
            `;
          }
          const items = (state.folders.games || []).map(id => {
            if(id === 'snake'){
              return `
                <button class="games-item games-card" type="button" data-game-id="snake">
                  <div class="games-icon pixel">
                    <img class="pixel" src="./assets/icons/snake.png" width="64" height="64" alt="${t('games.snake')}" style="display:block;" />
                  </div>
                  <span data-i18n="games.snake">Snake</span>
                </button>
              `;
            }
            if(id === 'dope-skate'){
              return `
                <button class="games-item games-card" type="button" data-game-id="dope-skate">
                  <div class="games-icon pixel">
                    <img class="pixel" src="./assets/icons/dope-skate.png" width="64" height="64" alt="${t('games.dopeSkate')}" style="display:block;" />
                  </div>
                  <span data-i18n="games.dopeSkate">Dope Skate</span>
                </button>
              `;
            }
            const app = getAppById(id);
            if(!app) return '';
            const label = t(app.titleKey);
            const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
            const iconHtml = iconFile
              ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
              : iconSVG(app.icon);
            return `
              <button class="games-item games-card" type="button" data-game-id="${id}">
                <div class="games-icon pixel">${iconHtml}</div>
                <span>${label}</span>
              </button>
            `;
          }).join('');

          return `
            <div class="games-shell">
              <div class="games-skin">
                <div class="games-surface">
                  <div class="games-tabs">
                    <button class="games-tab${state.games.view === 'list' ? ' active' : ''}" type="button" data-games-tab="hub" data-i18n="games.tab.hub">Games</button>
                    <button class="games-tab${state.games.view === 'leaderboard' ? ' active' : ''}" type="button" data-games-tab="leaderboard" data-i18n="games.tab.leaderboard">Leaderboard</button>
                  </div>
                  <div id="gamesList" class="games-grid">
                    ${items || `<div class="tiny" data-i18n="games.empty">${t('games.empty')}</div>`}
                  </div>
                </div>
              </div>
            </div>
          `;
        },
        videos: () => `
          <div class="videos-shell">
            <div class="videos-header">
              <a href="${VIDEO_CHANNEL_URL}" target="_blank" rel="noopener noreferrer" data-i18n="videos.channelLink">YouTube: @DIEVBLISS</a>
            </div>
            <div class="videos-player">
              <div class="videos-player-head">
                <strong data-i18n="videos.watchTitle">Watch inside BLISS 98</strong>
                <div class="videos-player-actions">
                  <button class="btn bevel" type="button" data-videos-action="openChannel" data-i18n="videos.openChannel">Open channel videos</button>
                  <button class="btn bevel" type="button" data-videos-action="addKey" data-i18n="videos.addKey">Add YouTube API Key</button>
                </div>
              </div>
              <div class="videos-embed bevel-in">
                <div class="videos-embed-inner">
                  <iframe id="videosPlayer" title="YouTube Player" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
                </div>
              </div>
              <div class="tiny" id="videosStatus"></div>
            </div>
            <div class="videos-list" id="videosList"></div>
          </div>
        `,
        poetry: () => {
          if(POEMS.length === 0){
            return `<h2>${t('app.poetry')}</h2><p>${t('poetry.empty')}</p>`;
          }
          if(state.poetry.view === 'read' && state.poetry.currentId){
            const poem = getPoemById(state.poetry.currentId);
            if(!poem){
              state.poetry.view = 'list';
            } else {
              return `
                <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px;">
                  <button class="btn bevel" type="button" data-poetry-action="back">${t('poetry.back')}</button>
                  <button class="btn bevel" type="button" data-poetry-action="toggleLang">${t('poetry.language')}</button>
                  <span class="kbd">${state.poetry.readLang.toUpperCase()}</span>
                </div>
                <h2>${poem.title}</h2>
                <div class="poem-body">${getPoemBody(poem, state.poetry.readLang)}</div>
              `;
            }
          }
          const grid = POEMS.map(poem => `
            <button class="poetry-item" type="button" data-poem-id="${poem.id}">
              <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">
                <img class="pixel" src="./assets/icons/poetry2.png" width="32" height="32" alt="${poem.title}" style="display:block;" />
              </div>
              <span>${poem.title}</span>
            </button>
          `).join('');
          return `
            <h2>${t('poetry.title')}</h2>
            <div class="poetry-grid">${grid}</div>
          `;
        },
        trash: () => {
          const items = Array.from(state.trash);
          if(items.length === 0){
            return `<div class="trash-empty-msg">${t('dialog.trash.empty')}</div>`;
          }
          const grid = items.map(id => {
            const app = APPS.find(a => a.id === id);
            const label = app ? getIconLabel(app) : id;
            const iconFile = app && app.iconFile
              ? (typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile)
              : null;
            const iconHtml = iconFile
              ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
              : iconSVG(app ? app.icon : 'file');
            return `
                  <button class="trash-item" type="button" data-trash-id="${id}">
                <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
                <span>${label}</span>
              </button>
            `;
          }).join('');
          return `<div class="trash-grid">${grid}</div>`;
        },
        contact: () => `
          <h2>${t('contact.title')}</h2>
          <div class="contact-list" style="display:flex; flex-direction:column; gap:8px;">
            <div><strong>${t('contact.label.instagramDIEV')}</strong> <a href="https://www.instagram.com/die.verson/" target="_blank" rel="noopener noreferrer">@die.verson</a></div>
            <div><strong>${t('contact.label.twitterDIEV')}</strong> <a href="https://x.com/DIE_VERSON" target="_blank" rel="noopener noreferrer">@die_verson</a></div>
            <div><strong>${t('contact.label.emailBusiness')}</strong> <a href="mailto:die.versonbusiness@gmail.com">die.versonbusiness@gmail.com</a></div>
            <div><strong>${t('contact.label.instagramBLISS')}</strong> <a href="https://www.instagram.com/blissworldweb/" target="_blank" rel="noopener noreferrer">@blissworldweb</a></div>
          </div>
        `,
        diev: () => `<h2>${t('diev.title')}</h2><p>${t('diev.p1')}</p>`,
        settings: () => `
          <h2 data-i18n="settings.title">Settings</h2>
          <div class="settings-shell">
            <div class="settings-tabs" role="tablist" aria-label="Settings">
              <button class="settings-tab" type="button" role="tab" data-tab="general" aria-controls="settingsPanel_general" data-i18n="settings.tab.general">General</button>
              <button class="settings-tab" type="button" role="tab" data-tab="language" aria-controls="settingsPanel_language" data-i18n="settings.tab.language">Language</button>
              <button class="settings-tab" type="button" role="tab" data-tab="appearance" aria-controls="settingsPanel_appearance" data-i18n="settings.tab.appearance">Appearance</button>
              <button class="settings-tab" type="button" role="tab" data-tab="performance" aria-controls="settingsPanel_performance" data-i18n="settings.tab.performance">Performance</button>
            </div>
            <div class="settings-panels">
              <div class="settings-panel" role="tabpanel" data-tab="general" id="settingsPanel_general">
                <div class="settings-general">
                  <div class="settings-logo">
                    <img class="pixel" src="./assets/icons/computer.png" width="48" height="48" alt="" />
                  </div>
                  <div class="settings-summary">
                    <strong data-i18n="settings.general.title">BLISS 98</strong>
                    <div class="tiny" data-i18n="settings.general.desc">System properties and preferences for BLISS 98.</div>
                    <div class="settings-block tiny">
                      <span data-i18n="settings.general.user">User:</span>
                      <strong>${state.user ? state.user : t('settings.general.guest')}</strong>
                    </div>
                    <div class="tiny">
                      <span data-i18n="settings.general.version">Version:</span>
                      <span>BLISS 98  Build 98.0</span>
                    </div>
                    <div class="settings-block tiny">
                      <div data-i18n="settings.general.registeredTo">Registered to:</div>
                      <strong data-i18n="settings.general.registeredName">A Bad Motherfucker</strong>
                      <div data-i18n="settings.general.registeredCode">616-FTP-420-333</div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="language" id="settingsPanel_language">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="./assets/icons/language.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.languageTab">Language</strong>
                    <div class="tiny" data-i18n="settings.languageDesc">Choose your language for BLISS 98.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-lang="en"><span class="kbd" style="margin-right:6px;">EN</span><span data-i18n="settings.lang.en">English</span></button>
                  <button class="btn bevel" type="button" data-set-lang="pt"><span class="kbd" style="margin-right:6px;">PT</span><span data-i18n="settings.lang.pt">Portugus (BR)</span></button>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="appearance" id="settingsPanel_appearance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="./assets/icons/appearance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.appearanceTab">Appearance</strong>
                    <div class="tiny" data-i18n="settings.appearanceDesc">Customize how BLISS 98 looks.</div>
                  </div>
                </div>
                <div class="settings-block" id="settingsThemes">
                  <strong data-i18n="settings.themes.title">Themes</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.themes.desc">Select a theme to change wallpaper, title color, and dark mode.</p>
                  <div class="theme-grid">
                    <button class="theme-thumb bevel" type="button" data-set-theme="default" data-theme-thumb="default">
                      <div class="theme-preview theme-preview-default">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.default">Default</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="totvers" data-theme-thumb="totvers">
                      <div class="theme-preview theme-preview-totvers">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.totvers">Totvers</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="matrix" data-theme-thumb="matrix">
                      <div class="theme-preview theme-preview-matrix">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body" style="background:linear-gradient(180deg, #000 0%, #0a1a0f 100%);"></div>
                      </div>
                      <span data-i18n="theme.matrix">Matrix</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="xp98" data-theme-thumb="xp98">
                      <div class="theme-preview theme-preview-xp98">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body" style="background:url('./assets/wallpapers/bliss98.png') center/cover no-repeat;"></div>
                      </div>
                      <span data-i18n="theme.xp98">XP98</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-set-theme="blank" data-theme-thumb="blank">
                      <div class="theme-preview theme-preview-blank">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-i18n="theme.blank">Blank</span>
                    </button>
                    <button class="theme-thumb bevel" type="button" data-theme-custom="load" data-theme-thumb="custom">
                      <div class="theme-preview theme-preview-custom">
                        <div class="theme-preview-bar"></div>
                        <div class="theme-preview-body"></div>
                      </div>
                      <span data-theme-custom-label data-i18n="theme.custom">Custom</span>
                    </button>
                  </div>
                  <div style="display:flex; gap:8px; margin-top:8px; align-items:center; flex-wrap:wrap;">
                    <button class="btn bevel" type="button" data-theme-custom="save" data-i18n="theme.save">Save Custom</button>
                    <div class="tiny"><span data-i18n="settings.themes.current">Current theme:</span> <span data-theme-current></span></div>
                  </div>
                </div>
                <div class="settings-block" id="settingsTitlebar">
                  <strong data-i18n="settings.titlebar.title">Window Title Color</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.titlebar.desc">Choose the color of the window title bars.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-titlebar="defaultBlue">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#000080,#1084d0);"></span>
                      <span data-i18n="titlebar.defaultBlue">Default Blue</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="pinkLight">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#f6a6cf,#e46aa9);"></span>
                      <span data-i18n="titlebar.pinkLight">Light Pink</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="purpleDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#3a1c5a,#1b0f30);"></span>
                      <span data-i18n="titlebar.purpleDark">Dark Purple</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="offWhite">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#e6e6e6,#cfcfcf);"></span>
                      <span data-i18n="titlebar.offWhite">Off-white</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="greenDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#1b4a2a,#0e2e1a);"></span>
                      <span data-i18n="titlebar.greenDark">Dark Green</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="redDark">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#5a1a1a,#2f0b0b);"></span>
                      <span data-i18n="titlebar.redDark">Dark Red</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="blank">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#b6b6b6,#c9c9c9);"></span>
                      <span data-i18n="titlebar.blank">Blank</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-titlebar="xpBlue">
                      <span class="titlebar-swatch" style="background:linear-gradient(90deg,#0a246a,#3a6ea5);"></span>
                      <span data-i18n="titlebar.xpBlue">XP Blue</span>
                    </button>
                  </div>
                </div>
                <div class="settings-block" id="settingsDarkMode">
                  <strong data-i18n="settings.darkMode.title">Dark Mode</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.darkMode.desc">Makes BLISS 98 darker and easier on the eyes.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-darkmode="on"><span data-i18n="settings.darkMode.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-darkmode="off"><span data-i18n="settings.darkMode.off">Off</span></button>
                  </div>
                </div>
                <div class="settings-block" id="settingsRetro">
                  <strong data-i18n="settings.retro.title">Retro Glow</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.retro.desc">Add a soft glow to windows and icons.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-retro="on"><span data-i18n="settings.retro.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-retro="off"><span data-i18n="settings.retro.off">Off</span></button>
                  </div>
                </div>
                <div class="settings-block" id="settingsWallpaper">
                  <strong data-i18n="settings.wallpaperTab">Wallpaper</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.wallpaperDesc">Choose a wallpaper for your desktop.</p>
                  <div class="grid2">
                    <button class="btn bevel" type="button" data-set-wallpaper="classic">
                      <span class="wallpaper-swatch" style="background:#008080;"></span>
                      <span data-i18n="wallpaper.classic">Classic Teal</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="bliss">
                      <span class="wallpaper-swatch" style="background:radial-gradient(circle at 20% 20%, #fff2c4 0%, #ffb77a 30%, #7fc7ff 65%, #1d5b9e 100%);"></span>
                      <span data-i18n="wallpaper.bliss">Sunrise</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="clouds">
                      <span class="wallpaper-swatch" style="background:linear-gradient(180deg, #9ad0ff 0%, #cfe9ff 45%, #f7fbff 100%);"></span>
                      <span data-i18n="wallpaper.clouds">Clouds</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="diev">
                      <span class="wallpaper-swatch" style="background:repeating-linear-gradient(0deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), repeating-linear-gradient(90deg, rgba(255,255,255,0.08) 0 1px, transparent 1px 6px), linear-gradient(135deg, #0a2333, #114b6a);"></span>
                      <span data-i18n="wallpaper.diev">Grid</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="tot">
                      <span class="wallpaper-swatch" style="background:radial-gradient(circle at 20% 20%, #ffd1e6 0%, #ff9fcb 45%, #ff7fb7 100%);"></span>
                      <span data-i18n="wallpaper.tot">Tot (Pink)</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="matrix">
                      <span class="wallpaper-swatch" style="background:repeating-linear-gradient(90deg, rgba(0,255,90,0.6) 0 2px, transparent 2px 5px), linear-gradient(180deg, #000 0%, #0a1a0f 100%);"></span>
                      <span data-i18n="wallpaper.matrix">Matrix</span>
                    </button>
                    <button class="btn bevel" type="button" data-set-wallpaper="xp98bliss">
                      <span class="wallpaper-swatch" style="background:url('./assets/wallpapers/bliss98.png') center/cover no-repeat;"></span>
                      <span data-i18n="wallpaper.xp98bliss">XP Bliss 98</span>
                    </button>
                  </div>
                </div>
                <div class="settings-block">
                  <strong data-i18n="settings.scanlinesTab">Scanlines</strong>
                  <p style="margin:6px 0 10px 0;" data-i18n="settings.scanlinesDesc">Add scanline effect to the display.</p>
                  <div class="settings-actions">
                    <button class="btn bevel" type="button" data-set-scanlines="on"><span data-i18n="settings.scanlines.on">On</span></button>
                    <button class="btn bevel" type="button" data-set-scanlines="off"><span data-i18n="settings.scanlines.off">Off</span></button>
                  </div>
                </div>
              </div>
              <div class="settings-panel" role="tabpanel" data-tab="performance" id="settingsPanel_performance">
                <div class="settings-panel-header">
                  <div class="settings-panel-icon">
                    <img class="pixel" src="./assets/icons/performance.png" width="48" height="48" alt="" />
                  </div>
                  <div>
                    <strong data-i18n="settings.animationsTab">Animations</strong>
                    <div class="tiny" data-i18n="settings.animationsDesc">Toggle window animations.</div>
                  </div>
                </div>
                <div class="settings-actions">
                  <button class="btn bevel" type="button" data-set-animations="on"><span data-i18n="settings.animations.on">On</span></button>
                  <button class="btn bevel" type="button" data-set-animations="off"><span data-i18n="settings.animations.off">Off</span></button>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      function getDisplayTime(){
        const d = new Date();
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        return `${hh}:${mm}`;
      }
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }


      // --- BLISS Media Player ---
      // NOTE: Browsers cannot scan/list a folder on static hosting (GitHub Pages). We use a manifest file.
      // Create: /assets/music/manifest.json or /assets/audio/tracks.json  Example: ["WOW.mp3","People Change.mp3"]
      const MP_MANIFEST_URL = './assets/audio/tracks.json';
      const MP_LIBRARY_URLS = ['./assets/music/manifest.json', MP_MANIFEST_URL];
      const MP_STATE_KEY = 'bliss98_mp_state';
      const MP_IMPORT_KEY = 'bliss98_mp_imports';

      let mp = {
        tracks: [],
        manifestTracks: [],
        imported: [],
        importedNames: [],
        idx: 0,
        playing: false,
        vol: 0.8,
        loaded: false,
        seeking: false,
        supportsFlac: true,
      };

      function mpSafeTitleFromFilename(name){
        try{
          const base = String(name).split('/').pop();
          const noExt = base.replace(/\.[^/.]+$/,'');
          return decodeURIComponent(noExt);
        } catch {
          return String(name).replace(/\.[^/.]+$/,'');
        }
      }

      function mpLoadState(){
        try{
          const raw = localStorage.getItem(MP_STATE_KEY);
          if(raw){
            const s = JSON.parse(raw);
            if(typeof s.idx === 'number') mp.idx = s.idx;
            if(typeof s.vol === 'number') mp.vol = clamp(s.vol, 0, 1);
          }
        } catch {}
        try{
          const rawImports = localStorage.getItem(MP_IMPORT_KEY);
          mp.importedNames = rawImports ? JSON.parse(rawImports) : [];
          state.mediaplayer.needsReimport = Array.isArray(mp.importedNames) && mp.importedNames.length > 0;
        } catch {
          mp.importedNames = [];
          state.mediaplayer.needsReimport = false;
        }
      }

      function mpSaveState(){
        try{ localStorage.setItem(MP_STATE_KEY, JSON.stringify({ idx: mp.idx, vol: mp.vol })); } catch {}
      }

      function mpResolveTitleFromSrc(src){
        return mpSafeTitleFromFilename(src);
      }

      function mpNormalizeManifest(data, baseDir){
        if(!Array.isArray(data)) return [];
        return data.map(item => {
          if(typeof item === 'string'){
            const file = item.trim();
            const isAbs = /^(https?:)?\//.test(file);
            const src = (isAbs || file.startsWith('.')) ? file : (baseDir + file);
            return { src, title: mpResolveTitleFromSrc(file), kind: 'manifest' };
          }
          if(item && typeof item === 'object' && (item.src || item.file)){
            const raw = String(item.src || item.file);
            const isAbs = /^(https?:)?\//.test(raw);
            const src = (isAbs || raw.startsWith('.')) ? raw : (baseDir + raw);
            return { src, title: item.title ? String(item.title) : mpResolveTitleFromSrc(raw), kind: 'manifest' };
          }
          return null;
        }).filter(Boolean);
      }

      function mpRebuildTracks(){
        mp.tracks = [...mp.manifestTracks, ...mp.imported];
      }

      function mpAddFiles(fileList){
        const files = Array.from(fileList || []);
        if(files.length === 0) return;
        const accepted = files.filter(f => {
          const name = String(f.name || '').toLowerCase();
          const ext = name.split('.').pop();
          return ['flac','mp3','wav','ogg'].includes(ext) || (f.type && f.type.startsWith('audio/'));
        });
        if(accepted.length === 0) return;

        const added = [];
        accepted.forEach(file => {
          const name = String(file.name || '');
          const ext = name.toLowerCase().split('.').pop();
          const src = URL.createObjectURL(file);
          added.push({
            src,
            title: mpSafeTitleFromFilename(name),
            kind: 'local',
            ext,
            file,
          });
        });

        mp.imported = [...mp.imported, ...added];
        mp.importedNames = mp.imported.map(tr => tr.title);
        state.mediaplayer.needsReimport = false;
        try{ localStorage.setItem(MP_IMPORT_KEY, JSON.stringify(mp.importedNames)); } catch {}

        mpRebuildTracks();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        } else {
          mpRender();
        }
      }

      function mpEls(){
        const win = document.getElementById('win_mediaplayer');
        if(!win) return null;
        return {
          win,
          audio: win.querySelector('#mpAudio'),
          now: win.querySelector('#mpNow'),
          msg: win.querySelector('#mpMsg'),
          seek: win.querySelector('#mpSeek'),
          current: win.querySelector('[data-mp-current]'),
          total: win.querySelector('[data-mp-total]'),
          vol: win.querySelector('#mpVol'),
          toggleBtn: win.querySelector('[data-mp-action="toggle"]'),
          shuffleBtn: win.querySelector('[data-mp-action="shuffle"]'),
          repeatBtn: win.querySelector('[data-mp-action="repeat"]'),
          addBtn: win.querySelector('[data-mp-action="add"]'),
          reimportBtn: win.querySelector('[data-mp-action="reimport"]'),
          dropHint: win.querySelector('#mpDropHint'),
          fileInput: win.querySelector('#mpFileInput'),
        };
      }

      function mpRender(){
        const els = mpEls();
        if(!els) return;
        const { now, msg, vol, toggleBtn, audio, shuffleBtn, repeatBtn, reimportBtn } = els;

        if(vol){
          vol.value = String(mp.vol);
        }
        if(audio){
          audio.volume = mp.vol;
        }

        if(msg){
          const hasFlac = mp.tracks.some(tr => {
            const src = String(tr.src || '').toLowerCase();
            return src.endsWith('.flac') || tr.ext === 'flac';
          });
          if(!mp.loaded){
            msg.textContent = t('player.loading');
          } else if(state.mediaplayer.needsReimport){
            msg.textContent = t('player.reimportHint');
          } else if(mp.tracks.length === 0){
            msg.textContent = t('player.notfound');
          } else if(!mp.supportsFlac && hasFlac){
            msg.textContent = t('player.flacUnsupported');
          } else {
            msg.textContent = '';
          }
        }

        const cur = mp.tracks[mp.idx];
        if(now) now.textContent = cur ? cur.title : '';
        if(toggleBtn) toggleBtn.innerHTML = mp.playing ? ` ${t('player.pause')}` : ` ${t('player.play')}`;
        if(shuffleBtn){
          shuffleBtn.textContent = t('player.shuffle');
          shuffleBtn.classList.toggle('pressed', state.mediaplayer.shuffle);
        }
        if(repeatBtn){
          const repeatKey = `player.repeat.${state.mediaplayer.repeat}`;
          repeatBtn.textContent = `${t('player.repeat')} ${t(repeatKey)}`;
          repeatBtn.classList.toggle('pressed', state.mediaplayer.repeat !== 'off');
        }
        if(reimportBtn){
          reimportBtn.classList.toggle('hidden', !state.mediaplayer.needsReimport);
        }
        mpUpdateTime();
      }

      function mpApplyVolume(els){
        if(!els || !els.audio) return;
        if(els.vol){
          els.vol.value = String(mp.vol);
        }
        els.audio.volume = mp.vol;
      }

      function mpBindAudioEventsOnce(audio){
        if(!audio || audio.dataset.mpBound === '1') return;
        audio.dataset.mpBound = '1';
        audio.addEventListener('ended', ()=> mpNext());
        audio.addEventListener('timeupdate', mpUpdateTime);
        audio.addEventListener('loadedmetadata', mpUpdateTime);
        audio.addEventListener('durationchange', mpUpdateTime);
        audio.addEventListener('canplay', mpUpdateTime);
      }

      function mpBindUiEventsOnce(win, els){
        if(!win || win.dataset.mpUiBound === '1') return;
        win.dataset.mpUiBound = '1';

        if(els.vol){
          els.vol.addEventListener('input', ()=>{
            mp.vol = Number(els.vol.value);
            if(els.audio) els.audio.volume = mp.vol;
            mpSaveState();
          });
        }

        if(els.seek){
          els.seek.addEventListener('input', ()=>{
            mp.seeking = true;
            mpSeekTo(els.seek.value);
          });
          els.seek.addEventListener('change', ()=>{
            mp.seeking = false;
            mpSeekTo(els.seek.value);
          });
          els.seek.addEventListener('pointerdown', ()=>{
            mp.seeking = true;
          });
          els.seek.addEventListener('pointerup', ()=>{
            mp.seeking = false;
          });
          els.seek.addEventListener('pointercancel', ()=>{
            mp.seeking = false;
          });
        }

        if(els.fileInput){
          els.fileInput.addEventListener('change', ()=>{
            mpAddFiles(els.fileInput.files);
            mpRender();
          });
        }

        const dropTarget = win.querySelector('.mp-mini');
        if(dropTarget && !dropTarget.dataset.mpDrop){
          dropTarget.dataset.mpDrop = '1';
          const showDrop = (on)=>{
            if(!els.dropHint) return;
            els.dropHint.classList.toggle('hidden', !on);
            els.dropHint.classList.toggle('active', !!on);
          };
          dropTarget.addEventListener('dragover', (e)=>{
            e.preventDefault();
            showDrop(true);
          });
          dropTarget.addEventListener('dragleave', ()=>{
            showDrop(false);
          });
          dropTarget.addEventListener('drop', (e)=>{
            e.preventDefault();
            showDrop(false);
            if(e.dataTransfer && e.dataTransfer.files){
              mpAddFiles(e.dataTransfer.files);
              mpRender();
            }
          });
        }
      }

      function mpFormatTime(raw){
        if(!Number.isFinite(raw)) return '--:--';
        const total = Math.max(0, Math.floor(raw));
        const hours = Math.floor(total / 3600);
        const mins = Math.floor((total % 3600) / 60);
        const secs = total % 60;
        if(hours > 0){
          return `${hours}:${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
        }
        return `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
      }

      function mpUpdateTime(){
        const els = mpEls();
        if(!els) return;
        const { audio, seek, current, total } = els;
        const dur = Number.isFinite(audio.duration) ? audio.duration : 0;
        const cur = Number.isFinite(audio.currentTime) ? audio.currentTime : 0;

        if(seek){
          seek.disabled = !dur;
          if(!dur){
            seek.value = '0';
          } else if(!mp.seeking){
            const ratio = cur / dur;
            seek.value = String(Math.round(ratio * 1000));
          }
        }
        if(current) current.textContent = mpFormatTime(cur);
        if(total) total.textContent = dur ? mpFormatTime(dur) : '--:--';
      }

      function mpSeekTo(value){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        const dur = Number.isFinite(audio.duration) ? audio.duration : 0;
        if(!dur) return;
        const ratio = clamp(Number(value) / 1000, 0, 1);
        audio.currentTime = ratio * dur;
        mpUpdateTime();
      }

      function mpOpenFilePicker(){
        const els = mpEls();
        if(!els || !els.fileInput) return;
        els.fileInput.value = '';
        els.fileInput.click();
      }

      function schedulePlayerAutoplay(){
        if(state.didAutoPlayThisSession) return;
        if(state.autoPlayTimer) clearTimeout(state.autoPlayTimer);
        state.autoPlayTimer = setTimeout(async ()=>{
          if(state.didAutoPlayThisSession) return;
          if(mp.playing) return;
          if(!state.windows.has('mediaplayer')) openApp('mediaplayer');

          const tryPlay = async () => {
            if(mp.tracks.length === 0){
              await mpLoadTracks();
            }
            if(mp.tracks.length === 0) return false;
            if(mp.idx < 0 || mp.idx >= mp.tracks.length){
              mp.idx = 0;
              mpSetTrack(0);
            }
            await mpPlay();
            return mp.playing;
          };

          let ok = await tryPlay();
          if(!ok){
            for(let i=0;i<3;i++){
              await new Promise(r => setTimeout(r, 500));
              ok = await tryPlay();
              if(ok) break;
            }
          }
          if(ok) state.didAutoPlayThisSession = true;
        }, 6000);
      }

      function mpSetTrack(i){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        mp.idx = clamp(i, 0, mp.tracks.length - 1);
        const cur = mp.tracks[mp.idx];
        audio.src = cur.src;
        audio.volume = mp.vol;
        audio.currentTime = 0;
        mpSaveState();
        mpRender();
      }

      async function mpPlay(){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        try{
          await audio.play();
          mp.playing = true;
        } catch {
          mp.playing = false;
        }
        mpRender();
      }

      function mpPause(){
        const els = mpEls();
        if(!els) return;
        els.audio.pause();
        mp.playing = false;
        mpRender();
      }

      function mpNext(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle){
          let next = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && next === mp.idx){
            next = (next + 1) % mp.tracks.length;
          }
          mpSetTrack(next);
          mpPlay();
          return;
        }
        if(!manual && state.mediaplayer.repeat === 'one'){
          mpSetTrack(mp.idx);
          mpPlay();
          return;
        }
        const atEnd = (mp.idx === mp.tracks.length - 1);
        if(atEnd && !manual && state.mediaplayer.repeat === 'off'){
          mpPause();
          return;
        }
        const nextIdx = atEnd ? 0 : mp.idx + 1;
        mpSetTrack(nextIdx);
        mpPlay();
      }

      function mpPrev(manual=false){
        if(mp.tracks.length === 0) return;
        if(state.mediaplayer.shuffle && !manual){
          let prev = Math.floor(Math.random() * mp.tracks.length);
          if(mp.tracks.length > 1 && prev === mp.idx){
            prev = (prev + 1) % mp.tracks.length;
          }
          mpSetTrack(prev);
          mpPlay();
          return;
        }
        const prevIdx = (mp.idx - 1 + mp.tracks.length) % mp.tracks.length;
        mpSetTrack(prevIdx);
        mpPlay();
      }

      async function mpLoadTracks(){
        mp.loaded = false;
        mp.manifestTracks = [];
        mpRebuildTracks();
        mpRender();

        try{
          let loaded = false;
          for(const url of MP_LIBRARY_URLS){
            const res = await fetch(url, { cache: 'no-store' });
            if(!res.ok) continue;
            const data = await res.json();
            if(Array.isArray(data) || Array.isArray(data.tracks)){
              const baseDir = url.includes('./assets/music/') ? './assets/music/' : './assets/audio/';
              const list = Array.isArray(data) ? data : data.tracks;
              mp.manifestTracks = mpNormalizeManifest(list, baseDir);
              loaded = true;
              break;
            }
          }
          if(!loaded){
            mp.manifestTracks = [];
          }
        } catch {
          mp.manifestTracks = [];
        }

        mp.loaded = true;
        mpLoadState();
        mpRebuildTracks();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        }
        mpRender();
      }

      function mpInitInWindow(){
        const els = mpEls();
        if(!els) return;
        const { audio, win } = els;
        mpBindAudioEventsOnce(audio);
        mpBindUiEventsOnce(win, els);
        mp.supportsFlac = !!audio.canPlayType('audio/flac');
        mpApplyVolume(els);
        mpUpdateTime();
        // Load tracks each time window is (re)rendered
        mpLoadTracks();
      }

      // Delegate Media Player button clicks
      document.addEventListener('click', (e)=>{
        const actBtn = e.target.closest && e.target.closest('[data-mp-action]');
        if(actBtn){
          const action = actBtn.dataset.mpAction;
          if(action === 'toggle'){
            if(mp.playing) mpPause(); else mpPlay();
          }
          if(action === 'next') mpNext(true);
          if(action === 'prev') mpPrev(true);
          if(action === 'shuffle'){
            state.mediaplayer.shuffle = !state.mediaplayer.shuffle;
            mpRender();
          }
          if(action === 'repeat'){
            const order = ['off', 'one', 'all'];
            const idx = order.indexOf(state.mediaplayer.repeat);
            state.mediaplayer.repeat = order[(idx + 1) % order.length];
            mpRender();
          }
          if(action === 'add' || action === 'reimport'){
            mpOpenFilePicker();
          }
        }

        const pickBtn = e.target.closest && e.target.closest('[data-mp-pick]');
        if(pickBtn){
          const idx = Number(pickBtn.dataset.mpPick);
          state.mediaplayer.selected = new Set([idx]);
          mpSetTrack(idx);
          mpPlay();
        }
      });

      document.addEventListener('dblclick', (e)=>{
        const card = e.target.closest && e.target.closest('[data-music-id]');
        if(card && card.dataset && card.dataset.musicLink){
          e.preventDefault();
          openLink(card.dataset.musicLink, 'music');
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem && poemItem.dataset && poemItem.dataset.poemId){
          e.preventDefault();
          state.poetry.view = 'read';
          state.poetry.currentId = poemItem.dataset.poemId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem && trashItem.dataset && trashItem.dataset.trashId){
          e.preventDefault();
          restoreFromTrash([trashItem.dataset.trashId]);
        }
      });

      let lastPoetryTap = { id: null, time: 0 };
      document.addEventListener('pointerdown', (e)=>{
        if(e.pointerType !== 'touch') return;
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard && musicCard.dataset && musicCard.dataset.musicLink){
          const id = musicCard.dataset.musicId;
          state.music.selected = new Set([id]);
          applyMusicState();
          musicCard.dataset.touchOpened = '1';
          openLink(musicCard.dataset.musicLink, 'music');
          return;
        }
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(!poemItem || !poemItem.dataset) return;
        const id = poemItem.dataset.poemId;
        const now = Date.now();
        if(lastPoetryTap.id === id && (now - lastPoetryTap.time) < 320){
          state.poetry.view = 'read';
          state.poetry.currentId = id;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
          lastPoetryTap = { id: null, time: 0 };
        } else {
          lastPoetryTap = { id, time: now };
        }
      });

      document.addEventListener('mouseover', (e)=>{
        if(!state.menuOpen) return;
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          openWindowMenu(winEl, menuKey, menuToggle);
        }
      });

      // Prevent browser text selection on desktop drags (keep selection inside .content and inputs)
      document.addEventListener('selectstart', (e)=>{
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(tag === 'input' || tag === 'textarea') return;
        if(e.target && e.target.closest && e.target.closest('.content')) return;
        e.preventDefault();
      });

      function setUser(name){
        state.user = name;
        localStorage.setItem('bliss98_user', name);
        $('#who').textContent = name ? name : '';
      }

      function showDesktop(){
        $('#login').classList.add('hidden');
        $('#desktop').classList.remove('hidden');
        $('#username').blur();
        themeApplying = true;
        applyWallpaper(state.wallpaper);
        themeApplying = false;
        renderIcons();
        renderStartMenu();
        tickClock();
      }
      let logoffInProgress = false;

      function showLogin(playBoot = false){
        $('#desktop').classList.add('hidden');
        $('#login').classList.remove('hidden');
        $('#username').focus();
        if(playBoot && SFX.boot && !SFX.boot.played){
          playSfxOnce('boot', { allowPending: true }).then((ok)=>{
            if(!ok && !SFX.boot.played) armBootUnlock();
          });
        }
      }

      function doLogoff(){
        if(logoffInProgress) return;
        logoffInProgress = true;
        if(state.autoPlayTimer){
          clearTimeout(state.autoPlayTimer);
          state.autoPlayTimer = null;
        }
        state.didAutoPlayThisSession = false;
        closeStartMenu();
        closeCtxMenu();
        closeWindowMenu();
        closeModal();
        playSfxAndWait('logoff').finally(()=>{
          showLogin(false);
          logoffInProgress = false;
        });
      }

function renderIcons(){
  const grid = $('#iconGrid');
  grid.innerHTML = '';

  const saved = loadIconPositions();
  const metrics = getGridMetrics();
  const occupied = new Map();
  let needsSave = false;
  const defaultLayout = getDefaultIconLayout();

  const desktopItems = [
    ...APPS.filter(app => app.showOnDesktop !== false).map(app => ({ type:'app', item: app })),
    ...VIRTUAL_ICONS.map(v => ({ type:'virtual', item: v }))
  ];

  desktopItems.forEach(({ type, item }, idx) => {
    const id = item.id;
    if(id !== 'trash' && state.trash.has(id)) return;
    if(isInFolder(id)) return;
    const el = document.createElement('div');
    el.className = 'icon';
    el.dataset.appId = id;

    const def = defaultLayout[id] || legacyDefaultIconPos(idx);
    const pos = (saved && saved[id]) ? saved[id] : def;
    const placed = placeOnFreeCell(pos.x, pos.y, occupied, metrics);
    el.style.left = placed.x + 'px';
    el.style.top = placed.y + 'px';
    if(placed.changed || !saved[id]){
      saved[id] = { x: placed.x, y: placed.y };
      needsSave = true;
    }

    const label = (type === 'virtual') ? t(item.titleKey) : getIconLabel(item);
    const iconFile = type === 'virtual' ? item.iconFile : (typeof item.iconFile === 'function' ? item.iconFile() : item.iconFile);
    const iconHtml = iconFile
      ? `<img class="pixel" src="${iconFile}" width="32" height="32" alt="${label}" style="display:block;" />`
      : iconSVG(item.icon);

          el.innerHTML = `
            <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
            <span>${label}</span>
          `;
    if(state.trash.has(id)) el.classList.add('trashed');

          // Click select
          el.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(el.dataset.dragged === '1'){
              // prevent post-drag click from changing selection unexpectedly
              el.dataset.dragged = '0';
              return;
            }
      selectIcon(id);
    });

          // Double click open
          el.addEventListener('dblclick', (e)=>{
            e.stopPropagation();
      openIconById(id);
    });

    makeIconDraggable(el);
    el.addEventListener('contextmenu', (ev)=>{
      ev.preventDefault();
      ev.stopPropagation();
      openCtxMenu(ev.clientX, ev.clientY, 'icon', id);
    });
    installLongPress(el, ()=>({ target:'icon', appId: id }));
    grid.appendChild(el);
  });
        if(needsSave) saveIconPositions(saved);
      }
      function selectIcon(id){
        state.selectedIconId = id;
        $$('.icon').forEach(i=>i.classList.toggle('selected', i.dataset.appId === id));
      }

      function makeIconDraggable(iconEl){
        let down = false;
        let dragging = false;
        let pointerId = null;
        let movedToLayer = false;
        let lastEvent = null;

        let startX = 0, startY = 0;
        let group = [];
        let startPositions = []; // { el, id, x, y }

        // group bounds + allowed delta range
        let dxMin = 0, dxMax = 0, dyMin = 0, dyMax = 0;

        const dragLayer = $('#dragLayer');
        const onWindowBlur = ()=>{
          endDrag(lastEvent, true);
        };
        const onDocPointerUp = (e)=>{
          if(pointerId !== null && e.pointerId !== pointerId) return;
          endDrag(e, false);
        };
        const endDrag = (e, cancel)=>{
          if(!down) return;
          if(pointerId !== null && e && e.pointerId !== pointerId) return;

          down = false;
          document.removeEventListener('pointermove', onPointerMove);
          document.removeEventListener('pointerup', onPointerUp);
          document.removeEventListener('pointercancel', onPointerUp);
          window.removeEventListener('blur', onWindowBlur);

          document.body.classList.remove('dragging');

          if(dragging && !cancel && e){
            const ids = startPositions.map(p => p.id);
            if(isOverTrashWindow(e.clientX, e.clientY) || isOverTrash(e.clientX, e.clientY)){
              restoreGroupLayer();
              moveIconsToTrash(ids);
            } else if(isOverGamesWindow(e.clientX, e.clientY)){
              addToFolder('games', ids);
              const saved = loadIconPositions();
              ids.forEach(id => { delete saved[id]; });
              saveIconPositions(saved);
              restoreGroupLayer();
              renderIcons();
              renderGamesWindow();
            } else {
              restoreGroupLayer();
              // Save all moved positions in one write
              const saved = loadIconPositions();
              const metrics = getGridMetrics();
              const movedIds = new Set(ids);
              const occupied = new Map();

              APPS.forEach((app, idx) => {
                if(movedIds.has(app.id)) return;
                const base = saved[app.id] || defaultIconPos(idx);
                const placed = placeOnFreeCell(base.x, base.y, occupied, metrics);
                if(placed.changed || !saved[app.id]){
                  saved[app.id] = { x: placed.x, y: placed.y };
                }
              });

              startPositions.forEach(p => {
                let x = parseInt(p.el.style.left || '0', 10);
                let y = parseInt(p.el.style.top || '0', 10);

                if(state.gridSnap){
                  const snapped = snapToGrid(x, y);
                  x = snapped.x;
                  y = snapped.y;
                }

                const placed = placeOnFreeCell(x, y, occupied, metrics);
                p.el.style.left = placed.x + 'px';
                p.el.style.top = placed.y + 'px';
                saved[p.id] = { x: placed.x, y: placed.y };
                p.el.dataset.dragged = '1';
              });
              saveIconPositions(saved);
            }
          } else if(dragging){
            restoreGroupLayer();
          }

          dragging = false;
          pointerId = null;
        };
        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;

          e.stopPropagation();
          closeStartMenu();
          closeCtxMenu();

          // If multiple icons are selected and the one we grabbed is selected, drag the whole group.
          const selectedEls = $$('.icon.selected');
          const isSelected = iconEl.classList.contains('selected');
          if(selectedEls.length > 1 && isSelected){
            group = selectedEls;
          } else {
            // Otherwise, single-select the grabbed icon
            selectIcon(iconEl.dataset.appId);
            group = [iconEl];
          }

          down = true;
          dragging = false;
          pointerId = e.pointerId;
          startX = e.clientX;
          startY = e.clientY;
          movedToLayer = false;

          // Snapshot starting positions
          startPositions = group.map(el => ({
            el,
            id: el.dataset.appId,
            x: parseInt(el.style.left || '0', 10),
            y: parseInt(el.style.top || '0', 10)
          }));

          // Compute bounds in desktop coordinates (relative to desktopArea)
          const area = $('#desktopArea').getBoundingClientRect();
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          startPositions.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x + ICON_SIZE.w);
            maxY = Math.max(maxY, p.y + ICON_SIZE.h);
          });

          // Right/bottom limits match `clampIconPos` behavior (icon right edge <= area.width - 6)
          dxMin = -minX;
          dxMax = (Math.floor(area.width - 6) - maxX);
          dyMin = -minY;
          dyMax = (Math.floor(area.height - 6) - maxY);

          // Prevent accidental post-drag clicks
          group.forEach(el => (el.dataset.dragged = '0'));

          document.body.classList.add('dragging');
          document.addEventListener('pointermove', onPointerMove);
          document.addEventListener('pointerup', onPointerUp);
          document.addEventListener('pointercancel', onPointerUp);
          window.addEventListener('blur', onWindowBlur);

          e.preventDefault();
        };

        const moveGroupToLayer = ()=>{
          if(movedToLayer || !dragLayer) return;
          dragLayer.classList.add('active');
          group.forEach(el => {
            dragLayer.appendChild(el);
            el.style.zIndex = '9999';
          });
          movedToLayer = true;
        };

        const restoreGroupLayer = ()=>{
          if(!movedToLayer) return;
          const grid = $('#iconGrid');
          group.forEach(el => {
            grid.appendChild(el);
            el.style.zIndex = '';
          });
          if(dragLayer) dragLayer.classList.remove('active');
          movedToLayer = false;
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;
          lastEvent = e;

          const dxRaw = e.clientX - startX;
          const dyRaw = e.clientY - startY;

          if(!dragging && (Math.abs(dxRaw) + Math.abs(dyRaw) > 4)){
            dragging = true;
            moveGroupToLayer();
          }
          if(!dragging) return;

          // Clamp movement so the whole group stays within the desktop
          const dx = clamp(dxRaw, dxMin, dxMax);
          const dy = clamp(dyRaw, dyMin, dyMax);

          // Move all icons in the group
          startPositions.forEach(p => {
            p.el.style.left = (p.x + dx) + 'px';
            p.el.style.top = (p.y + dy) + 'px';
          });

          e.preventDefault();
        };

        const onPointerUp = (e)=>{
          endDrag(e, false);
        };

        // Pointer events handle mouse + touch + pen
        iconEl.addEventListener('pointerdown', onPointerDown);
      }

      $('#desktopArea').addEventListener('click', ()=>{
        // If a selection drag just happened, do not treat it as a click
        if($('#desktopArea').dataset.selDragged === '1'){
          $('#desktopArea').dataset.selDragged = '0';
          return;
        }
        state.selectedIconId = null;
        $$('.icon').forEach(i=>i.classList.remove('selected'));
        closeStartMenu();
        closeCtxMenu();
      });

      // Right-click / two-finger click on desktop
      $('#desktopArea').addEventListener('contextmenu', (e)=>{
        if($('#desktop').classList.contains('hidden')) return;
        if(e.target && e.target.closest && e.target.closest('.icon')) return;
        if(e.target && e.target.closest && e.target.closest('.window')) return;
        e.preventDefault();
        openCtxMenu(e.clientX, e.clientY, 'desktop', null);
      });

      // Long-press on desktop (mobile/touch)
      installLongPress($('#desktopArea'), ()=>({ target:'desktop', appId:null }));

      // Rubber-band selection (Windows 98 style)
      (function installRubberbandSelection(){
        const areaEl = $('#desktopArea');
        const rb = $('#rubberband');
        if(!areaEl || !rb) return;

        let down = false;
        let active = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let lastRect = null;

        function rectFrom(aX, aY, bX, bY){
          const x1 = Math.min(aX, bX);
          const y1 = Math.min(aY, bY);
          const x2 = Math.max(aX, bX);
          const y2 = Math.max(aY, bY);
          return { x:x1, y:y1, w:(x2-x1), h:(y2-y1) };
        }

        function intersects(r, elRect){
          return !(elRect.right < r.x || elRect.left > (r.x + r.w) || elRect.bottom < r.y || elRect.top > (r.y + r.h));
        }

        function updateRubberband(r){
          rb.style.left = r.x + 'px';
          rb.style.top = r.y + 'px';
          rb.style.width = r.w + 'px';
          rb.style.height = r.h + 'px';
        }

        function clearRubberband(){
          rb.classList.add('hidden');
          rb.style.width = '0px';
          rb.style.height = '0px';
          lastRect = null;
          document.body.classList.remove('dragging');
        }

        function selectByRect(r){
          // Select icons whose bounding boxes intersect with the rubberband rect
          const icons = $$('.icon');
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const area = areaEl.getBoundingClientRect();
            const rel = {
              left: rect.left - area.left,
              right: rect.right - area.left,
              top: rect.top - area.top,
              bottom: rect.bottom - area.top,
            };
            const hit = intersects(r, rel);
            icon.classList.toggle('selected', hit);
          });
        }

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Don't start a box if user is interacting with icons/windows/menus
          if(e.target && e.target.closest && (e.target.closest('.icon') || e.target.closest('.window') || e.target.closest('#startMenu') || e.target.closest('#ctxMenu'))){
            return;
          }

          down = true;
          active = false;
          pointerId = e.pointerId;

          const area = areaEl.getBoundingClientRect();
          startX = e.clientX - area.left;
          startY = e.clientY - area.top;

          try{ areaEl.setPointerCapture(pointerId); } catch {}
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const area = areaEl.getBoundingClientRect();
          const curX = e.clientX - area.left;
          const curY = e.clientY - area.top;

          const dx = curX - startX;
          const dy = curY - startY;

          // Activate after small movement threshold
          if(!active && (Math.abs(dx) + Math.abs(dy) > 6)){
            active = true;
            rb.classList.remove('hidden');
            document.body.classList.add('dragging');
            // Close menus
            closeStartMenu();
            closeCtxMenu();
            // Clear single selection
            state.selectedIconId = null;
          }
          if(!active) return;

          e.preventDefault();

          const r = rectFrom(startX, startY, curX, curY);
          lastRect = r;
          updateRubberband(r);
          selectByRect(r);
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ areaEl.releasePointerCapture(e.pointerId); } catch {}

          if(active){
            // Prevent click clear right after box select
            areaEl.dataset.selDragged = '1';
            active = false;
            clearRubberband();
          }
          pointerId = null;
        };

        areaEl.addEventListener('pointerdown', onPointerDown);
        areaEl.addEventListener('pointermove', onPointerMove);
        areaEl.addEventListener('pointerup', onPointerUp);
        areaEl.addEventListener('pointercancel', onPointerUp);
      })();

      function renderStartMenu(){
        const list = $('#startList');
        list.innerHTML = '';
        APPS.filter(app => app.showInStart !== false).forEach(app => {
          const item = document.createElement('div');
          item.className = 'menu-item';
          const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
          item.innerHTML = `
            <div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;">${iconFile ? `<img class="pixel" src="${iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${app.id}" />` : iconSVG(app.icon)}</div>
            <div>${t(app.titleKey)}</div>
          `;
          item.addEventListener('click', ()=>{ openApp(app.id); closeStartMenu(); });
          list.appendChild(item);
        });

        const sep = document.createElement('div');
        sep.className = 'menu-sep';
        list.appendChild(sep);

        const logout = document.createElement('div');
        logout.className = 'menu-item';
        logout.innerHTML = `<div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;"><img class="pixel" src="./assets/icons/logout.png" width="16" height="16" alt="" style="display:block;" /></div><div>${t('menu.logoff')}</div>`;
        logout.addEventListener('click', ()=>{ closeStartMenu(); doLogoff(); });
        list.appendChild(logout);
      }

      function toggleStartMenu(){
        const menu = $('#startMenu');
        const btn = $('#startBtn');
        const isOpen = !menu.classList.contains('hidden');
        if(isOpen) closeStartMenu();
        else { menu.classList.remove('hidden'); btn.classList.add('pressed'); }
      }
      function closeStartMenu(){
        $('#startMenu').classList.add('hidden');
        $('#startBtn').classList.remove('pressed');
      }
      $('#startBtn').addEventListener('click', (e)=>{ e.stopPropagation(); toggleStartMenu(); });

      function defaultWindowRect(){
        const area = $('#desktopArea').getBoundingClientRect();
        const w = clamp(Math.round(area.width * 0.56), 320, 720);
        const h = clamp(Math.round(area.height * 0.58), 240, 640);
        const left = Math.round((area.width - w) * (0.18 + Math.random()*0.18));
        const top = Math.round((area.height - h) * (0.12 + Math.random()*0.18));
        return { left, top, width:w, height:h };
      }

      function getSavedWindowRect(appId){
        try{
          const raw = localStorage.getItem(`bliss98_window_${appId}`);
          if(!raw) return null;
          const parsed = JSON.parse(raw);
          if(!parsed) return null;
          const { left, top, width, height } = parsed;
          if(!Number.isFinite(left) || !Number.isFinite(top) || !Number.isFinite(width) || !Number.isFinite(height)) return null;
          return { left, top, width, height };
        } catch {
          return null;
        }
      }

      function normalizeWindowRect(rect, area, margin = 16){
        const maxW = Math.max(240, Math.floor(area.width - margin * 2));
        const maxH = Math.max(200, Math.floor(area.height - margin * 2));
        const width = clamp(rect.width, 240, maxW);
        const height = clamp(rect.height, 200, maxH);
        const left = clamp(rect.left, margin, Math.max(margin, area.width - width - margin));
        const top = clamp(rect.top, margin, Math.max(margin, area.height - height - margin));
        return { left, top, width, height };
      }

      // Auto-fit windows to their rendered content on first open (when no saved/manual size exists).
function installAutoFitObserver(winEl, appId){
  if(!winEl || winEl.dataset.autoFitObserver) return;
  const content = winEl.querySelector('.content');
  if(!content) return;
  const w = state.windows.get(appId);
  const observer = new MutationObserver(()=>{
    if(winEl.classList.contains('mobile-game')) return;
    autoFitWindow(winEl, appId);
  });
  observer.observe(content, { childList: true, subtree: true, characterData: true });
  winEl.dataset.autoFitObserver = '1';
  if(w) w.autoFitObserver = observer;
}

function autoFitWindow(winEl, appId){
  if(!winEl) return;
  const w = state.windows.get(appId);
  if(!w || w.userSized) return;
  if(winEl.classList.contains('mobile-game')) return;

        requestAnimationFrame(()=>{
          requestAnimationFrame(()=>{
            const frame = winEl.querySelector('.frame');
            const content = winEl.querySelector('.content');
            if(!frame || !content) return;

            const area = $('#desktopArea').getBoundingClientRect();
            const frameRect = frame.getBoundingClientRect();
            const contentRect = content.getBoundingClientRect();
            const extraW = frameRect.width - contentRect.width;
            const extraH = frameRect.height - contentRect.height;

            let maxRight = 0;
            let maxBottom = 0;
            Array.from(content.children).forEach((el)=>{
              if(!el.getBoundingClientRect) return;
              const r = el.getBoundingClientRect();
              maxRight = Math.max(maxRight, r.right - contentRect.left);
              maxBottom = Math.max(maxBottom, r.bottom - contentRect.top);
            });
            let intrinsicW = maxRight > 0 ? maxRight : Math.max(content.scrollWidth, content.clientWidth);
            let intrinsicH = maxBottom > 0 ? maxBottom : Math.max(content.scrollHeight, content.clientHeight);

            let targetW = Math.ceil(intrinsicW + extraW);
            let targetH = Math.ceil(intrinsicH + extraH);

            const fitMinW = parseInt(content.dataset.fitMinW || '0', 10) || 0;
            const fitMinH = parseInt(content.dataset.fitMinH || '0', 10) || 0;
            if(fitMinW) targetW = Math.max(targetW, fitMinW);
            if(fitMinH) targetH = Math.max(targetH, fitMinH);

            const currentRect = winEl.getBoundingClientRect();
            if(Math.abs(targetW - currentRect.width) < 2 && Math.abs(targetH - currentRect.height) < 2) return;

            const fitKey = content.dataset.fitKey || '';
            if(fitKey){
              if(!w.fitCache) w.fitCache = {};
              const cached = w.fitCache[fitKey];
              if(cached){
                cached.width = Math.max(cached.width, targetW);
                cached.height = Math.max(cached.height, targetH);
                targetW = cached.width;
                targetH = cached.height;
              } else {
                w.fitCache[fitKey] = { width: targetW, height: targetH };
              }
            }

            const normalized = normalizeWindowRect({ left: w.left, top: w.top, width: targetW, height: targetH }, area, 16);
            w.left = normalized.left;
            w.top = normalized.top;
            w.width = normalized.width;
            w.height = normalized.height;
            w.lastFitKey = fitKey;
            w.lastFitW = normalized.width;
            w.lastFitH = normalized.height;

            winEl.style.left = w.left + 'px';
            winEl.style.top = w.top + 'px';
            winEl.style.width = w.width + 'px';
            winEl.style.height = w.height + 'px';
          });
        });
      }

      function sizeWindowToContent(winEl, appId){
        if(!winEl) return;
        const frame = winEl.querySelector('.frame');
        const content = winEl.querySelector('.content');
        if(!frame || !content) return;

        const area = $('#desktopArea').getBoundingClientRect();
        const frameRect = frame.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const extraW = frameRect.width - contentRect.width;
        const extraH = frameRect.height - contentRect.height;

        const targetW = Math.ceil(Math.max(content.scrollWidth, content.clientWidth) + extraW);
        const targetH = Math.ceil(Math.max(content.scrollHeight, content.clientHeight) + extraH);

        const maxW = Math.max(280, Math.floor(area.width));
        const maxH = Math.max(200, Math.floor(area.height));
        const newW = clamp(targetW, 280, maxW);
        const newH = clamp(targetH, 200, maxH);

        let newL = parseFloat(winEl.style.left) || 0;
        let newT = parseFloat(winEl.style.top) || 0;
        if(newL + newW > maxW) newL = Math.max(0, maxW - newW);
        if(newT + newH > maxH) newT = Math.max(0, maxH - newH);

        winEl.style.width = newW + 'px';
        winEl.style.height = newH + 'px';
        winEl.style.left = newL + 'px';
        winEl.style.top = newT + 'px';

        const w = state.windows.get(appId);
        if(w){
          w.width = newW;
          w.height = newH;
          w.left = newL;
          w.top = newT;
        }
      }

      function openApp(appId){
        const app = APPS.find(a=>a.id===appId);
        if(!app) return;

        if(state.windows.has(appId)){
          const w = state.windows.get(appId);
          w.minimized = false;
          const el = document.getElementById(`win_${appId}`);
          if(el) el.classList.remove('hidden');
          focusWindow(appId);
          renderTaskButtons();
          return;
        }

        let rect = defaultWindowRect();
        if(appId === 'mediaplayer'){
          const area = $('#desktopArea').getBoundingClientRect();
          const maxW = Math.max(260, Math.floor(area.width - 40));
          const maxH = Math.max(180, Math.floor(area.height - 80));
          rect.width = clamp(360, 260, maxW);
          rect.height = clamp(210, 180, maxH);
        }
        const area = $('#desktopArea').getBoundingClientRect();
        const savedRect = getSavedWindowRect(appId);
        if(savedRect){
          rect = normalizeWindowRect(savedRect, area, 16);
        } else {
          rect = normalizeWindowRect(rect, area, 16);
        }
        const iconFile = typeof app.iconFile === 'function' ? app.iconFile() : app.iconFile;
        const wstate = {
          id: appId,
          title: t(app.titleKey),
          titleKey: app.titleKey,
          icon: app.icon,
          iconFile: iconFile || null,
          minimized: false,
          fit: false,
          prevRect: null,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          z: ++state.zTop,
          savedRect: Boolean(savedRect),
          userSized: false,
          autoFitObserver: null,
          lastFitKey: '',
          lastFitW: 0,
          lastFitH: 0,
          fitCache: null,
        };
        state.windows.set(appId, wstate);
        createWindowElement(wstate);
        focusWindow(appId);
        renderTaskButtons();
      }

      function closeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        if(appId === 'games'){
          snakeStop();
          DopeSkateGame.unmount();
          state.games.view = 'list';
          state.games.selectedId = null;
        }
        state.windows.delete(appId);
        const el = document.getElementById(`win_${appId}`);
        if(w.autoFitObserver) w.autoFitObserver.disconnect();
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
        if(el){
          if(state.animations){
            el.classList.add('anim-close');
            el.addEventListener('animationend', ()=>{ el.remove(); }, { once:true });
          } else {
            el.remove();
          }
        }
      }
      function minimizeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.minimized = true;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          if(state.animations){
            const winRect = el.getBoundingClientRect();
            const taskbar = document.getElementById('taskbar');
            const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
            const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
            const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
            const dx = targetX - winRect.left;
            const dy = targetY - winRect.top;
            el.style.setProperty('--min-x', `${dx}px`);
            el.style.setProperty('--min-y', `${dy}px`);
            el.classList.add('anim-minimize');
            el.addEventListener('animationend', ()=>{
              el.classList.remove('anim-minimize');
              el.classList.add('hidden');
              el.style.removeProperty('--min-x');
              el.style.removeProperty('--min-y');
            }, { once:true });
          } else {
            el.classList.add('hidden');
          }
        }
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
      }

      function toggleFitWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        const winEl = document.getElementById(`win_${appId}`);
        if(!winEl) return;

        if(w.fit && w.prevRect){
          const area = $('#desktopArea').getBoundingClientRect();
          const normalized = normalizeWindowRect({
            left: w.left,
            top: w.top,
            width: w.prevRect.width,
            height: w.prevRect.height
          }, area, 16);
          w.left = normalized.left;
          w.top = normalized.top;
          w.width = normalized.width;
          w.height = normalized.height;
          w.fit = false;
          w.prevRect = null;
          winEl.style.left = w.left + 'px';
          winEl.style.top = w.top + 'px';
          winEl.style.width = w.width + 'px';
          winEl.style.height = w.height + 'px';
          return;
        }

        const frame = winEl.querySelector('.frame');
        const content = winEl.querySelector('.content');
        if(!frame || !content) return;

        w.prevRect = { left: w.left, top: w.top, width: w.width, height: w.height };

        const frameRect = frame.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const extraW = frameRect.width - contentRect.width;
        const extraH = frameRect.height - contentRect.height;
        const targetContentW = Math.max(content.scrollWidth, content.clientWidth);
        const targetContentH = Math.max(content.scrollHeight, content.clientHeight);

        const area = $('#desktopArea').getBoundingClientRect();
        const maxW = Math.max(320, Math.floor(area.width));
        const maxH = Math.max(220, Math.floor(area.height));

        let newW = Math.ceil(targetContentW + extraW);
        let newH = Math.ceil(targetContentH + extraH);

        newW = clamp(newW, 280, maxW);
        newH = clamp(newH, 200, maxH);

        let newL = w.left;
        let newT = w.top;
        if(newL + newW > maxW) newL = Math.max(0, maxW - newW);
        if(newT + newH > maxH) newT = Math.max(0, maxH - newH);

        w.left = newL;
        w.top = newT;
        w.width = newW;
        w.height = newH;
        w.fit = true;

        winEl.style.left = newL + 'px';
        winEl.style.top = newT + 'px';
        winEl.style.width = newW + 'px';
        winEl.style.height = newH + 'px';
      }

      function focusWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.z = ++state.zTop;
        state.activeWindowId = appId;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          el.style.zIndex = String(w.z);
          $$('.window').forEach(winEl=>{
            winEl.dataset.active = (winEl.id === `win_${appId}`) ? '1' : '0';
            const tb = winEl.querySelector('.titlebar');
            if(tb) tb.style.filter = (winEl.dataset.active==='1') ? 'none' : 'grayscale(0.35) brightness(0.9)';
          });
        }
        renderTaskButtons();
      }

      function createWindowElement(wstate){
        const appId = wstate.id;
        const el = document.createElement('div');
        el.className = 'window';
        el.id = `win_${appId}`;
        el.style.left = wstate.left + 'px';
        el.style.top = wstate.top + 'px';
        el.style.width = wstate.width + 'px';
        el.style.height = wstate.height + 'px';
        el.style.zIndex = String(wstate.z);
        el.style.visibility = 'hidden';
        if(state.animations) el.classList.add('anim-open');

        const bodyHTML = (CONTENT[appId] ? CONTENT[appId]() : `<h2>${wstate.title}</h2><p>Sem contedo.</p>`);

        el.innerHTML = `
          <div class="frame bevel">
            <div class="titlebar" data-drag="1">
              <div class="title-left">
                <span style="width:16px;height:16px;display:inline-flex;">${wstate.iconFile ? `<img class="pixel" src="${wstate.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(wstate.icon)}</span>
                <strong>${wstate.title}</strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" title="${t('win.minimize')}" data-action="min">_</div>
                <div class="wctl bevel" title="${t('win.maximize')}" data-action="max">[]</div>
                <div class="wctl bevel" title="${t('win.close')}" data-action="close"></div>
              </div>
            </div>
            ${appId === 'trash'
              ? `<div class="trash-actions">
                  <button class="btn bevel" type="button" data-trash-action="restore">${t('dialog.trash.restore')}</button>
                  <button class="btn bevel" type="button" data-trash-action="restoreAll">${t('dialog.trash.restoreAll')}</button>
                  <button class="btn bevel" type="button" data-trash-action="empty">${t('dialog.trash.emptyAction')}</button>
                  <button class="btn bevel" type="button" data-trash-action="help">${t('menu.help.controls')}</button>
                </div>`
              : `<div class="menubar">
                  <span data-menu="file" data-i18n="menubar.file">${t('menubar.file')}</span>
                  <span data-menu="edit" data-i18n="menubar.edit">${t('menubar.edit')}</span>
                  <span data-menu="view" data-i18n="menubar.view">${t('menubar.view')}</span>
                  <span data-menu="help" data-i18n="menubar.help">${t('menubar.help')}</span>
                </div>
                <div class="menu-drop hidden"></div>`}
            <div class="content">${bodyHTML}</div>
            <div class="statusbar">
              <span data-i18n="status.ready">${t('status.ready')}</span>
              <span class="status-center" data-i18n="about.footer">${t('about.footer')}</span>
              <span>BLISS 98</span>
            </div>
          </div>
          <div class="resize" title="${t('win.resize')}"></div>
        `;

        el.addEventListener('mousedown', (e)=>{ e.stopPropagation(); focusWindow(appId); closeStartMenu(); });
        el.addEventListener('contextmenu', (e)=>{
          e.preventDefault();
          e.stopPropagation();
        });
        el.addEventListener('click', (e)=>{
          const act = e.target?.dataset?.action;
          if(!act) return;
          e.stopPropagation();
          if(act==='close') closeApp(appId);
          if(act==='min') minimizeApp(appId);
          if(act==='max') toggleFitWindow(appId);
        });

        makeDraggable(el, appId);
        makeResizable(el, appId);

        if(appId === 'mediaplayer') { setTimeout(mpInitInWindow, 0); }
        if(appId === 'trash') { updateTrashIconUI(); }
        if(appId === 'clothes') { setTimeout(()=>initClothesWindow(el), 0); }
        if(appId === 'settings') { setTimeout(()=>initSettingsTabs(el), 0); }
        if(appId === 'games') { setTimeout(()=>initGamesWindow(el), 0); }
        if(appId === 'videos') { setTimeout(()=>initVideosWindow(el), 0); }

        $('#windows').appendChild(el);
        applyI18nTo(el);
        applyWindowState(el, appId);
        if(appId === 'trash') updateTrashIconUI();
        // Auto-fit after content + i18n, unless a saved/manual size exists.
        installAutoFitObserver(el, appId);
        autoFitWindow(el, appId);
        el.style.visibility = 'visible';
        if(state.animations){
          el.addEventListener('animationend', ()=>{ el.classList.remove('anim-open'); }, { once:true });
        }
      }

      function makeDraggable(winEl, appId){
        const titlebar = winEl.querySelector('[data-drag="1"]');
        if(!titlebar) return;

        let dragging = false;
        let pointerId = null;
        let startX = 0, startY = 0, startL = 0, startT = 0;

        const onPointerDown = (e)=>{
          // Ignore non-primary mouse buttons
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Ignore clicks on window control buttons
          if(e.target && e.target.dataset && e.target.dataset.action) return;

          e.preventDefault();
          dragging = true;
          document.body.classList.add('dragging');
          pointerId = e.pointerId;

          // Focus window when starting drag
          try{ focusWindow(appId); } catch {}

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startL = rect.left;
          startT = rect.top;

          // Capture pointer so drag continues even if the finger leaves the titlebar
          try{ titlebar.setPointerCapture(pointerId); } catch {}

          titlebar.addEventListener('pointermove', onPointerMove);
          titlebar.addEventListener('pointerup', onPointerUp);
          titlebar.addEventListener('pointercancel', onPointerUp);
        };

        const onPointerMove = (e)=>{
          if(!dragging) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const newL = clamp(startL + dx - area.left, 0, area.width - 80);
          const newT = clamp(startT + dy - area.top, 0, area.height - 60);

          winEl.style.left = newL + 'px';
          winEl.style.top = newT + 'px';

          const w = state.windows.get(appId);
          if(w){ w.left = newL; w.top = newT; }
        };

        const onPointerUp = (e)=>{
          if(pointerId !== null && e.pointerId !== pointerId) return;

          dragging = false;
          pointerId = null;
          document.body.classList.remove('dragging');

          try{ titlebar.releasePointerCapture(e.pointerId); } catch {}

          titlebar.removeEventListener('pointermove', onPointerMove);
          titlebar.removeEventListener('pointerup', onPointerUp);
          titlebar.removeEventListener('pointercancel', onPointerUp);
        };

        // Pointer events handle mouse + touch + pen
        titlebar.addEventListener('pointerdown', onPointerDown);
      }

      function makeResizable(winEl, appId){
        const handle = winEl.querySelector('.resize');
        const EDGE = 6; // px

        let resizing = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let startW = 0, startH = 0;
        let startL = 0, startT = 0;
        let dir = '';

        function getDir(clientX, clientY){
          const r = winEl.getBoundingClientRect();
          const left = (clientX - r.left) <= EDGE;
          const right = (r.right - clientX) <= EDGE;
          const top = (clientY - r.top) <= EDGE;
          const bottom = (r.bottom - clientY) <= EDGE;

          let d = '';
          if(top) d += 'n';
          else if(bottom) d += 's';
          if(left) d += 'w';
          else if(right) d += 'e';
          return d;
        }

        function cursorFor(d){
          if(d === 'n' || d === 's') return 'ns-resize';
          if(d === 'e' || d === 'w') return 'ew-resize';
          if(d === 'ne' || d === 'sw') return 'nesw-resize';
          if(d === 'nw' || d === 'se') return 'nwse-resize';
          return '';
        }

        function beginResize(e, resizeDir){
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          e.preventDefault();

          resizing = true;
          pointerId = e.pointerId;
          dir = resizeDir;
          document.body.classList.add('dragging');
          const w = state.windows.get(appId);
          if(w){
            w.fit = false;
            w.prevRect = null;
          }

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startW = rect.width;
          startH = rect.height;
          startL = rect.left;
          startT = rect.top;

          try{ winEl.setPointerCapture(pointerId); } catch {}

          winEl.addEventListener('pointermove', onPointerMove);
          winEl.addEventListener('pointerup', onPointerUp);
          winEl.addEventListener('pointercancel', onPointerUp);
        }

        function onPointerMove(e){
          if(!resizing) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;
          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const MIN_W = 280;
          const MIN_H = 200;

          let newW = startW;
          let newH = startH;
          let newL = startL;
          let newT = startT;

          if(dir.includes('e')) newW = clamp(startW + dx, MIN_W, 920);
          if(dir.includes('s')) newH = clamp(startH + dy, MIN_H, 780);

          if(dir.includes('w')){
            newW = clamp(startW - dx, MIN_W, 920);
            newL = startL + (startW - newW);
          }
          if(dir.includes('n')){
            newH = clamp(startH - dy, MIN_H, 780);
            newT = startT + (startH - newH);
          }

          // Clamp to desktop bounds
          newL = clamp(newL - area.left, 0, area.width - 60) + area.left;
          newT = clamp(newT - area.top, 0, area.height - 40) + area.top;

          winEl.style.width = newW + 'px';
          winEl.style.height = newH + 'px';
          winEl.style.left = (newL - area.left) + 'px';
          winEl.style.top = (newT - area.top) + 'px';

          const w = state.windows.get(appId);
          if(w){
            w.width = newW;
            w.height = newH;
            w.left = (newL - area.left);
            w.top = (newT - area.top);
          }
        }

        function onPointerUp(e){
          if(pointerId !== null && e.pointerId !== pointerId) return;
          resizing = false;
          pointerId = null;
          dir = '';
          document.body.classList.remove('dragging');

          try{ winEl.releasePointerCapture(e.pointerId); } catch {}

          winEl.removeEventListener('pointermove', onPointerMove);
          winEl.removeEventListener('pointerup', onPointerUp);
          winEl.removeEventListener('pointercancel', onPointerUp);
          const w = state.windows.get(appId);
          if(w) w.userSized = true;
        }

        // Mouse hover cursor change near edges
        winEl.addEventListener('mousemove', (e)=>{
          if(resizing) return;
          // don't override cursor on controls/titlebar
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          const c = cursorFor(d);
          winEl.style.cursor = c || '';
        });
        winEl.addEventListener('mouseleave', ()=>{
          if(!resizing) winEl.style.cursor = '';
        });

        // Edge/corner resize start
        winEl.addEventListener('pointerdown', (e)=>{
          if(resizing) return;
          // ignore titlebar drag and window control clicks
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          if(!d) return;
          beginResize(e, d);
        });

        // Keep the existing bottom-right handle resize too
        if(handle){
          handle.addEventListener('pointerdown', (e)=>{
            // If we already started edge resize, ignore
            if(resizing) return;
            beginResize(e, 'se');
          });
        }
      }

      function renderTaskButtons(){
        const host = $('#taskButtons');
        host.innerHTML = '';
        const wins = Array.from(state.windows.values()).sort((a,b)=>a.title.localeCompare(b.title));
        wins.forEach(w => {
          const b = document.createElement('div');
          b.className = 'btn bevel';
          const isActive = (state.activeWindowId === w.id && !w.minimized);
          if(isActive) b.classList.add('pressed');
          b.style.maxWidth = '240px';
          b.style.overflow = 'hidden';
          b.style.whiteSpace = 'nowrap';
          b.style.textOverflow = 'ellipsis';
          b.innerHTML = `
            <span style="width:16px;height:16px;display:inline-flex;">${w.iconFile ? `<img class="pixel" src="${w.iconFile}" width="16" height="16" alt="" style="display:block;" data-app-id="${w.id}" />` : iconSVG(w.icon)}</span>
            <span>${w.title}</span>
          `;
          b.addEventListener('click', (e)=>{
            e.stopPropagation();
            closeStartMenu();
            if(w.minimized){
              w.minimized = false;
              const el = document.getElementById(`win_${w.id}`);
              if(el){
                el.classList.remove('hidden');
                if(state.animations){
                  const winRect = el.getBoundingClientRect();
                  const taskbar = document.getElementById('taskbar');
                  const targetRect = taskbar ? taskbar.getBoundingClientRect() : null;
                  const targetX = targetRect ? (targetRect.left + 20) : winRect.left;
                  const targetY = targetRect ? (targetRect.top + 8) : (winRect.top + winRect.height);
                  const dx = targetX - winRect.left;
                  const dy = targetY - winRect.top;
                  el.style.setProperty('--min-x', `${dx}px`);
                  el.style.setProperty('--min-y', `${dy}px`);
                  el.classList.add('anim-restore');
                  el.addEventListener('animationend', ()=>{
                    el.classList.remove('anim-restore');
                    el.style.removeProperty('--min-x');
                    el.style.removeProperty('--min-y');
                  }, { once:true });
                }
              }
              focusWindow(w.id);
            } else if(state.activeWindowId === w.id){
              minimizeApp(w.id);
            } else {
              focusWindow(w.id);
            }
          });
          host.appendChild(b);
        });
      }

      function tickClock(){
        $('#clock').textContent = getDisplayTime();
        setTimeout(tickClock, 1000);
      }

      function enter(){
        const name = $('#username').value.trim();
        if(!name){
          showMessage('dialog.loginEmpty.title', 'dialog.loginEmpty.body');
          $('#username').focus();
          return;
        }
        state.didAutoPlayThisSession = false;
        setUser(name);
        showDesktop();
        if(!state.windows.has('mediaplayer')) openApp('mediaplayer');
        if(!state.windows.has('music')) openApp('music');
        setTimeout(()=>{ mpInitInWindow(); }, 0);
        schedulePlayerAutoplay();
      }

      $('#enter').addEventListener('click', enter);
      $('#username').addEventListener('keydown', (e)=>{ if(e.key==='Enter') enter(); });
      $('#langBtn').addEventListener('click', (e)=>{ e.preventDefault(); toggleLang(); });

      $('#clearProfile').addEventListener('click', ()=>{
        localStorage.removeItem('bliss98_user');
        $('#username').value = '';
        $('#username').focus();
      });

      document.addEventListener('keydown', (e)=>{
        if(e.key==='Escape'){
          closeStartMenu();
          closeCtxMenu();
          closeWindowMenu();
          closeModal();
        }
        if(snakeHandleKey(e)) return;
        if(dopeSkateHandleKey(e)) return;
        if(e.key === 'Enter' && state.activeWindowId === 'poetry' && state.poetry.view === 'list' && state.poetry.selectedId){
          state.poetry.view = 'read';
          state.poetry.currentId = state.poetry.selectedId;
          state.poetry.readLang = state.lang;
          renderPoetryWindow();
        }
        if(e.key === 'Enter' && state.activeWindowId === 'games' && state.games.view === 'list' && state.games.selectedId){
          openGameFromHub(state.games.selectedId);
        }

        // Keyboard context menu (Shift+F10)
        if(e.shiftKey && e.key === 'F10'){
          if($('#desktop').classList.contains('hidden')) return;
          e.preventDefault();
          const area = $('#desktopArea').getBoundingClientRect();
          openCtxMenu(area.left + area.width/2, area.top + area.height/2, 'desktop', null);
        }

        // Basic keyboard navigation inside context menu
        const menu = $('#ctxMenu');
        if(menu && !menu.classList.contains('hidden')){
          const items = Array.from(menu.querySelectorAll('.ctx-item'));
          const idx = items.indexOf(document.activeElement);
          if(e.key === 'ArrowDown'){
            e.preventDefault();
            const next = items[Math.min(items.length-1, Math.max(0, idx+1))] || items[0];
            if(next) next.focus();
          }
          if(e.key === 'ArrowUp'){
            e.preventDefault();
            const prev = items[Math.max(0, idx-1)] || items[items.length-1];
            if(prev) prev.focus();
          }
        }
      });
      document.addEventListener('keyup', (e)=>{
        if(dopeSkateHandleKeyUp(e)) return;
      });
      document.addEventListener('click', (e)=>{
        const poemItem = e.target.closest && e.target.closest('[data-poem-id]');
        if(poemItem){
          const id = poemItem.dataset.poemId;
          if(e.detail > 1) return;
          selectPoetryItem(id);
          return;
        }
        const poemAction = e.target.closest && e.target.closest('[data-poetry-action]');
        if(poemAction && poemAction.dataset && poemAction.dataset.poetryAction){
          if(poemAction.dataset.poetryAction === 'back'){
            state.poetry.view = 'list';
            state.poetry.currentId = null;
            renderPoetryWindow();
          }
          if(poemAction.dataset.poetryAction === 'toggleLang'){
            state.poetry.readLang = (state.poetry.readLang === 'en') ? 'pt' : 'en';
            renderPoetryWindow();
          }
          return;
        }

        const trashItem = e.target.closest && e.target.closest('[data-trash-id]');
        if(trashItem){
          const id = trashItem.dataset.trashId;
          if(e.ctrlKey || e.metaKey){
            if(state.trashSelection.has(id)) state.trashSelection.delete(id);
            else state.trashSelection.add(id);
          } else {
            state.trashSelection = new Set([id]);
          }
          renderTrashWindow();
          return;
        }

        const trashBtn = e.target.closest && e.target.closest('[data-trash-action]');
        if(trashBtn && trashBtn.dataset){
          const action = trashBtn.dataset.trashAction;
          if(action === 'help'){
            showMessage('dialog.controls.title', 'dialog.controls.body');
            return;
          }
          if(action === 'restore'){
            const ids = state.trashSelection.size ? Array.from(state.trashSelection) : [];
            if(ids.length){
              restoreFromTrash(ids);
              state.trashSelection = new Set();
            }
          }
          if(action === 'restoreAll'){
            restoreFromTrash(Array.from(state.trash));
            state.trashSelection = new Set();
          }
          if(action === 'empty'){
            emptyTrash();
            state.trashSelection = new Set();
          }
          return;
        }

        const modalAction = e.target.closest && e.target.closest('[data-modal-action]');
        if(modalAction && modalAction.dataset && modalAction.dataset.modalAction){
          const act = modalAction.dataset.modalAction;
          if(act === 'confirm' && typeof modalState.onConfirm === 'function'){
            const select = $('#modalSelect');
            const input = $('#modalInput');
            const value = input ? input.value : (select ? select.value : null);
            modalState.onConfirm(value);
          }
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modal'){
          closeModal();
          return;
        }
        if(e.target && e.target.id === 'modalClose'){
          closeModal();
          return;
        }

        const menuItem = e.target.closest && e.target.closest('[data-menu-action]');
        if(menuItem && menuItem.dataset && menuItem.dataset.menuAction){
          e.preventDefault();
          e.stopPropagation();
          handleMenuAction(menuItem.dataset.menuAction);
          closeWindowMenu();
          return;
        }
        const menuToggle = e.target.closest && e.target.closest('.menubar span[data-menu]');
        if(menuToggle){
          e.preventDefault();
          e.stopPropagation();
          const winEl = menuToggle.closest('.window');
          const menuKey = menuToggle.dataset.menu;
          if(state.menuOpen && state.menuOpen.winId === getWindowId(winEl) && state.menuOpen.menuKey === menuKey){
            closeWindowMenu();
          } else {
            openWindowMenu(winEl, menuKey, menuToggle);
          }
          return;
        }

        const btn = e.target.closest && e.target.closest('[data-set-lang]');
        if(btn && btn.dataset && btn.dataset.setLang){
          setLang(btn.dataset.setLang);
        }
        const wpBtn = e.target.closest && e.target.closest('[data-set-wallpaper]');
        if(wpBtn && wpBtn.dataset && wpBtn.dataset.setWallpaper){
          applyWallpaper(wpBtn.dataset.setWallpaper);
        }
        const animBtn = e.target.closest && e.target.closest('[data-set-animations]');
        if(animBtn && animBtn.dataset && animBtn.dataset.setAnimations){
          setAnimations(animBtn.dataset.setAnimations === 'on');
        }
        const scanBtn = e.target.closest && e.target.closest('[data-set-scanlines]');
        if(scanBtn && scanBtn.dataset && scanBtn.dataset.setScanlines){
          setScanlines(scanBtn.dataset.setScanlines === 'on');
        }
        const darkBtn = e.target.closest && e.target.closest('[data-set-darkmode]');
        if(darkBtn && darkBtn.dataset && darkBtn.dataset.setDarkmode){
          setDarkMode(darkBtn.dataset.setDarkmode === 'on');
        }
        const retroBtn = e.target.closest && e.target.closest('[data-set-retro]');
        if(retroBtn && retroBtn.dataset && retroBtn.dataset.setRetro){
          setRetroGlow(retroBtn.dataset.setRetro === 'on');
        }
        const titleBtn = e.target.closest && e.target.closest('[data-set-titlebar]');
        if(titleBtn && titleBtn.dataset && titleBtn.dataset.setTitlebar){
          setTitlebarTheme(titleBtn.dataset.setTitlebar);
        }
        const themeBtn = e.target.closest && e.target.closest('[data-set-theme]');
        if(themeBtn && themeBtn.dataset && themeBtn.dataset.setTheme){
          setThemePreset(themeBtn.dataset.setTheme);
        }
        const themeCustomBtn = e.target.closest && e.target.closest('[data-theme-custom]');
        if(themeCustomBtn && themeCustomBtn.dataset && themeCustomBtn.dataset.themeCustom){
          const act = themeCustomBtn.dataset.themeCustom;
          if(act === 'save'){
            saveCustomThemeFromState();
          }
          if(act === 'load'){
            if(!themeCustomBtn.classList.contains('disabled')) applyCustomTheme();
          }
        }
        const gamesTabBtn = e.target.closest && e.target.closest('[data-games-tab]');
        if(gamesTabBtn && gamesTabBtn.dataset && gamesTabBtn.dataset.gamesTab){
          const tab = gamesTabBtn.dataset.gamesTab;
          state.games.view = (tab === 'leaderboard') ? 'leaderboard' : 'list';
          renderGamesWindow();
        }
        const videosAction = e.target.closest && e.target.closest('[data-videos-action]');
        if(videosAction && videosAction.dataset && videosAction.dataset.videosAction){
          const act = videosAction.dataset.videosAction;
          if(act === 'openChannel'){
            renderVideoPlayer(null, null, { force:true });
          }
          if(act === 'addKey'){
            showInputDialog({
              titleKey: 'videos.keyTitle',
              descKey: 'videos.keyDesc',
              value: loadYouTubeApiKey(),
              confirmKey: 'common.save',
              onConfirm: (val)=>{
                const next = (val || '').trim();
                saveYouTubeApiKey(next);
                initVideosWindow();
              }
            });
          }
        }
        const videoItem = e.target.closest && e.target.closest('[data-video-id]');
        if(videoItem && videoItem.dataset && videoItem.dataset.videoId){
          state.videos.selectedId = videoItem.dataset.videoId;
          renderVideoPlayer(null, state.videos.selectedId, { force:true });
          renderVideosList(null, state.videos.items);
          return;
        }
        const musicCard = e.target.closest && e.target.closest('[data-music-id]');
        if(musicCard){
          if(musicCard.dataset && musicCard.dataset.touchOpened === '1'){
            delete musicCard.dataset.touchOpened;
            return;
          }
          const id = musicCard.dataset.musicId;
          if(e.ctrlKey || e.metaKey){
            if(state.music.selected.has(id)) state.music.selected.delete(id);
            else state.music.selected.add(id);
          } else {
            state.music.selected = new Set([id]);
          }
          applyMusicState();
          return;
        }

        const ctxBtn = e.target.closest && e.target.closest('[data-ctx-action]');
        if(ctxBtn && ctxBtn.dataset && ctxBtn.dataset.ctxAction){
          e.preventDefault();
          e.stopPropagation();
          handleCtxAction(ctxBtn.dataset.ctxAction);
          closeCtxMenu();
        }
        if(!e.target.closest || (!e.target.closest('.menu-drop') && !e.target.closest('.menubar'))){
          closeWindowMenu();
        }
      });

      (function init(){
        const savedLang = localStorage.getItem('bliss98_lang') || 'en';
        state.lang = (savedLang === 'pt') ? 'pt' : 'en';

        const saved = localStorage.getItem('bliss98_user');
        if(saved){ setUser(saved); $('#username').value = saved; }

        state.gridSnap = loadGridSnap();
        state.wallpaper = loadWallpaper();
        state.animations = loadAnimations();
        state.settings.scanlines = loadScanlines();
        state.settings.darkMode = loadDarkMode();
        state.settings.retroGlow = loadRetroGlow();
        state.theme.preset = loadThemePreset();
        state.theme.titlebar = loadTitlebarTheme();
        if(state.theme.titlebar === 'transparent') state.theme.titlebar = 'blank';
        const customTheme = loadCustomTheme();
        state.theme.palette = (state.theme.preset === 'xp98') ? 'xp98' : 'default';
        if(state.theme.preset === 'custom' && customTheme && customTheme.palette){
          state.theme.palette = customTheme.palette;
        }
        state.games.layout = loadGamesLayout();
        state.games.bigIcons = loadGamesBigIcons();
        state.folders = loadFolders();
        if(!Array.isArray(state.folders.games)) state.folders.games = [];
        if(!state.folders.games.includes('snake')) state.folders.games.unshift('snake');
        if(!state.folders.games.includes('dope-skate')) state.folders.games.push('dope-skate');
        state.snake.highScore = loadSnakeHighScore();
        state.dopeSkate.highScore = loadDopeSkateHighScore();
        recordGameScore('snake', state.snake.highScore || 0);
        recordGameScore('dopeSkate', state.dopeSkate.highScore || 0);
        state.trash = new Set(loadTrash());
        state.iconLabels = loadIconLabels();
        state.trashSelection = new Set();

        if(state.theme.preset && state.theme.preset !== 'custom'){
          setThemePreset(state.theme.preset, { init:true });
        } else {
          applyThemePalette();
          applyTitlebarTheme();
        }

        // Apply translations immediately (default is English)
        applyI18n();
        applyDarkMode();
        applyScanlines();
        applyRetroGlow();
        updateTrashIconUI();

        initSfx();
        showLogin(true);
        document.addEventListener('click', ()=>{ closeStartMenu(); closeCtxMenu(); });
        const cm = $('#ctxMenu');
        if(cm){
          cm.addEventListener('click', (ev)=>{
            const btn = ev.target.closest && ev.target.closest('[data-ctx-action]');
            if(btn && btn.dataset && btn.dataset.ctxAction){
              ev.preventDefault();
              ev.stopPropagation();
              handleCtxAction(btn.dataset.ctxAction);
              closeCtxMenu();
              return;
            }
            // Prevent clicks inside the menu from bubbling to the document closer
            ev.stopPropagation();
          });
        }
      })();
    </script>
  </body>
</html>
