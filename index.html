<!doctype html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BLISS 98</title>
    <style>
      :root{
        --bg:#008080;
        --shadow-dark:#0a0a0a;
        --shadow-mid:#808080;
        --shadow-light:#dfdfdf;
        --shadow-white:#ffffff;
        --title:#000080;
        --title2:#1084d0;
        --task:#c0c0c0;
        --text:#000;
        --menu:#c0c0c0;
        --select:#000080;
      }

      html,body{height:100%;margin:0;}
      body{
        background:var(--bg);
        color:var(--text);
        font-family:"MS Sans Serif", Tahoma, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        font-size:13px;
        overflow:hidden;
        user-select:none;
        -webkit-user-select:none;
        -webkit-touch-callout:none;
        -webkit-tap-highlight-color: transparent;
      }
      .hidden{display:none !important;}
      .pixel{image-rendering:pixelated; image-rendering:crisp-edges;}

      .bevel{
        background:var(--task);
        border-top:2px solid var(--shadow-white);
        border-left:2px solid var(--shadow-white);
        border-right:2px solid var(--shadow-dark);
        border-bottom:2px solid var(--shadow-dark);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .bevel-in{
        background:#fff;
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }
      .btn{
        height:24px;
        padding:0 10px;
        display:inline-flex;
        align-items:center;
        gap:6px;
        cursor:pointer;
      }
      .btn:active{ filter:brightness(0.97); }
      .btn.pressed{
        border-top:2px solid var(--shadow-dark);
        border-left:2px solid var(--shadow-dark);
        border-right:2px solid var(--shadow-white);
        border-bottom:2px solid var(--shadow-white);
        box-shadow: 1px 1px 0 0 var(--shadow-mid) inset, -1px -1px 0 0 var(--shadow-light) inset;
      }

      #app{height:100%;}

      #login{
        position:absolute; inset:0;
        display:flex;
        align-items:center;
        justify-content:center;
        background:radial-gradient(circle at 40% 35%, rgba(255,255,255,.15), rgba(255,255,255,0) 45%), var(--bg);
      }
      .login-panel{
        width:min(520px, calc(100% - 32px));
        padding:14px;
      }
      .login-title{
        display:flex;
        align-items:center;
        justify-content:space-between;
        gap:10px;
        margin-bottom:10px;
      }
      .login-left{
        display:flex;
        align-items:center;
        gap:10px;
        min-width:0;
      }
      .lang-btn{
        min-width:70px;
        justify-content:center;
        font-weight:700;
      }
      .logo{ width:34px; height:34px; }
      .login-title h1{
        font-size:18px;
        margin:0;
        letter-spacing:0.2px;
      }
      .login-sub{opacity:.9;margin:2px 0 0 0;}
      .field-row{display:flex; gap:8px; align-items:center; margin-top:12px;}
      label{white-space:nowrap;}
      input[type="text"]{
        flex:1;
        height:26px;
        padding:0 8px;
        outline:none;
      }
      .login-footer{display:flex; justify-content:space-between; align-items:center; margin-top:12px; gap:10px;}
      .tiny{font-size:12px; opacity:.85; user-select:text;}
      .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; background:#fff; padding:1px 5px; border:1px solid #999;}

      #desktop{ position:absolute; inset:0; }
      .desktop-area{
        position:absolute; inset:0 0 30px 0;
        padding:10px;
      }

      .icons{
        position:relative;
        width:100%;
        height:100%;
      }
      .icon{
        position:absolute;
        width:92px;
        height:88px;
        display:flex;
        flex-direction:column;
        align-items:center;
        justify-content:flex-start;
        gap:6px;
        padding:6px 4px;
        border:1px solid transparent;
        cursor:default;
      }
      .icon.selected{
        border:1px dotted rgba(255,255,255,0.9);
        background:rgba(0,0,0,0.12);
      }
      .icon span{
        color:#fff;
        text-align:center;
        line-height:1.1;
        text-shadow: 1px 1px 0 rgba(0,0,0,0.65);
        padding:1px 2px;
        max-width:86px;
        word-break:break-word;
      }
      .icon.selected span{
        background:rgba(0,0,128,0.9);
        outline:1px dotted #fff;
      }

      .taskbar{
        position:absolute;
        left:0; right:0; bottom:0;
        height:30px;
        display:flex;
        align-items:center;
        gap:6px;
        padding:2px 6px;
      }
      .task-left{display:flex; align-items:center; gap:6px;}
      .task-buttons{
        display:flex;
        align-items:center;
        gap:4px;
        flex:1;
        overflow:auto hidden;
        padding:0 6px;
      }
      .task-buttons::-webkit-scrollbar{height:8px;}
      .task-buttons::-webkit-scrollbar-thumb{background:#9a9a9a;}
      .task-right{ display:flex; align-items:center; gap:8px; }
      .tray{
        height:24px;
        display:flex;
        align-items:center;
        padding:0 8px;
      }
      .clock{min-width:72px; text-align:right; font-variant-numeric:tabular-nums;}

      .start-menu{
        position:absolute;
        left:6px;
        bottom:32px;
        width:260px;
        display:flex;
        padding:0;
      }
      .start-side{
        width:30px;
        background:linear-gradient(#000080, #000);
        color:#fff;
        display:flex;
        align-items:flex-end;
        justify-content:center;
        padding:8px 0;
      }
      .start-side span{
        writing-mode:vertical-rl;
        transform:rotate(180deg);
        letter-spacing:1px;
        font-weight:700;
      }
      .start-list{ flex:1; padding:2px; }
      .menu-item{
        display:flex;
        align-items:center;
        gap:10px;
        padding:6px 8px;
        cursor:pointer;
      }
      .menu-item:hover{
        background:var(--select);
        color:#fff;
      }
      .menu-sep{height:1px; background:#9a9a9a; margin:2px 0;}
      /* Desktop context menu (Win98 style) */
.ctx-menu{
  position:absolute;
  min-width:220px;
  padding:2px;
  z-index:9999;
}
.ctx-item{
  width:100%;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:6px 8px;
  background:transparent;
  border:0;
  font:inherit;
  color:inherit;
  cursor:pointer;
  text-align:left;
}
.ctx-item:hover,
.ctx-item:focus{
  background:var(--select);
  color:#fff;
  outline:none;
}
.ctx-left{display:flex; align-items:center; gap:10px;}
.ctx-sep{height:1px; background:#9a9a9a; margin:2px 0;}
.ctx-check{
  width:16px;
  height:16px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:700;
  opacity:.95;
}
.ctx-shortcut{opacity:.85; font-size:12px;}
.ctx-item:hover .ctx-shortcut,
.ctx-item:focus .ctx-shortcut{opacity:1;}

@media (max-width: 720px){
  .ctx-menu{min-width:200px;}
  .ctx-item{padding:10px 10px;}
}

      .window{ position:absolute; min-width:320px; min-height:220px; }
      .window .frame{height:100%; display:flex; flex-direction:column;}
      .titlebar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:2px 3px;
        background:linear-gradient(90deg, var(--title), var(--title2));
        color:#fff;
        cursor:move;
        touch-action:none;
      }
      .title-left{display:flex; align-items:center; gap:6px;}
      .title-left strong{font-weight:700; font-size:12px;}
      .title-controls{display:flex; gap:4px;}
      .wctl{
        width:18px; height:18px;
        display:flex; align-items:center; justify-content:center;
        cursor:pointer;
        font-size:12px;
        line-height:1;
      }
      .menubar{
        height:22px;
        display:flex;
        align-items:center;
        gap:14px;
        padding:0 8px;
        background:var(--task);
        border-bottom:1px solid #9a9a9a;
        user-select:none;
      }
      .menubar span{cursor:default;}
      .content{
        flex:1;
        padding:10px;
        overflow:auto;
        background:#fff;
        color:#000;
        user-select:text;
        -webkit-user-select:text;
      }
      .content h2{margin:0 0 8px 0; font-size:16px;}
      .content p{margin:0 0 10px 0; line-height:1.35;}
      .content .card{ padding:10px; margin:10px 0; }
      .content a{color:#0000ee;}
      .statusbar{
        height:22px;
        display:flex;
        align-items:center;
        justify-content:space-between;
        padding:0 8px;
        background:var(--task);
        border-top:1px solid #9a9a9a;
        font-size:12px;
      }

      .resize{
        position:absolute;
        width:14px; height:14px;
        right:2px; bottom:2px;
        cursor:nwse-resize;
        background:conic-gradient(from 225deg, #0000 0 25%, #666 0 35%, #0000 0 50%, #666 0 60%, #0000 0 75%, #666 0 85%, #0000 0 100%);
        opacity:.55;
        touch-action:none;
      }

      /* Desktop selection box (Win98-like) */
      .rubberband{
        position:absolute;
        pointer-events:none;
        border:1px dotted #ffffff;
        background:rgba(0,0,128,0.18);
        box-shadow: 0 0 0 1px rgba(0,0,0,0.15) inset;
      }

      /* While dragging/resizing/selecting, hard-disable selection everywhere */
      body.dragging, body.dragging *{
        user-select:none !important;
        -webkit-user-select:none !important;
      }

      /* Keep normal selection inside content and inputs */
      .content, .content *{
        user-select:text;
        -webkit-user-select:text;
      }
      input, textarea{
        user-select:text;
        -webkit-user-select:text;
      }

      .hr98{height:1px; background:#b0b0b0; border-bottom:1px solid #fff; margin:10px 0;}
      .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
      .list98{padding-left:18px; margin:0;}
      .tag{
        display:inline-block;
        padding:1px 6px;
        border:1px solid #999;
        background:#f2f2f2;
        margin-right:6px;
        font-size:12px;
      }

      @media (max-width: 720px){
        .icons{grid-template-rows: repeat(5, 88px);}
        .window{min-width:280px;}
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="login">
        <div class="login-panel bevel">
          <div class="login-title">
            <div class="login-left">
              <svg class="logo pixel" viewBox="0 0 16 16" aria-hidden="true">
                <rect x="0" y="0" width="16" height="16" fill="#c0c0c0" />
                <rect x="1" y="1" width="14" height="14" fill="#ffffff" />
                <rect x="2" y="2" width="12" height="12" fill="#008080" />
                <rect x="4" y="4" width="8" height="8" fill="#000080" />
                <rect x="6" y="6" width="4" height="4" fill="#ffcc00" />
              </svg>
              <div>
                <h1>BLISS 98</h1>
                <p class="login-sub" data-i18n="login.sub">Enter your name to login</p>
              </div>
            </div>
            <button id="langBtn" class="btn bevel lang-btn" type="button" aria-label="Language" data-i18n-aria="aria.language">
              EN
            </button>
          </div>

          <div class="bevel-in" style="padding:12px;">
            <div class="field-row">
              <label for="username" data-i18n="login.labelName">Name:</label>
              <input id="username" class="bevel-in" type="text" autocomplete="name" placeholder="Enter your name" data-i18n-placeholder="login.placeholder" />
            </div>

            <div class="login-footer">
              <div class="tiny" data-i18n="login.hint">Hint: Ignorance is BLISS</div>
              <div style="display:flex; gap:6px;">
                <button id="clearProfile" class="btn bevel" type="button" data-i18n="login.clear">Clear</button>
                <button id="enter" class="btn bevel" type="button"><strong data-i18n="login.enter">Enter</strong></button>
              </div>
            </div>
          </div>

          <div class="tiny" style="margin-top:10px; opacity:.9;">
            <span data-i18n="login.copyright">© BLISS / DIEV — Bliss 98 OS</span>
          </div>
        </div>
      </div>

      <div id="desktop" class="hidden">
        <div class="desktop-area" id="desktopArea">
          <div class="icons" id="iconGrid"></div>
          <div id="windows"></div>
          <div id="rubberband" class="rubberband hidden"></div>
        </div>

        <div class="taskbar bevel" id="taskbar">
          <div class="task-left">
            <div id="startBtn" class="btn bevel" title="Menu" data-i18n-title="start.menu">
              <svg class="pixel" width="16" height="16" viewBox="0 0 16 16" aria-hidden="true">
                <rect x="0" y="0" width="16" height="16" fill="#000080" />
                <rect x="2" y="2" width="5" height="5" fill="#ffcc00" />
                <rect x="9" y="2" width="5" height="5" fill="#00ff99" />
                <rect x="2" y="9" width="5" height="5" fill="#ff6699" />
                <rect x="9" y="9" width="5" height="5" fill="#66ccff" />
              </svg>
              <strong>Bliss</strong>
            </div>
          </div>

          <div class="task-buttons" id="taskButtons"></div>

          <div class="task-right">
            <div class="tray bevel">
              <span id="who" style="margin-right:10px;"></span>
              <span class="clock" id="clock"></span>
            </div>
          </div>
        </div>

        <div id="startMenu" class="start-menu bevel hidden" role="menu" aria-label="Menu Bliss" data-i18n-aria="aria.startMenu">
          <div class="start-side"><span>BLISS 98</span></div>
          <div class="start-list" id="startList"></div>
        </div>

        <!-- Desktop context menu -->
        <div id="ctxMenu" class="ctx-menu bevel hidden" role="menu" aria-label="Context menu" data-i18n-aria="aria.contextMenu">
          <!-- items injected by JS -->
        </div>
      </div>
    </div>

    <script>
      const $ = (sel, root=document) => root.querySelector(sel);
      const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

      const state = {
        user: null,
        windows: new Map(),
        zTop: 10,
        activeWindowId: null,
        selectedIconId: null,
        lang: 'en',
        gridSnap: true,
      };

      const ICON_POS_KEY = 'bliss98_icon_positions';
      const ICON_SIZE = { w: 92, h: 88 };
      const ICON_GAP = { x: 12, y: 8 };

      function loadIconPositions(){
        try{
          const raw = localStorage.getItem(ICON_POS_KEY);
          return raw ? JSON.parse(raw) : {};
        } catch {
          return {};
        }
      }

      function saveIconPositions(pos){
        try{
          localStorage.setItem(ICON_POS_KEY, JSON.stringify(pos));
        } catch {}
      }

      function defaultIconPos(index){
        // Layout similar to the old grid: 6 rows then new column
        const rows = 6;
        const col = Math.floor(index / rows);
        const row = index % rows;
        return {
          x: col * (ICON_SIZE.w + ICON_GAP.x),
          y: row * (ICON_SIZE.h + ICON_GAP.y)
        };
      }

      function clampIconPos(x, y){
        const area = $('#desktopArea').getBoundingClientRect();
        const maxX = Math.max(0, Math.floor(area.width - ICON_SIZE.w - 6));
        const maxY = Math.max(0, Math.floor(area.height - ICON_SIZE.h - 6));
        return {
          x: clamp(Math.floor(x), 0, maxX),
          y: clamp(Math.floor(y), 0, maxY)
        };
      }
      const GRID_SNAP_KEY = 'bliss98_grid_snap';

function loadGridSnap(){
  try{
    const raw = localStorage.getItem(GRID_SNAP_KEY);
    if(raw === null) return true;
    return raw === '1';
  } catch {
    return true;
  }
}

function saveGridSnap(){
  try{
    localStorage.setItem(GRID_SNAP_KEY, state.gridSnap ? '1' : '0');
  } catch {}
}

function snapToGrid(x, y){
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const sx = Math.round(x / stepX) * stepX;
  const sy = Math.round(y / stepY) * stepY;
  return clampIconPos(sx, sy);
}

function getGridMetrics(){
  const area = $('#desktopArea').getBoundingClientRect();
  const stepX = ICON_SIZE.w + ICON_GAP.x;
  const stepY = ICON_SIZE.h + ICON_GAP.y;
  const cols = Math.max(1, Math.floor((area.width - 6) / stepX));
  const rows = Math.max(1, Math.floor((area.height - 6) / stepY));
  return { stepX, stepY, cols, rows };
}

function snapToGridClamped(x, y, metrics){
  const snapped = snapToGrid(x, y);
  const maxX = (metrics.cols - 1) * metrics.stepX;
  const maxY = (metrics.rows - 1) * metrics.stepY;
  return {
    x: clamp(snapped.x, 0, maxX),
    y: clamp(snapped.y, 0, maxY)
  };
}

function gridCellFromPos(x, y, metrics){
  return {
    col: clamp(Math.round(x / metrics.stepX), 0, metrics.cols - 1),
    row: clamp(Math.round(y / metrics.stepY), 0, metrics.rows - 1)
  };
}

function gridPosFromCell(cell, metrics){
  return { x: cell.col * metrics.stepX, y: cell.row * metrics.stepY };
}

function findFreeCell(startCell, occupied, metrics){
  const total = metrics.cols * metrics.rows;
  const startIdx = startCell.row * metrics.cols + startCell.col;
  for(let i = 0; i < total; i++){
    const idx = (startIdx + i) % total;
    const col = idx % metrics.cols;
    const row = Math.floor(idx / metrics.cols);
    const key = `${col},${row}`;
    if(!occupied.has(key)){
      return { col, row };
    }
  }
  return startCell;
}

function placeOnFreeCell(x, y, occupied, metrics){
  const snapped = snapToGridClamped(x, y, metrics);
  const cell = gridCellFromPos(snapped.x, snapped.y, metrics);
  const key = `${cell.col},${cell.row}`;
  const targetCell = occupied.has(key) ? findFreeCell(cell, occupied, metrics) : cell;
  const pos = gridPosFromCell(targetCell, metrics);
  occupied.set(`${targetCell.col},${targetCell.row}`, true);
  return {
    x: pos.x,
    y: pos.y,
    changed: targetCell.col !== cell.col || targetCell.row !== cell.row || pos.x !== snapped.x || pos.y !== snapped.y
  };
}

function arrangeIcons(){
  const next = {};
  APPS.forEach((app, idx) => {
    next[app.id] = defaultIconPos(idx);
  });
  saveIconPositions(next);
  renderIcons();
}

function resetIconPositions(){
  try{ localStorage.removeItem(ICON_POS_KEY); } catch {}
  renderIcons();
}

// Context menu state
let ctxState = { open:false, target:'desktop', appId:null };

function renderCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;

  const isIcon = ctxState.target === 'icon' && !!ctxState.appId;
  const gridMark = state.gridSnap ? '✓' : '';

  const items = [];
  if(isIcon){
    items.push({ action:'open', label:t('ctx.open') });
    items.push({ sep:true });
  }

  items.push({ action:'arrange', label:t('ctx.arrange') });
  items.push({ action:'grid', label:t('ctx.grid'), check:gridMark });
  items.push({ sep:true });
  items.push({ action:'settings', label:t('ctx.settings') });
  items.push({ action:'language', label:t('ctx.language'), right: state.lang.toUpperCase() });
  items.push({ action:'about', label:t('ctx.about') });
  items.push({ sep:true });
  items.push({ action:'logoff', label:t('ctx.logoff') });

  menu.innerHTML = items.map(it => {
    if(it.sep) return `<div class="ctx-sep"></div>`;
    const check = it.check ? `<span class="ctx-check" aria-hidden="true">${it.check}</span>` : `<span class="ctx-check" aria-hidden="true"></span>`;
    const right = it.right ? `<span class="ctx-shortcut">${it.right}</span>` : `<span class="ctx-shortcut"></span>`;
    return `
      <button class="ctx-item" type="button" role="menuitem" data-ctx-action="${it.action}">
        <span class="ctx-left">${check}<span>${it.label}</span></span>
        ${right}
      </button>
    `;
  }).join('');
}

function positionCtxMenu(x, y){
  const menu = $('#ctxMenu');
  if(!menu) return;
  const area = $('#desktopArea').getBoundingClientRect();

  menu.classList.remove('hidden');
  menu.style.left = '0px';
  menu.style.top = '0px';
  const rect = menu.getBoundingClientRect();

  const maxX = area.left + area.width - rect.width - 6;
  const maxY = area.top + area.height - rect.height - 6;

  const px = clamp(x, area.left + 6, maxX);
  const py = clamp(y, area.top + 6, area.top + area.height - rect.height - 6);

  menu.style.left = (px - area.left) + 'px';
  menu.style.top = (py - area.top) + 'px';
}

function openCtxMenu(x, y, target='desktop', appId=null){
  if($('#desktop').classList.contains('hidden')) return;
  ctxState = { open:true, target, appId };
  closeStartMenu();
  renderCtxMenu();
  positionCtxMenu(x, y);
  const menu = $('#ctxMenu');
  if(menu){
    menu.classList.remove('hidden');
    const first = menu.querySelector('.ctx-item');
    if(first) first.focus();
  }
}

function closeCtxMenu(){
  const menu = $('#ctxMenu');
  if(!menu) return;
  menu.classList.add('hidden');
  ctxState = { open:false, target:'desktop', appId:null };
}

function handleCtxAction(action){
  if(action === 'open' && ctxState.target === 'icon' && ctxState.appId){
    openApp(ctxState.appId);
  }
  if(action === 'arrange') arrangeIcons();
  if(action === 'grid'){
    state.gridSnap = !state.gridSnap;
    saveGridSnap();
    renderCtxMenu();
  }
  if(action === 'settings') openApp('settings');
  if(action === 'language') toggleLang();
  if(action === 'about') openApp('about');
  if(action === 'logoff'){
    closeCtxMenu();
    closeStartMenu();
    showLogin();
  }
}

// Long-press support (mobile/touch)
function installLongPress(el, getTarget){
  let timer = null;
  let start = null;
  const threshold = 8;
  const delay = 520;

  const clear = ()=>{
    if(timer){ clearTimeout(timer); timer = null; }
    start = null;
  };

  el.addEventListener('pointerdown', (e)=>{
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    start = { x:e.clientX, y:e.clientY };
    timer = setTimeout(()=>{
      const tgt = getTarget ? getTarget() : { target:'desktop', appId:null };
      openCtxMenu(e.clientX, e.clientY, tgt.target, tgt.appId);
      clear();
    }, delay);
  });

  el.addEventListener('pointermove', (e)=>{
    if(!start || !timer) return;
    const dx = e.clientX - start.x;
    const dy = e.clientY - start.y;
    if(Math.hypot(dx,dy) > threshold){
      clear();
    }
  });

  el.addEventListener('pointerup', clear);
  el.addEventListener('pointercancel', clear);
}

      const I18N = {
        en: {
          'login.sub': 'Enter your name to login',
          'login.labelName': 'Name:',
          'login.placeholder': 'Enter your name',
          'login.hint': 'Hint: Ignorance is BLISS',
          'login.clear': 'Clear',
          'login.enter': 'Enter',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Soon.',

          'aria.language': 'Language',
          'aria.startMenu': 'BLISS Menu',
          'aria.contextMenu': 'Context menu',
          'start.menu': 'Menu',

          'menubar.file': 'File',
          'menubar.edit': 'Edit',
          'menubar.view': 'View',
          'menubar.help': 'Help',

          'status.ready': 'Ready',

          'win.minimize': 'Minimize',
          'win.close': 'Close',
          'win.resize': 'Resize',
          'win.maximize': 'Maximize',
          'win.restore': 'Restore',

          'app.clothes': 'Clothes',
          'app.music': 'Music',
          'app.art': 'Art',
          'app.games': 'Games',
          'app.videos': 'Videos',
          'app.about': 'About',
          'app.contact': 'Contact',
          'app.diev': 'DIEV',
          'app.settings': 'Settings',
          'app.mediaplayer': 'BLISS Media Player',

          'menu.logoff': 'Log off…',

          'ctx.open': 'Open',
          'ctx.arrange': 'Arrange icons',
          'ctx.grid': 'Grid (snap)',
          'ctx.settings': 'Settings',
          'ctx.language': 'Language',
          'ctx.about': 'About',
          'ctx.logoff': 'Log off…',

          'settings.title': 'Settings',
          'settings.languageTab': 'Language',
          'settings.languageDesc': 'Choose your language for BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',

          'music.title': 'BLISS — Music',
          'music.subtitle': 'Listen everywhere:',
          'music.tip': 'Music is a beautiful thing, innit?',

          'about.title': 'About — BLISS 98',
          'about.p1': 'BLISS 98 is a playful Windows 98–style desktop built for BLISS.',
          'about.p2': 'Explore the apps, open windows, and make yourself at home.',

          'contact.title': 'Contact',
          'diev.title': 'DIEV',
          'diev.p1': 'Official page for DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Now playing:',
          'player.play': 'Play',
          'player.pause': 'Pause',
          'player.prev': 'Prev',
          'player.next': 'Next',
          'player.vol': 'Vol',
          'player.loading': 'Loading tracks…',
          'player.notfound': 'No songs yet.',
          'player.autoplay': 'Autoplay may be blocked by your browser. If it does not start, press Play.'
        },
        pt: {
          'login.sub': 'Digite seu nome para entrar',
          'login.labelName': 'Nome:',
          'login.placeholder': 'Digite seu nome',
          'login.hint': 'Dica: Ignorância é BLISS',
          'login.clear': 'Limpar',
          'login.enter': 'Entrar',
          'login.copyright': '© BLISS / DIEV — Bliss 98 OS',

          'common.soon': 'Em breve.',

          'aria.language': 'Idioma',
          'aria.startMenu': 'Menu BLISS',
          'aria.contextMenu': 'Menu de contexto',
          'start.menu': 'Menu',

          'menubar.file': 'Arquivo',
          'menubar.edit': 'Editar',
          'menubar.view': 'Exibir',
          'menubar.help': 'Ajuda',

          'status.ready': 'Pronto',

          'win.minimize': 'Minimizar',
          'win.close': 'Fechar',
          'win.resize': 'Redimensionar',
          'win.maximize': 'Maximizar',
          'win.restore': 'Restaurar',

          'app.clothes': 'Roupas',
          'app.music': 'Música',
          'app.art': 'Arte',
          'app.games': 'Jogos',
          'app.videos': 'Vídeos',
          'app.about': 'Sobre',
          'app.contact': 'Contato',
          'app.diev': 'DIEV',
          'app.settings': 'Configurações',
          'app.mediaplayer': 'BLISS Media Player',

          'menu.logoff': 'Sair…',

          'ctx.open': 'Abrir',
          'ctx.arrange': 'Organizar ícones',
          'ctx.grid': 'Grade (snap)',
          'ctx.settings': 'Configurações',
          'ctx.language': 'Idioma',
          'ctx.about': 'Sobre',
          'ctx.logoff': 'Sair…',

          'settings.title': 'Configurações',
          'settings.languageTab': 'Idioma',
          'settings.languageDesc': 'Escolha o idioma do BLISS 98.',
          'settings.lang.en': 'English',
          'settings.lang.pt': 'Português (BR)',

          'music.title': 'BLISS — Música',
          'music.subtitle': 'Ouça em todas as plataformas:',
          'music.tip': 'Música é uma coisa linda, não é?',

          'about.title': 'Sobre — BLISS 98',
          'about.p1': 'BLISS 98 é um desktop estilo Windows 98 feito para a BLISS.',
          'about.p2': 'Explore os apps, abra janelas e fique à vontade.',

          'contact.title': 'Contato',
          'diev.title': 'DIEV',
          'diev.p1': 'Página oficial do DIEV.',

          'player.title': 'BLISS Media Player',
          'player.now': 'Tocando:',
          'player.play': 'Play',
          'player.pause': 'Pausar',
          'player.prev': 'Anterior',
          'player.next': 'Próxima',
          'player.vol': 'Vol',
          'player.loading': 'Carregando músicas…',
          'player.notfound': 'Sem músicas ainda.',
          'player.autoplay': 'O autoplay pode ser bloqueado. Se não tocar, aperte Play.'
        }
      };

      function t(key){
        return (I18N[state.lang] && I18N[state.lang][key]) || (I18N.en && I18N.en[key]) || key;
      }

      function applyI18nTo(root){
        // text nodes
        $$('[data-i18n]', root).forEach(el => {
          const key = el.getAttribute('data-i18n');
          if(key) el.textContent = t(key);
        });
        // titles
        $$('[data-i18n-title]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-title');
          if(key) el.setAttribute('title', t(key));
        });
        // aria labels
        $$('[data-i18n-aria]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-aria');
          if(key) el.setAttribute('aria-label', t(key));
        });
        // placeholders
        $$('[data-i18n-placeholder]', root).forEach(el => {
          const key = el.getAttribute('data-i18n-placeholder');
          if(key) el.setAttribute('placeholder', t(key));
        });
      }

      function applyI18n(){
        applyI18nTo(document);

        // Update language button label
        const lb = $('#langBtn');
        if(lb) lb.textContent = state.lang.toUpperCase();

        // Re-render desktop UI labels
        renderIcons();
        renderStartMenu();
        updateOpenWindowTitles();
        renderTaskButtons();
        renderCtxMenu();
      }

      function setLang(lang){
        state.lang = (lang === 'pt') ? 'pt' : 'en';
        localStorage.setItem('bliss98_lang', state.lang);
        applyI18n();
      }

      function toggleLang(){
        setLang(state.lang === 'en' ? 'pt' : 'en');
      }

      function updateOpenWindowTitles(){
        // Update stored titles and the DOM titlebars
        state.windows.forEach((w, id) => {
          const app = APPS.find(a => a.id === id);
          const title = app ? t(app.titleKey) : (w.titleKey ? t(w.titleKey) : id);
          w.title = title;
          const winEl = document.getElementById(`win_${id}`);
          if(winEl){
            const titleEl = winEl.querySelector('.title-left strong');
            if(titleEl) titleEl.textContent = title;

            const c = winEl.querySelector('.content');
            if(c && CONTENT[id]) {
              c.innerHTML = CONTENT[id]();
            }
            applyI18nTo(winEl);

            const minCtl = winEl.querySelector('[data-action="min"]');
            const closeCtl = winEl.querySelector('[data-action="close"]');
            const resizeCtl = winEl.querySelector('.resize');
            if(minCtl) minCtl.title = t('win.minimize');
            if(closeCtl) closeCtl.title = t('win.close');
            if(resizeCtl) resizeCtl.title = t('win.resize');

            if(id === 'mediaplayer') {
              setTimeout(mpInitInWindow, 0);
            }
          }
        });
      }

      function iconSVG(type){
        const common = `viewBox="0 0 16 16" class="pixel" aria-hidden="true"`;
        switch(type){
          case 'folder':
            return `<svg ${common}><rect width="16" height="16" fill="none"/><path d="M1 4h6l1 2h7v8H1z" fill="#ffcc66" stroke="#000" stroke-width="1"/><path d="M1 4h6l1 2H1z" fill="#ffd88a" stroke="#000" stroke-width="1"/></svg>`;
          case 'music':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><path d="M10 3v7.5a2 2 0 1 1-1-1.7V5h-3V3z" fill="#000080"/></svg>`;
          case 'art':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="3" y="3" width="10" height="10" fill="#c0c0c0" stroke="#000"/><path d="M4 11l2-2 2 2 2-3 3 3" stroke="#000080" stroke-width="1" fill="none"/></svg>`;
          case 'game':
            return `<svg ${common}><rect x="2" y="5" width="12" height="7" rx="2" fill="#c0c0c0" stroke="#000"/><rect x="5" y="7" width="1" height="3" fill="#000"/><rect x="4" y="8" width="3" height="1" fill="#000"/><circle cx="11" cy="8" r="1" fill="#ff3366"/><circle cx="12.8" cy="9.5" r="1" fill="#66ccff"/></svg>`;
          case 'video':
            return `<svg ${common}><rect x="1" y="3" width="12" height="10" fill="#fff" stroke="#000"/><path d="M13 6l2-1v6l-2-1z" fill="#000"/></svg>`;
          case 'info':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="5" r="1" fill="#000"/><rect x="7" y="7" width="2" height="6" fill="#000080"/></svg>`;
          case 'mail':
            return `<svg ${common}><rect x="1" y="3" width="14" height="10" fill="#fff" stroke="#000"/><path d="M1 4l7 5 7-5" fill="none" stroke="#000080" stroke-width="1"/></svg>`;
          case 'user':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="6" r="2" fill="#000080"/><path d="M4 13c1-2 7-2 8 0" stroke="#000080" fill="none"/></svg>`;
          case 'settings':
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><circle cx="8" cy="8" r="3" fill="#c0c0c0" stroke="#000"/><path d="M8 2v2M8 12v2M2 8h2M12 8h2M3.5 3.5l1.4 1.4M11.1 11.1l1.4 1.4M12.5 3.5l-1.4 1.4M4.9 11.1l-1.4 1.4" stroke="#000080"/></svg>`;
          default:
            return `<svg ${common}><rect x="1" y="1" width="14" height="14" fill="#fff" stroke="#000"/><rect x="4" y="4" width="8" height="8" fill="#000080"/></svg>`;
        }
      }

      const APPS = [
        { id:'clothes', titleKey:'app.clothes', icon:'folder', iconFile:'/assets/icons/Clothes.png' },
        { id:'music', titleKey:'app.music', icon:'music', iconFile:'/assets/icons/Music.png' },
        { id:'mediaplayer', titleKey:'app.mediaplayer', icon:'music', iconFile:'/assets/icons/BLISS%20mediaplayer.png' },
        { id:'art', titleKey:'app.art', icon:'art', iconFile:'/assets/icons/Art.png' },
        { id:'games', titleKey:'app.games', icon:'game', iconFile:'/assets/icons/Games.png' },
        { id:'videos', titleKey:'app.videos', icon:'video', iconFile:'/assets/icons/Videos.png' },
        { id:'about', titleKey:'app.about', icon:'info', iconFile:'/assets/icons/About.png' },
        { id:'contact', titleKey:'app.contact', icon:'mail', iconFile:'/assets/icons/Contact.png' },
        { id:'diev', titleKey:'app.diev', icon:'user', iconFile:'/assets/icons/DIEV.png' },
        { id:'settings', titleKey:'app.settings', icon:'settings', iconFile:'/assets/icons/Settings.png' },
      ];

      const CONTENT = {
        about: () => `
          <h2>${t('about.title')}</h2>
          <p>${t('about.p1')}</p>
          <p class="tiny">${t('about.p2')}</p>
        `,
        clothes: () => `<h2>BLISS — ${t('app.clothes')}</h2><p>${t('common.soon')}</p>`,
        music: () => `
  <h2>${t('music.title')}</h2>
  <p style="margin:0 0 10px 0;">${t('music.subtitle')}</p>

  <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap:12px;">
    <a href="https://open.spotify.com/artist/6bjnHKF2yjUlKyYD15cNGq" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/spotify.png" width="32" height="32" alt="Spotify" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">Spotify</div>
      </div>
    </a>

    <a href="https://music.youtube.com/channel/UCSjAU7hceaYUQPZml7HUFgA" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/youtubemusic.png" width="32" height="32" alt="YouTube Music" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">YouTube Music</div>
      </div>
    </a>

    <a href="https://music.apple.com/us/artist/diev/1586153318" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/applemusic.png" width="32" height="32" alt="Apple Music" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">Apple Music</div>
      </div>
    </a>

    <a href="https://music.amazon.com.br/artists/B00F5I7CC6/diev" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/amazonmusic.png" width="32" height="32" alt="Amazon Music" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">Amazon Music</div>
      </div>
    </a>

    <a href="https://soundcloud.com/die_v/tracks" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/soundcloud.png" width="32" height="32" alt="SoundCloud" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">SoundCloud</div>
      </div>
    </a>

    <a href="https://www.deezer.com/en/artist/5170963" target="_blank" rel="noreferrer" style="text-decoration:none; color:inherit;">
      <div class="bevel" style="padding:10px; display:flex; flex-direction:column; align-items:center; gap:8px;">
        <div class="bevel-in" style="width:44px; height:44px; display:flex; align-items:center; justify-content:center; padding:2px;">
          <img class="pixel" src="/assets/icons/deezer.png" width="32" height="32" alt="Deezer" style="display:block;" />
        </div>
        <div style="font-weight:700; text-align:center;">Deezer</div>
      </div>
    </a>
  </div>

  <div class="hr98"></div>
  <div class="tiny">${t('music.tip')}</div>
`,

        mediaplayer: () => `
          <h2>${t('player.title')}</h2>
          <div class="card bevel" style="display:flex; flex-direction:column; gap:10px;">
            <div>
              <strong>${t('player.now')}</strong>
              <span id="mpNow" style="margin-left:6px;">—</span>
            </div>

            <audio id="mpAudio" preload="metadata"></audio>

            <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
              <button class="btn bevel" type="button" data-mp-action="prev">⏮ ${t('player.prev')}</button>
              <button class="btn bevel" type="button" data-mp-action="toggle">▶ ${t('player.play')}</button>
              <button class="btn bevel" type="button" data-mp-action="next">⏭ ${t('player.next')}</button>

              <span style="margin-left:auto; display:flex; align-items:center; gap:6px;">
                <span class="kbd">${t('player.vol')}</span>
                <input id="mpVol" type="range" min="0" max="1" step="0.01" value="0.8" />
              </span>
            </div>

            <div class="bevel-in" style="padding:8px;">
              <div id="mpList" style="display:grid; gap:6px;"></div>
              <div id="mpMsg" class="tiny" style="margin-top:8px;"></div>
            </div>

            <div class="tiny">${t('player.autoplay')}</div>
          </div>
        `,

        art: () => `<h2>BLISS — ${t('app.art')}</h2><p>${t('common.soon')}</p>`,
        games: () => `<h2>BLISS — ${t('app.games')}</h2><p>${t('common.soon')}</p>`,
        videos: () => `<h2>BLISS — ${t('app.videos')}</h2><p>${t('common.soon')}</p>`,
        contact: () => `<h2>${t('contact.title')}</h2><p>${t('common.soon')}</p>`,
        diev: () => `<h2>${t('diev.title')}</h2><p>${t('diev.p1')}</p>`,
        settings: () => `
          <h2 data-i18n="settings.title">Settings</h2>
          <div class="card bevel">
            <strong data-i18n="settings.languageTab">Language</strong>
            <p style="margin:6px 0 10px 0;" data-i18n="settings.languageDesc">Choose your language for Bliss 98.</p>
            <div style="display:flex; gap:8px; flex-wrap:wrap;">
              <button class="btn bevel" type="button" data-set-lang="en"><span class="kbd" style="margin-right:6px;">EN</span><span data-i18n="settings.lang.en">English</span></button>
              <button class="btn bevel" type="button" data-set-lang="pt"><span class="kbd" style="margin-right:6px;">PT</span><span data-i18n="settings.lang.pt">Português (BR)</span></button>
            </div>
          </div>
        `,
      };

      function getDisplayTime(){
        const d = new Date();
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        return `${hh}:${mm}`;
      }
      function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }


      // --- BLISS Media Player ---
      // NOTE: Browsers cannot scan/list a folder on static hosting (GitHub Pages). We use a manifest file.
      // Create: /assets/audio/tracks.json  Example: ["WOW.mp3","People Change.mp3"]
      const MP_MANIFEST_URL = '/assets/audio/tracks.json';
      const MP_STATE_KEY = 'bliss98_mp_state';

      let mp = { tracks: [], idx: 0, playing: false, vol: 0.8, loaded: false };

      function mpSafeTitleFromFilename(name){
        try{
          const base = String(name).split('/').pop();
          const noExt = base.replace(/\.[^/.]+$/,'');
          return decodeURIComponent(noExt);
        } catch {
          return String(name).replace(/\.[^/.]+$/,'');
        }
      }

      function mpLoadState(){
        try{
          const raw = localStorage.getItem(MP_STATE_KEY);
          if(!raw) return;
          const s = JSON.parse(raw);
          if(typeof s.idx === 'number') mp.idx = s.idx;
          if(typeof s.vol === 'number') mp.vol = clamp(s.vol, 0, 1);
        } catch {}
      }

      function mpSaveState(){
        try{ localStorage.setItem(MP_STATE_KEY, JSON.stringify({ idx: mp.idx, vol: mp.vol })); } catch {}
      }

      function mpEls(){
        const win = document.getElementById('win_mediaplayer');
        if(!win) return null;
        return {
          win,
          audio: win.querySelector('#mpAudio'),
          now: win.querySelector('#mpNow'),
          list: win.querySelector('#mpList'),
          msg: win.querySelector('#mpMsg'),
          vol: win.querySelector('#mpVol'),
          toggleBtn: win.querySelector('[data-mp-action="toggle"]'),
        };
      }

      function mpRender(){
        const els = mpEls();
        if(!els) return;
        const { now, list, msg, vol, toggleBtn, audio } = els;

        vol.value = String(mp.vol);
        audio.volume = mp.vol;

        if(!mp.loaded){
          msg.textContent = t('player.loading');
        } else if(mp.tracks.length === 0){
          msg.textContent = t('player.notfound');
        } else {
          msg.textContent = '';
        }

        list.innerHTML = mp.tracks.map((tr, i)=>{
          const active = (i === mp.idx);
          return `
            <button class="btn bevel" type="button" data-mp-pick="${i}" style="justify-content:flex-start; width:100%; ${active ? 'font-weight:700;' : ''}">
              ${active ? '▶ ' : ''}${tr.title}
            </button>
          `;
        }).join('');

        const cur = mp.tracks[mp.idx];
        now.textContent = cur ? cur.title : '—';
        toggleBtn.innerHTML = mp.playing ? `⏸ ${t('player.pause')}` : `▶ ${t('player.play')}`;
      }

      function mpSetTrack(i){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        mp.idx = clamp(i, 0, mp.tracks.length - 1);
        const cur = mp.tracks[mp.idx];
        audio.src = cur.src;
        audio.volume = mp.vol;
        mpSaveState();
        mpRender();
      }

      async function mpPlay(){
        const els = mpEls();
        if(!els) return;
        const { audio } = els;
        if(mp.tracks.length === 0) return;
        try{
          await audio.play();
          mp.playing = true;
        } catch {
          mp.playing = false;
        }
        mpRender();
      }

      function mpPause(){
        const els = mpEls();
        if(!els) return;
        els.audio.pause();
        mp.playing = false;
        mpRender();
      }

      function mpNext(){
        if(mp.tracks.length === 0) return;
        mpSetTrack((mp.idx + 1) % mp.tracks.length);
        mpPlay();
      }

      function mpPrev(){
        if(mp.tracks.length === 0) return;
        mpSetTrack((mp.idx - 1 + mp.tracks.length) % mp.tracks.length);
        mpPlay();
      }

      async function mpLoadTracks(){
        mp.loaded = false;
        mp.tracks = [];
        mpRender();

        try{
          const res = await fetch(MP_MANIFEST_URL, { cache: 'no-store' });
          if(!res.ok) throw new Error('manifest not found');
          const data = await res.json();

          const files = Array.isArray(data) ? data : (Array.isArray(data.tracks) ? data.tracks : []);
          const normalized = files
            .map(x => (typeof x === 'string') ? x : (x && x.file) ? x.file : null)
            .filter(Boolean);

          mp.tracks = normalized
            .filter(f => String(f).toLowerCase().endsWith('.mp3'))
            .map(f => ({
              src: '/assets/audio/' + String(f).split('/').pop(),
              title: mpSafeTitleFromFilename(f)
            }));

        } catch {
          mp.tracks = [];
        }

        mp.loaded = true;
        mpLoadState();
        if(mp.tracks.length > 0){
          mp.idx = clamp(mp.idx, 0, mp.tracks.length - 1);
          mpSetTrack(mp.idx);
        }
        mpRender();
      }

      function mpInitInWindow(){
        const els = mpEls();
        if(!els) return;
        const { audio, vol } = els;

        // Volume
        vol.value = String(mp.vol);
        audio.volume = mp.vol;
        vol.addEventListener('input', ()=>{
          mp.vol = Number(vol.value);
          audio.volume = mp.vol;
          mpSaveState();
        });

        // Ended -> next
        audio.addEventListener('ended', ()=> mpNext());

        // Load tracks each time window is (re)rendered
        mpLoadTracks();
      }

      // Delegate Media Player button clicks
      document.addEventListener('click', (e)=>{
        const actBtn = e.target.closest && e.target.closest('[data-mp-action]');
        if(actBtn){
          const action = actBtn.dataset.mpAction;
          if(action === 'toggle'){
            if(mp.playing) mpPause(); else mpPlay();
          }
          if(action === 'next') mpNext();
          if(action === 'prev') mpPrev();
        }

        const pickBtn = e.target.closest && e.target.closest('[data-mp-pick]');
        if(pickBtn){
          const idx = Number(pickBtn.dataset.mpPick);
          mpSetTrack(idx);
          mpPlay();
        }
      });

      // Prevent browser text selection on desktop drags (keep selection inside .content and inputs)
      document.addEventListener('selectstart', (e)=>{
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if(tag === 'input' || tag === 'textarea') return;
        if(e.target && e.target.closest && e.target.closest('.content')) return;
        e.preventDefault();
      });

      function setUser(name){
        state.user = name;
        localStorage.setItem('bliss98_user', name);
        $('#who').textContent = name ? name : '';
      }

      function showDesktop(){
        $('#login').classList.add('hidden');
        $('#desktop').classList.remove('hidden');
        $('#username').blur();
        renderIcons();
        renderStartMenu();
        tickClock();
      }
      function showLogin(){
        $('#desktop').classList.add('hidden');
        $('#login').classList.remove('hidden');
        $('#username').focus();
      }

      function renderIcons(){
        const grid = $('#iconGrid');
        grid.innerHTML = '';

        const saved = loadIconPositions();
        const metrics = getGridMetrics();
        const occupied = new Map();
        let needsSave = false;

        APPS.forEach((app, idx) => {
          const el = document.createElement('div');
          el.className = 'icon';
          el.dataset.appId = app.id;

          const def = defaultIconPos(idx);
          const pos = (saved && saved[app.id]) ? saved[app.id] : def;
          const placed = placeOnFreeCell(pos.x, pos.y, occupied, metrics);
          el.style.left = placed.x + 'px';
          el.style.top = placed.y + 'px';
          if(placed.changed || !saved[app.id]){
            saved[app.id] = { x: placed.x, y: placed.y };
            needsSave = true;
          }

          const iconHtml = app.iconFile
            ? `<img class="pixel" src="${app.iconFile}" width="32" height="32" alt="${t(app.titleKey)}" style="display:block;" />`
            : iconSVG(app.icon);

          el.innerHTML = `
            <div class="pixel" style="width:34px;height:34px;display:flex;align-items:center;justify-content:center;">${iconHtml}</div>
            <span>${t(app.titleKey)}</span>
          `;

          // Click select
          el.addEventListener('click', (e)=>{
            e.stopPropagation();
            if(el.dataset.dragged === '1'){
              // prevent post-drag click from changing selection unexpectedly
              el.dataset.dragged = '0';
              return;
            }
            selectIcon(app.id);
          });

          // Double click open
          el.addEventListener('dblclick', (e)=>{
            e.stopPropagation();
            openApp(app.id);
          });

          makeIconDraggable(el);
          el.addEventListener('contextmenu', (ev)=>{
            ev.preventDefault();
            openCtxMenu(ev.clientX, ev.clientY, 'icon', app.id);
          });
          installLongPress(el, ()=>({ target:'icon', appId: app.id }));
          grid.appendChild(el);
        });
        if(needsSave) saveIconPositions(saved);
      }
      function selectIcon(id){
        state.selectedIconId = id;
        $$('.icon').forEach(i=>i.classList.toggle('selected', i.dataset.appId === id));
      }

      function makeIconDraggable(iconEl){
        let down = false;
        let dragging = false;
        let pointerId = null;

        let startX = 0, startY = 0;
        let group = [];
        let startPositions = []; // { el, id, x, y }

        // group bounds + allowed delta range
        let dxMin = 0, dxMax = 0, dyMin = 0, dyMax = 0;

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;

          e.stopPropagation();
          closeStartMenu();
          closeCtxMenu();

          // If multiple icons are selected and the one we grabbed is selected, drag the whole group.
          const selectedEls = $$('.icon.selected');
          const isSelected = iconEl.classList.contains('selected');
          if(selectedEls.length > 1 && isSelected){
            group = selectedEls;
          } else {
            // Otherwise, single-select the grabbed icon
            selectIcon(iconEl.dataset.appId);
            group = [iconEl];
          }

          down = true;
          dragging = false;
          pointerId = e.pointerId;
          startX = e.clientX;
          startY = e.clientY;

          // Snapshot starting positions
          startPositions = group.map(el => ({
            el,
            id: el.dataset.appId,
            x: parseInt(el.style.left || '0', 10),
            y: parseInt(el.style.top || '0', 10)
          }));

          // Compute bounds in desktop coordinates (relative to desktopArea)
          const area = $('#desktopArea').getBoundingClientRect();
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          startPositions.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x + ICON_SIZE.w);
            maxY = Math.max(maxY, p.y + ICON_SIZE.h);
          });

          // Right/bottom limits match `clampIconPos` behavior (icon right edge <= area.width - 6)
          dxMin = -minX;
          dxMax = (Math.floor(area.width - 6) - maxX);
          dyMin = -minY;
          dyMax = (Math.floor(area.height - 6) - maxY);

          // Prevent accidental post-drag clicks
          group.forEach(el => (el.dataset.dragged = '0'));

          document.body.classList.add('dragging');
          try{ iconEl.setPointerCapture(pointerId); } catch {}

          iconEl.addEventListener('pointermove', onPointerMove);
          iconEl.addEventListener('pointerup', onPointerUp);
          iconEl.addEventListener('pointercancel', onPointerUp);

          e.preventDefault();
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const dxRaw = e.clientX - startX;
          const dyRaw = e.clientY - startY;

          if(!dragging && (Math.abs(dxRaw) + Math.abs(dyRaw) > 4)){
            dragging = true;
          }
          if(!dragging) return;

          // Clamp movement so the whole group stays within the desktop
          const dx = clamp(dxRaw, dxMin, dxMax);
          const dy = clamp(dyRaw, dyMin, dyMax);

          // Move all icons in the group
          startPositions.forEach(p => {
            p.el.style.left = (p.x + dx) + 'px';
            p.el.style.top = (p.y + dy) + 'px';
          });

          e.preventDefault();
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ iconEl.releasePointerCapture(e.pointerId); } catch {}

          iconEl.removeEventListener('pointermove', onPointerMove);
          iconEl.removeEventListener('pointerup', onPointerUp);
          iconEl.removeEventListener('pointercancel', onPointerUp);

          document.body.classList.remove('dragging');

          if(dragging){
            // Save all moved positions in one write
            const saved = loadIconPositions();
            const metrics = getGridMetrics();
            const movedIds = new Set(startPositions.map(p => p.id));
            const occupied = new Map();

            APPS.forEach((app, idx) => {
              if(movedIds.has(app.id)) return;
              const base = saved[app.id] || defaultIconPos(idx);
              const placed = placeOnFreeCell(base.x, base.y, occupied, metrics);
              if(placed.changed || !saved[app.id]){
                saved[app.id] = { x: placed.x, y: placed.y };
              }
            });

            startPositions.forEach(p => {
              let x = parseInt(p.el.style.left || '0', 10);
              let y = parseInt(p.el.style.top || '0', 10);

              if(state.gridSnap){
                const snapped = snapToGrid(x, y);
                x = snapped.x;
                y = snapped.y;
              }

              const placed = placeOnFreeCell(x, y, occupied, metrics);
              p.el.style.left = placed.x + 'px';
              p.el.style.top = placed.y + 'px';
              saved[p.id] = { x: placed.x, y: placed.y };
              p.el.dataset.dragged = '1';
            });
            saveIconPositions(saved);
          }

          dragging = false;
          pointerId = null;
        };

        // Pointer events handle mouse + touch + pen
        iconEl.addEventListener('pointerdown', onPointerDown);
      }

      $('#desktopArea').addEventListener('click', ()=>{
        // If a selection drag just happened, do not treat it as a click
        if($('#desktopArea').dataset.selDragged === '1'){
          $('#desktopArea').dataset.selDragged = '0';
          return;
        }
        state.selectedIconId = null;
        $$('.icon').forEach(i=>i.classList.remove('selected'));
        closeStartMenu();
        closeCtxMenu();
      });

      // Right-click / two-finger click on desktop
      $('#desktopArea').addEventListener('contextmenu', (e)=>{
        if($('#desktop').classList.contains('hidden')) return;
        e.preventDefault();
        openCtxMenu(e.clientX, e.clientY, 'desktop', null);
      });

      // Long-press on desktop (mobile/touch)
      installLongPress($('#desktopArea'), ()=>({ target:'desktop', appId:null }));

      // Rubber-band selection (Windows 98 style)
      (function installRubberbandSelection(){
        const areaEl = $('#desktopArea');
        const rb = $('#rubberband');
        if(!areaEl || !rb) return;

        let down = false;
        let active = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let lastRect = null;

        function rectFrom(aX, aY, bX, bY){
          const x1 = Math.min(aX, bX);
          const y1 = Math.min(aY, bY);
          const x2 = Math.max(aX, bX);
          const y2 = Math.max(aY, bY);
          return { x:x1, y:y1, w:(x2-x1), h:(y2-y1) };
        }

        function intersects(r, elRect){
          return !(elRect.right < r.x || elRect.left > (r.x + r.w) || elRect.bottom < r.y || elRect.top > (r.y + r.h));
        }

        function updateRubberband(r){
          rb.style.left = r.x + 'px';
          rb.style.top = r.y + 'px';
          rb.style.width = r.w + 'px';
          rb.style.height = r.h + 'px';
        }

        function clearRubberband(){
          rb.classList.add('hidden');
          rb.style.width = '0px';
          rb.style.height = '0px';
          lastRect = null;
          document.body.classList.remove('dragging');
        }

        function selectByRect(r){
          // Select icons whose bounding boxes intersect with the rubberband rect
          const icons = $$('.icon');
          icons.forEach(icon => {
            const rect = icon.getBoundingClientRect();
            const area = areaEl.getBoundingClientRect();
            const rel = {
              left: rect.left - area.left,
              right: rect.right - area.left,
              top: rect.top - area.top,
              bottom: rect.bottom - area.top,
            };
            const hit = intersects(r, rel);
            icon.classList.toggle('selected', hit);
          });
        }

        const onPointerDown = (e)=>{
          if($('#desktop').classList.contains('hidden')) return;
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Don't start a box if user is interacting with icons/windows/menus
          if(e.target && e.target.closest && (e.target.closest('.icon') || e.target.closest('.window') || e.target.closest('#startMenu') || e.target.closest('#ctxMenu'))){
            return;
          }

          down = true;
          active = false;
          pointerId = e.pointerId;

          const area = areaEl.getBoundingClientRect();
          startX = e.clientX - area.left;
          startY = e.clientY - area.top;

          try{ areaEl.setPointerCapture(pointerId); } catch {}
        };

        const onPointerMove = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          const area = areaEl.getBoundingClientRect();
          const curX = e.clientX - area.left;
          const curY = e.clientY - area.top;

          const dx = curX - startX;
          const dy = curY - startY;

          // Activate after small movement threshold
          if(!active && (Math.abs(dx) + Math.abs(dy) > 6)){
            active = true;
            rb.classList.remove('hidden');
            document.body.classList.add('dragging');
            // Close menus
            closeStartMenu();
            closeCtxMenu();
            // Clear single selection
            state.selectedIconId = null;
          }
          if(!active) return;

          e.preventDefault();

          const r = rectFrom(startX, startY, curX, curY);
          lastRect = r;
          updateRubberband(r);
          selectByRect(r);
        };

        const onPointerUp = (e)=>{
          if(!down) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          down = false;
          try{ areaEl.releasePointerCapture(e.pointerId); } catch {}

          if(active){
            // Prevent click clear right after box select
            areaEl.dataset.selDragged = '1';
            active = false;
            clearRubberband();
          }
          pointerId = null;
        };

        areaEl.addEventListener('pointerdown', onPointerDown);
        areaEl.addEventListener('pointermove', onPointerMove);
        areaEl.addEventListener('pointerup', onPointerUp);
        areaEl.addEventListener('pointercancel', onPointerUp);
      })();

      function renderStartMenu(){
        const list = $('#startList');
        list.innerHTML = '';
        APPS.forEach(app => {
          const item = document.createElement('div');
          item.className = 'menu-item';
          item.innerHTML = `
            <div style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;">${app.iconFile ? `<img class="pixel" src="${app.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(app.icon)}</div>
            <div>${t(app.titleKey)}</div>
          `;
          item.addEventListener('click', ()=>{ openApp(app.id); closeStartMenu(); });
          list.appendChild(item);
        });

        const sep = document.createElement('div');
        sep.className = 'menu-sep';
        list.appendChild(sep);

        const logout = document.createElement('div');
        logout.className = 'menu-item';
        logout.innerHTML = `<div style="width:18px;height:18px;">${iconSVG('user')}</div><div>${t('menu.logoff')}</div>`;
        logout.addEventListener('click', ()=>{ closeStartMenu(); showLogin(); });
        list.appendChild(logout);
      }

      function toggleStartMenu(){
        const menu = $('#startMenu');
        const btn = $('#startBtn');
        const isOpen = !menu.classList.contains('hidden');
        if(isOpen) closeStartMenu();
        else { menu.classList.remove('hidden'); btn.classList.add('pressed'); }
      }
      function closeStartMenu(){
        $('#startMenu').classList.add('hidden');
        $('#startBtn').classList.remove('pressed');
      }
      $('#startBtn').addEventListener('click', (e)=>{ e.stopPropagation(); toggleStartMenu(); });

      function defaultWindowRect(){
        const area = $('#desktopArea').getBoundingClientRect();
        const w = clamp(Math.round(area.width * 0.56), 320, 720);
        const h = clamp(Math.round(area.height * 0.58), 240, 640);
        const left = Math.round((area.width - w) * (0.18 + Math.random()*0.18));
        const top = Math.round((area.height - h) * (0.12 + Math.random()*0.18));
        return { left, top, width:w, height:h };
      }

      function openApp(appId){
        const app = APPS.find(a=>a.id===appId);
        if(!app) return;

        if(state.windows.has(appId)){
          const w = state.windows.get(appId);
          w.minimized = false;
          const el = document.getElementById(`win_${appId}`);
          if(el) el.classList.remove('hidden');
          focusWindow(appId);
          renderTaskButtons();
          return;
        }

        const rect = defaultWindowRect();
        const wstate = {
          id: appId,
          title: t(app.titleKey),
          titleKey: app.titleKey,
          icon: app.icon,
          iconFile: app.iconFile || null,
          minimized: false,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          z: ++state.zTop,
        };
        state.windows.set(appId, wstate);
        createWindowElement(wstate);
        focusWindow(appId);
        renderTaskButtons();
      }

      function closeApp(appId){
        state.windows.delete(appId);
        const el = document.getElementById(`win_${appId}`);
        if(el) el.remove();
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
      }
      function minimizeApp(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.minimized = true;
        const el = document.getElementById(`win_${appId}`);
        if(el) el.classList.add('hidden');
        if(state.activeWindowId === appId) state.activeWindowId = null;
        renderTaskButtons();
      }

      function focusWindow(appId){
        const w = state.windows.get(appId);
        if(!w) return;
        w.z = ++state.zTop;
        state.activeWindowId = appId;
        const el = document.getElementById(`win_${appId}`);
        if(el){
          el.style.zIndex = String(w.z);
          $$('.window').forEach(winEl=>{
            winEl.dataset.active = (winEl.id === `win_${appId}`) ? '1' : '0';
            const tb = winEl.querySelector('.titlebar');
            if(tb) tb.style.filter = (winEl.dataset.active==='1') ? 'none' : 'grayscale(0.35) brightness(0.9)';
          });
        }
        renderTaskButtons();
      }

      function createWindowElement(wstate){
        const appId = wstate.id;
        const el = document.createElement('div');
        el.className = 'window';
        el.id = `win_${appId}`;
        el.style.left = wstate.left + 'px';
        el.style.top = wstate.top + 'px';
        el.style.width = wstate.width + 'px';
        el.style.height = wstate.height + 'px';
        el.style.zIndex = String(wstate.z);

        const bodyHTML = (CONTENT[appId] ? CONTENT[appId]() : `<h2>${wstate.title}</h2><p>Sem conteúdo.</p>`);

        el.innerHTML = `
          <div class="frame bevel">
            <div class="titlebar" data-drag="1">
              <div class="title-left">
                <span style="width:16px;height:16px;display:inline-flex;">${wstate.iconFile ? `<img class="pixel" src="${wstate.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(wstate.icon)}</span>
                <strong>${wstate.title}</strong>
              </div>
              <div class="title-controls">
                <div class="wctl bevel" title="${t('win.minimize')}" data-action="min">_</div>
                <div class="wctl bevel" title="${t('win.close')}" data-action="close">×</div>
              </div>
            </div>
            <div class="menubar">
              <span data-i18n="menubar.file">${t('menubar.file')}</span>
              <span data-i18n="menubar.edit">${t('menubar.edit')}</span>
              <span data-i18n="menubar.view">${t('menubar.view')}</span>
              <span data-i18n="menubar.help">${t('menubar.help')}</span>
            </div>
            <div class="content">${bodyHTML}</div>
            <div class="statusbar"><span data-i18n="status.ready">${t('status.ready')}</span><span>BLISS 98</span></div>
          </div>
          <div class="resize" title="${t('win.resize')}"></div>
        `;

        el.addEventListener('mousedown', (e)=>{ e.stopPropagation(); focusWindow(appId); closeStartMenu(); });
        el.addEventListener('click', (e)=>{
          const act = e.target?.dataset?.action;
          if(!act) return;
          e.stopPropagation();
          if(act==='close') closeApp(appId);
          if(act==='min') minimizeApp(appId);
        });

        makeDraggable(el, appId);
        makeResizable(el, appId);

        if(appId === 'mediaplayer') { setTimeout(mpInitInWindow, 0); }

        $('#windows').appendChild(el);
      }

      function makeDraggable(winEl, appId){
        const titlebar = winEl.querySelector('[data-drag="1"]');
        if(!titlebar) return;

        let dragging = false;
        let pointerId = null;
        let startX = 0, startY = 0, startL = 0, startT = 0;

        const onPointerDown = (e)=>{
          // Ignore non-primary mouse buttons
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          // Ignore clicks on window control buttons
          if(e.target && e.target.dataset && e.target.dataset.action) return;

          e.preventDefault();
          dragging = true;
          document.body.classList.add('dragging');
          pointerId = e.pointerId;

          // Focus window when starting drag
          try{ focusWindow(appId); } catch {}

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startL = rect.left;
          startT = rect.top;

          // Capture pointer so drag continues even if the finger leaves the titlebar
          try{ titlebar.setPointerCapture(pointerId); } catch {}

          titlebar.addEventListener('pointermove', onPointerMove);
          titlebar.addEventListener('pointerup', onPointerUp);
          titlebar.addEventListener('pointercancel', onPointerUp);
        };

        const onPointerMove = (e)=>{
          if(!dragging) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;

          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const newL = clamp(startL + dx - area.left, 0, area.width - 80);
          const newT = clamp(startT + dy - area.top, 0, area.height - 60);

          winEl.style.left = newL + 'px';
          winEl.style.top = newT + 'px';

          const w = state.windows.get(appId);
          if(w){ w.left = newL; w.top = newT; }
        };

        const onPointerUp = (e)=>{
          if(pointerId !== null && e.pointerId !== pointerId) return;

          dragging = false;
          pointerId = null;
          document.body.classList.remove('dragging');

          try{ titlebar.releasePointerCapture(e.pointerId); } catch {}

          titlebar.removeEventListener('pointermove', onPointerMove);
          titlebar.removeEventListener('pointerup', onPointerUp);
          titlebar.removeEventListener('pointercancel', onPointerUp);
        };

        // Pointer events handle mouse + touch + pen
        titlebar.addEventListener('pointerdown', onPointerDown);
      }

      function makeResizable(winEl, appId){
        const handle = winEl.querySelector('.resize');
        const EDGE = 6; // px

        let resizing = false;
        let pointerId = null;
        let startX = 0, startY = 0;
        let startW = 0, startH = 0;
        let startL = 0, startT = 0;
        let dir = '';

        function getDir(clientX, clientY){
          const r = winEl.getBoundingClientRect();
          const left = (clientX - r.left) <= EDGE;
          const right = (r.right - clientX) <= EDGE;
          const top = (clientY - r.top) <= EDGE;
          const bottom = (r.bottom - clientY) <= EDGE;

          let d = '';
          if(top) d += 'n';
          else if(bottom) d += 's';
          if(left) d += 'w';
          else if(right) d += 'e';
          return d;
        }

        function cursorFor(d){
          if(d === 'n' || d === 's') return 'ns-resize';
          if(d === 'e' || d === 'w') return 'ew-resize';
          if(d === 'ne' || d === 'sw') return 'nesw-resize';
          if(d === 'nw' || d === 'se') return 'nwse-resize';
          return '';
        }

        function beginResize(e, resizeDir){
          if(e.pointerType === 'mouse' && e.button !== 0) return;
          e.preventDefault();

          resizing = true;
          pointerId = e.pointerId;
          dir = resizeDir;
          document.body.classList.add('dragging');

          const rect = winEl.getBoundingClientRect();
          startX = e.clientX;
          startY = e.clientY;
          startW = rect.width;
          startH = rect.height;
          startL = rect.left;
          startT = rect.top;

          try{ winEl.setPointerCapture(pointerId); } catch {}

          winEl.addEventListener('pointermove', onPointerMove);
          winEl.addEventListener('pointerup', onPointerUp);
          winEl.addEventListener('pointercancel', onPointerUp);
        }

        function onPointerMove(e){
          if(!resizing) return;
          if(pointerId !== null && e.pointerId !== pointerId) return;
          e.preventDefault();

          const area = $('#desktopArea').getBoundingClientRect();
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          const MIN_W = 280;
          const MIN_H = 200;

          let newW = startW;
          let newH = startH;
          let newL = startL;
          let newT = startT;

          if(dir.includes('e')) newW = clamp(startW + dx, MIN_W, 920);
          if(dir.includes('s')) newH = clamp(startH + dy, MIN_H, 780);

          if(dir.includes('w')){
            newW = clamp(startW - dx, MIN_W, 920);
            newL = startL + (startW - newW);
          }
          if(dir.includes('n')){
            newH = clamp(startH - dy, MIN_H, 780);
            newT = startT + (startH - newH);
          }

          // Clamp to desktop bounds
          newL = clamp(newL - area.left, 0, area.width - 60) + area.left;
          newT = clamp(newT - area.top, 0, area.height - 40) + area.top;

          winEl.style.width = newW + 'px';
          winEl.style.height = newH + 'px';
          winEl.style.left = (newL - area.left) + 'px';
          winEl.style.top = (newT - area.top) + 'px';

          const w = state.windows.get(appId);
          if(w){
            w.width = newW;
            w.height = newH;
            w.left = (newL - area.left);
            w.top = (newT - area.top);
          }
        }

        function onPointerUp(e){
          if(pointerId !== null && e.pointerId !== pointerId) return;
          resizing = false;
          pointerId = null;
          dir = '';
          document.body.classList.remove('dragging');

          try{ winEl.releasePointerCapture(e.pointerId); } catch {}

          winEl.removeEventListener('pointermove', onPointerMove);
          winEl.removeEventListener('pointerup', onPointerUp);
          winEl.removeEventListener('pointercancel', onPointerUp);
        }

        // Mouse hover cursor change near edges
        winEl.addEventListener('mousemove', (e)=>{
          if(resizing) return;
          // don't override cursor on controls/titlebar
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          const c = cursorFor(d);
          winEl.style.cursor = c || '';
        });
        winEl.addEventListener('mouseleave', ()=>{
          if(!resizing) winEl.style.cursor = '';
        });

        // Edge/corner resize start
        winEl.addEventListener('pointerdown', (e)=>{
          if(resizing) return;
          // ignore titlebar drag and window control clicks
          if(e.target && e.target.closest && (e.target.closest('.titlebar') || e.target.closest('.wctl'))) return;
          const d = getDir(e.clientX, e.clientY);
          if(!d) return;
          beginResize(e, d);
        });

        // Keep the existing bottom-right handle resize too
        if(handle){
          handle.addEventListener('pointerdown', (e)=>{
            // If we already started edge resize, ignore
            if(resizing) return;
            beginResize(e, 'se');
          });
        }
      }

      function renderTaskButtons(){
        const host = $('#taskButtons');
        host.innerHTML = '';
        const wins = Array.from(state.windows.values()).sort((a,b)=>a.title.localeCompare(b.title));
        wins.forEach(w => {
          const b = document.createElement('div');
          b.className = 'btn bevel';
          const isActive = (state.activeWindowId === w.id && !w.minimized);
          if(isActive) b.classList.add('pressed');
          b.style.maxWidth = '240px';
          b.style.overflow = 'hidden';
          b.style.whiteSpace = 'nowrap';
          b.style.textOverflow = 'ellipsis';
          b.innerHTML = `
            <span style="width:16px;height:16px;display:inline-flex;">${w.iconFile ? `<img class="pixel" src="${w.iconFile}" width="16" height="16" alt="" style="display:block;" />` : iconSVG(w.icon)}</span>
            <span>${w.title}</span>
          `;
          b.addEventListener('click', (e)=>{
            e.stopPropagation();
            closeStartMenu();
            if(w.minimized){
              w.minimized = false;
              const el = document.getElementById(`win_${w.id}`);
              if(el) el.classList.remove('hidden');
              focusWindow(w.id);
            } else if(state.activeWindowId === w.id){
              minimizeApp(w.id);
            } else {
              focusWindow(w.id);
            }
          });
          host.appendChild(b);
        });
      }

      function tickClock(){
        $('#clock').textContent = getDisplayTime();
        setTimeout(tickClock, 1000);
      }

      function enter(){
        const name = $('#username').value.trim();
        if(!name){ $('#username').focus(); return; }
        setUser(name);
        showDesktop();
        if(!state.windows.has('mediaplayer')) openApp('mediaplayer');
        if(!state.windows.has('music')) openApp('music');
        setTimeout(()=>{ mpPlay(); }, 0);
      }

      $('#enter').addEventListener('click', enter);
      $('#username').addEventListener('keydown', (e)=>{ if(e.key==='Enter') enter(); });
      $('#langBtn').addEventListener('click', (e)=>{ e.preventDefault(); toggleLang(); });

      $('#clearProfile').addEventListener('click', ()=>{
        localStorage.removeItem('bliss98_user');
        $('#username').value = '';
        $('#username').focus();
      });

      document.addEventListener('keydown', (e)=>{
        if(e.key==='Escape'){
          closeStartMenu();
          closeCtxMenu();
        }

        // Keyboard context menu (Shift+F10)
        if(e.shiftKey && e.key === 'F10'){
          if($('#desktop').classList.contains('hidden')) return;
          e.preventDefault();
          const area = $('#desktopArea').getBoundingClientRect();
          openCtxMenu(area.left + area.width/2, area.top + area.height/2, 'desktop', null);
        }

        // Basic keyboard navigation inside context menu
        const menu = $('#ctxMenu');
        if(menu && !menu.classList.contains('hidden')){
          const items = Array.from(menu.querySelectorAll('.ctx-item'));
          const idx = items.indexOf(document.activeElement);
          if(e.key === 'ArrowDown'){
            e.preventDefault();
            const next = items[Math.min(items.length-1, Math.max(0, idx+1))] || items[0];
            if(next) next.focus();
          }
          if(e.key === 'ArrowUp'){
            e.preventDefault();
            const prev = items[Math.max(0, idx-1)] || items[items.length-1];
            if(prev) prev.focus();
          }
        }
      });
      document.addEventListener('click', (e)=>{
        const btn = e.target.closest && e.target.closest('[data-set-lang]');
        if(btn && btn.dataset && btn.dataset.setLang){
          setLang(btn.dataset.setLang);
        }

        const ctxBtn = e.target.closest && e.target.closest('[data-ctx-action]');
        if(ctxBtn && ctxBtn.dataset && ctxBtn.dataset.ctxAction){
          e.preventDefault();
          e.stopPropagation();
          handleCtxAction(ctxBtn.dataset.ctxAction);
          closeCtxMenu();
        }
      });

      (function init(){
        const savedLang = localStorage.getItem('bliss98_lang') || 'en';
        state.lang = (savedLang === 'pt') ? 'pt' : 'en';

        const saved = localStorage.getItem('bliss98_user');
        if(saved){ setUser(saved); $('#username').value = saved; }

        state.gridSnap = loadGridSnap();

        // Apply translations immediately (default is English)
        applyI18n();

        showLogin();
        document.addEventListener('click', ()=>{ closeStartMenu(); closeCtxMenu(); });
        const cm = $('#ctxMenu');
        if(cm){
          cm.addEventListener('click', (ev)=>{
            const btn = ev.target.closest && ev.target.closest('[data-ctx-action]');
            if(btn && btn.dataset && btn.dataset.ctxAction){
              ev.preventDefault();
              ev.stopPropagation();
              handleCtxAction(btn.dataset.ctxAction);
              closeCtxMenu();
              return;
            }
            // Prevent clicks inside the menu from bubbling to the document closer
            ev.stopPropagation();
          });
        }
      })();
    </script>
  </body>
</html>
